--- Page 1 ---
From Euler to AI: Unifying Formulas for
Mathematical Constants
Tomer Raz
Michael Shalyt
Elyasheev Leibtag
Rotem Kalisch
Shachar Weinbaum
Yaron Hadad
Ido Kaminer ∗
Technion – Israel Institute of Technology,
Haifa 3200003, Israel
Abstract
The constant π has fascinated scholars throughout the centuries, inspiring numerous
formulas for its evaluation, such as infinite sums and continued fractions. Despite
their individual significance, many of the underlying connections among formulas
remain unknown, missing unifying theories that could unveil deeper understanding.
The absence of a unifying theory reflects a broader challenge across math and
science: knowledge is typically accumulated through isolated discoveries, while
deeper connections often remain hidden. In this work, we present an automated
framework for the unification of mathematical formulas. Our system combines
large language models (LLMs) for systematic formula harvesting, an LLM-code
feedback loop for validation, and a novel symbolic algorithm for clustering and
eventual unification. We demonstrate this methodology on the hallmark case of
π, an ideal testing ground for symbolic unification. Applying this approach to
455,050 arXiv papers, we validate 385 distinct formulas for π and prove relations
between 360 (94%) of them, of which 166 (43%) can be derived from a single
mathematical object—linking canonical formulas by Euler, Gauss, Brouncker,
and newer ones from algorithmic discoveries by the Ramanujan Machine. Our
method generalizes to other constants, including e, ζ(3), and Catalan’s constant,
demonstrating the potential of AI-assisted mathematics to uncover hidden structures
and unify knowledge across domains.
1
Introduction
The earliest rigorous approximation for π dates back to Archimedes around 250 BCE, who established
the bounds 223
71 < π < 22
7 [16]. Modern π approximations employ more sophisticated formulas.
For example, the Chudnovsky algorithm [15], derived from a formula by Ramanujan [48], remains
instrumental for precision records. Similarly, the BBP formula [6] is notable for enabling computation
of specific π digits without requiring prior digits. Such breakthroughs inspired fundamental advances
in computer science, such as high-precision arithmetic [7], evolutionary optimization [35], and elliptic
curve cryptography [39]. Recent efforts led to the development of computer algorithms capable
of generating numerous formula hypotheses and sometimes proofs for mathematical constants
[9, 17, 46].
∗Corresponding author: kaminer@technion.ac.il
Project repository: https://github.com/RamanujanMachine/euler2ai
39th Conference on Neural Information Processing Systems (NeurIPS 2025).
arXiv:2502.17533v3  [math.HO]  16 Nov 2025


--- Page 2 ---
Figure 1: Selected π formulas across centuries.
The plethora of results related to π
discovered over the centuries leads to
a persistent question: How are they
all connected? This question is im-
portant not only for preventing acci-
dental rediscoveries (e.g., Lange’s for-
mula from 1999 [37] had already been
derived by Lord Brouncker in 1656
[42]). Many equivalent formulas ap-
pear vastly different at first glance.
A simple example is Euler’s contin-
ued fraction that provides equivalent
representations of infinite sums [23].
This complex situation underscores
the need for a systematic approach to
unify these relationships.
So far, efforts in AI for mathematics
have focused on automated theorem
proving [44, 56], automated conjec-
ture generation [3, 24, 25, 40, 46], regression [31, 32, 55], and, recently, LLM–tool integrations for
mathematical discovery [27, 29, 50, 59]. However, to date, no work has addressed the problem of
symbolic unification of mathematical knowledge.
In this work, we propose a system for the large-scale harvesting, identification, and unification of
mathematical formulas (Fig. 2). This effort leverages recent advances in content understanding
based on large language models (LLMs), the newly discovered concept of Conservative Matrix
Fields (CMFs) [21, 58], and a novel mathematical algorithm that we call UMAPS for unification
via mapping across symbolic structures, using the math of coboundary equivalence for finding and
proving relations between formulas. To demonstrate this methodology, we selected the symbolic case
study of formulas calculating π. A total of 385 unique π formulas were extracted from the literature
and validated, of which 43% were found to correspond to different trajectories within a single CMF
(Section 5). We expect near-future improvements of our algorithm to classify all the π formulas into
one or just a few unique CMFs that unify all knowledge about π calculation.
Mathematical 
knowledge
Harvesting
Retrieval
Extraction
Validation
Clustering
Canonical form
Dynamical metrics
Coboundary algorithm
Unification
2021
1813 Gauss
1655 Brouncker
1914 Ramanujan
Figure 2: Automated methodology for unifying mathematical knowledge. A large corpus of
mathematical formulas is harvested, retrieving formulas that are each translated to executable code
for validation. The formulas are then clustered by conversion into their canonical forms, and unified
using a novel symbolic computational algorithm that proves their relations.
To the best of our knowledge, this work is the first LLM–symbolic-tool integration for discovery in
number theory, and possibly the first LLM integration with a proprietary research-grade computer
algebra system. The success of this study highlights the prospects of automated unification of vast
mathematical knowledge. Beyond the example of π, we applied our algorithm to other mathematical
constants like e, ζ(3), and Catalan’s constant, and to a variety of formula structures, showcasing its
broad potential. Appendix A provides a glossary of key terms used throughout the paper.
2


--- Page 3 ---
2
Mathematical background
2.1
Recurrences as universal representations of formulas for mathematical constants
A wide range of formulas—including infinite sums, products, and continued fractions—can be
converted into recurrences, providing a cohesive framework for unification. A function un satisfies a
recurrence of order m if un = a1,nun−1 + a2,nun−2 + . . . + am,nun−m, which can be represented
via the associated companion matrix:
CM(n) :=






0
0
. . .
0
am,n
1
0
. . .
0
am−1,n
0
1
. . .
0
am−2,n
...
...
...
...
...
0
0
. . .
1
a1,n






(1)
By incrementally multiplying the companion matrix over n steps, we get the matrix:
Qn
i=1 CM(i) =






p1,n−m
. . .
p1,n−1
p1,n
p2,n−m
. . .
p2,n−1
p2,n
p3,n−m
. . .
p3,n−1
p3,n
...
...
...
...
pm,n−m
. . .
pm,n−1
pm,n






(2)
p1,n, . . . pm,n are solutions to the recurrence for the initial conditions pi,j = δj
i . Other solutions for
different initial conditions can be written as linear combinations of these.
Recurrences evaluate a desired constant L either directly limn→∞un = L (e.g., for infinite sums), or
as ratios limn→∞
pn
qn = L with pn and qn being two solutions for the recurrence (e.g., for continued
fractions). In the special case of a second-order recurrence, un = anun−1 + bnun−2, and any pair of
solutions is associated with a formula in the form of a continued fraction:
b1
a1 +
b2
... + bn
an
= pn
qn
(3)
When the functions an = a(n) and bn = b(n) are polynomials, the formula above is known as a
Polynomial Continued Fraction (PCF), denoted by PCF (a(n), b(n)). See details in Appendix E.
2.2
The dynamical metrics describing each formula
A formula of a mathematical constant L provides a converging sequence of rational numbers pn
qn
(known as a Diophantine approximation). The formula can be characterized by dynamical metrics
capturing properties such as its convergence rate. A recent paper [52] proposed using such metrics
for formula discovery and clustering. Here we use the metrics of convergence rate and irrationality
measure. The convergence rate is defined as:
r = lim
n→∞
1
n log
L −pn
qn

(4)
When examining the connection of two candidate formulas, the ratio of their r values can hint
whether one is a transformation of a subsequence of the other (see Appendix E.5 for an example).
The irrationality measure of pn
qn is defined as the limit δ = limn→∞δn, where
δn = −1 −
log
L −pn
qn

log |qn|
(5)
We found that for two formulas to have the same δ is the strongest indication of a possible relation,
since δ is invariant under many transformations and choice of subsequences. Below, our UMAPS
algorithm is used to derive and prove a relation once a pair of formulas share the same r and δ.
2.3
Conservative Matrix Fields (CMFs)
The CMF is the mathematical structure that generalizes formulas of a particular constant, originally
found by generalizing PCFs [21], and later realized to be more general (Appendix G). To exemplify the
3


--- Page 4 ---
concept, we focus on the CMF of π. This CMF is 3D, i.e., consisting of three matrices Mx, My, Mz
with rational function entries in the variables (x, y, z), satisfying:
Mx(x, y, z)My(x + 1, y, z) = My(x, y, z)Mx(x, y + 1, z)
Mx(x, y, z)Mz(x + 1, y, z) = Mz(x, y, z)Mx(x, y, z + 1)
My(x, y, z)Mz(x, y + 1, z) = Mz(x, y, z)My(x, y, z + 1)
This property describes the path-independence of the transition between two points in a 3D lattice
(lattice illustrated in Fig. 5b), in analogy to a conservative vector field. The CMF satisfies the
properties of a discrete flat connection [11]. For an explanation of how formulas reside as directions
within the CMF, see Appendix G.1. A notable feature of the CMF is that pairs of formulas found to
be parallel trajectories with different initial points correspond to two matrices that are coboundary
equivalent.
Many of the known π formulas will be shown to reside within a single CMF (details in Appendix G.2):
Mx =
1
y
1
x
2x+y−2z+2
x

My =
1
x
1
y
x+2y−2z+2
y

Mz =
 z(−x−y+z)
(y−z)(x−z)
zxy
(y−z)(x−z)
z
(y−z)(x−z)
−z2
(y−z)(x−z)
!
(6)
3
Methodology for symbolic unification of formulas
3.1
Harvesting: large-scale retrieval of formulas from the literature
equations
1656
articles
scraping
retrieval
278,242,506
equations
equations
455,050
121,662
Harvesting scheme
validate
via PSLQ
formulas
660
Example
Guillera, Jesús. "Bilateral sums related to Ramanujan-like series." arXiv
preprint arXiv:1610.04839 (2016).
"\sum_{n = 0}^{\infty} (-1)^n \frac{(\frac12)_n (\frac14)_n
(\frac34)_n}{(1)_n^3} \frac{21460n + 1123}{882^{2n}} = \frac{3528}{\pi}."
True
series
1122.99727845641348 == 3528 / π
computes π?
series or
continued
fraction?
formulas
385
term: (-1)**n * RisingFactorial(1/2, n) * RisingFactorial(1/4, n)
* RisingFactorial(3/4, n) / (RisingFactorial(1, n)**3) * (21460*n + 1123) / 882**(2*n)
start: 0
variable: n
(-14681/1695923712 - (1946417*n)/89035994880 - (1366829*n^2)/66776996160 - (46871*n^3)/5564749680 
- n^4/777924)*f[n] + (-71386776899/8479618560 - (1836628904911*n)/89035994880 
- (1222951171699*n^2)/66776996160 - (39244403773*n^3)/5564749680 - (777923*n^4)/777924)*f[1 + n] 
+ (45166/5365 + (110669*n)/5365 + (196509*n^2)/10730 + (151343*n^3)/21460 + n^4)*f[2 + n] = 0
extract
to recurrence
formulas
385
Figure 3: Pipeline for automated harvesting of mathemat-
ical formulas (left), exemplified using one of the analyzed
π formulas (right). (a) Equations are scraped from papers
on arXiv. (b) Regular expressions on the LATEX strings re-
trieve series and continued fraction patterns that contain π
as the only irrational number (see Appendix I.3). (c) Zero-
shot classification using OpenAI’s GPT-4o mini identifies
formulas calculating the constant π. Then, OpenAI’s GPT-4o
identifies the formula type (series, continued fraction, or nei-
ther). (d) Extraction of the series’ summand or the continued
fraction’s partial numerator and partial denominator, using
GPT-4o. The formula is then converted to code. (e) Formulas
are computed and validated using the integer relation finder
algorithm PSLQ. (f) The formulas are converted to canonical
recurrences using RISC’s tool for fitting recurrences [33].
The first challenge lies in the natu-
ral language processing of formulas.
We analyze the LATEX source code of
455,050 arXiv articles by combining
regular expressions and LLMs, ex-
tracting all mathematical expressions,
resulting in 278,242,506 strings. Fil-
tering for expressions containing the
π symbol retrieves 121,662 π-related
equations. The widespread use of the
symbol π in scientific literature means
that most occurrences are unrelated to
calculating the constant itself. To ad-
dress this, and keeping in mind that
there is a priori very little data on
what successful formulas’ LATEX looks
like, each potential formula is clas-
sified as computing π or not, using
GPT-4o mini [41] (chosen for its cost-
effectiveness), reducing the number of
candidates to 3367. Next, GPT-4o cat-
egorizes formulas by type: series, con-
tinued fraction, or neither—resulting
in 1656 formula candidates.
3.2
Harvesting:
extraction and validation
The extraction and validation stages
rely on an LLM-code feedback loop
that feeds a PSLQ algorithm. Each
equation,
represented as a LATEX
string, must then be parsed into a
Computer Algebra System (CAS) for
further manipulations (in our case,
SymPy [38]). Automatically extract-
ing algebraic forms from LATEX strings
is especially complicated due to var-
ied LATEX patterns, which are difficult
4


--- Page 5 ---
to systematically convert to executable code using a predefined logic. LLMs help us overcome these
obstacles by processing text contextually and attending to relevant parts of the text, solving the
natural language processing task that may have required elaborate rules [14, 47]. Specifically, we
use OpenAI’s GPT-4o to translate relevant LATEX into executable mathematical code [22, 43, 61] (see
Appendix I for the exact prompts used). To correct for (common) mistakes in the LLM-generated
formula code, we apply an LLM-code feedback loop for code validation: errors are sent back to the
LLM along with the faulty code to correct it, up to three times (see Appendix I.6.3).
We validate that each extracted formula computes the constant π by running the formula code to get a
numerical approximation and then applying PSLQ, an integer relation algorithm [26]. Limit values
are not extracted directly from the LATEX string for validation, since we found that GPT-4o got them
wrong in some cases (see Table 14). Instead, the PSLQ approach fixes these critical GPT mistakes
and reproduces the intended formulas. Out of the 660 candidates, 385 were validated as π formulas
and passed on for canonicalization (details in Appendix I.5).
3.3
Clustering: using the canonical form
The first unification step is converting each formula to its canonical form: the simplest linear
recurrence with polynomial coefficients (Appendix E.4.1). Automated algebraic capabilities are
unpredictable in solving such tasks. Thus, we use a computational method for converting the formulas
to polynomial recurrences: a Mathematica package by RISC [33] that fits polynomial-coefficient
linear recurrences to each sequence of rational numbers. The resulting recurrences are validated
numerically and passed to a Maple package to guarantee order minimality [57, 60], thus finding the
provably minimal polynomial recurrence. Out of the 385 validated formulas (Section 3.1), 380 are
found to have representations as order-2 recurrences, and 5 as order-3 recurrences, which can also be
addressed as we show in Appendix B.6 and Appendix C.3.
The same canonical form captures a wide range of formulas, continued fractions and infinite sums.
Thus, the conversion to canonical forms automatically unifies different formulas, yielding 149
different order-2 canonical forms and 4 order-3 canonical forms for π, 153 in total, from 385 formulas
(selected examples in Table 1).
Table 1: Canonical form representation. Converting formulas to their canonical forms shows
equivalence of different-looking expressions (e.g. 1,2), leaving the less-trivial connections for the
later steps of the algorithm. Additional details in Appendix C.4.
Formula
Value
arXiv source
Canonical form (CF)
CF value
Initial conditions
1
P∞
n=0
n!
Qn
i=1(2i+1)
π
2
1806.03346
PCF(3n + 1, n(1 −2n))
2
π

0
1
1
1

2
P∞
n=1
2n
n(
2n
n )
π
2
2010.05610
PCF(3n + 1, n(1 −2n))
2
π

0
1
1
1

3
P∞
n=0
(−1)n
2n+1
π
4
2404.15210
PCF(2, (2n −1)2)
1 + 4
π

0
1
1
1

4
P∞
n=1
(−1)n+1
n(n+1)(2n+1)
π −3
2206.07174
PCF(6, (2n + 1)2)
1
π−3

0
1
1
6

5
P∞
n=1
4n(12n−5)
(2n−1)(
4n
2n)
3π+4
2
2204.08275
*
−42π−196
3π+4

0
70
−1
15

* PCF(240n3 + 164n2 −54n −29, −9216n6 + 12288n5 + 11264n4 −15520n3 −764n2 + 3802n −714)
3.4
Clustering: using the dynamical metrics
The clustering stage is a heuristic to guide which formulas should be attempted to be proven equal
using UMAPS. Formulas with the same metrics are likely to be related to the same constant [52].
The metrics also indicate a more intricate connection, enabling to unify formulas in a systematic way
that proves an analytical transformation between them. Canonical-form formulas are first compared
to each other using the irrationality measure δ (Fig. 4a), which is the most reliable indicator for
a potential equivalence. Every new formula is first evaluated relative to directions in the CMF
corresponding to recurrences with the same δ. This search can be improved by using gradient descent
on the direction parameters, because δ is found to be continuous [21].
5


--- Page 6 ---
We found that δ is not sufficient to imply equivalence, and thus we complement it using the ratio of
convergence rates rA : rB. Canonical form A is folded (Appendix E.5) by rB and canonical form
B is folded by rA (Fig. 4b), making them converge at the same rate. The next step is finding their
precise algebraic relation using UMAPS.
3.5
Unification: using the UMAPS algorithm for coboundary equivalence
Figure 4: The matching algorithm: connecting
polynomial linear recurrences. This algorithm is
demonstrated here for polynomial continued frac-
tions (PCFs) but can be generalized to any linear
polynomial recurrence. (a) Compute the dynam-
ical metrics [52] for the two PCFs (irrationality
measures δA, δB and the convergence rates ratio
rA/rB). The δ metrics are used to identify pos-
sible connections, as only if δA = δB, the PCFs
can be related via coboundary (in practice, we test
for them to be within 0.06 of each other). (b) Fold
PCFA by rB and PCFB by rA (Appendix E.5).
UMAPS (c)-(e): (c) Solve for a general Möbius
transform (a 2×2 matrix U(1)) that once applied to
the limit of PCFB equates it to the limit of PCFA.
(d) Representing the PCFs in matrix form (A(n)
and B(n)), propagate the coboundary matrix via
the relation U(n + 1) = A(n)−1 · U(n) · B(n) up
to U(N) (N = 40 was sufficient for our runs, see
Appendix D). (e) Assume the general form of U(n)
to have rational-function entries with polynomial
degree up to
 N−1
2

and solve for their coefficients
using normalized U(1, . . . , N). If such a solution
is found and validated, the PCFs are coboundary-
related. See Appendix C for more details.
Our algorithm for unification via mapping
across symbolic structures (UMAPS) relies on
the established concept of coboundary equiva-
lence (Appendix E.4), however, no specialized
coboundary solver existed prior to this work.
A(n), B(n) ∈PGLm (Q(n)) are coboundary
equivalent if there exist a matrix U(n) such that
A(n) · U(n + 1) = U(n) · B(n)
(7)
This definition carries to recurrences when
their
companion
matrices
(Eq.
(1))
are
coboundary equivalent (Fig. 5a,d) and then:
(Qn
i=1 A(i)) · U(n + 1) = U(1) · (Qn
i=1 B(i)) .
Since any matrix with rational function coef-
ficients can be scaled to have polynomial co-
efficients, we can write that A(n), B(n) ∈
GLm(Q[n]) are coboundary equivalent if there
exist a matrix U(n) ∈GLm(Q[n]) and polyno-
mials pA(n), pB(n) ∈Q[n] such that
pA(n) · A(n) · U(n + 1) = pB(n) · U(n) · B(n)
(8)
Finding a coboundary between two polynomial
matrices is inherently a non-linear problem due
to the product of unknown polynomials pA
and pB with unknown coboundary matrix U.
Moreover, the degree of each polynomial is not
known. Despite the non-linearity, we found a
coboundary solver algorithm for general order
m (Appendix C.3).
UMAPS finds the solution without solving non-
linear equations, instead leveraging the recur-
rence limits to compute a sequence of empirical
coboundary matrices, whose elements are fitted
to rational functions [53]. The algorithm relies
on the following lemma:
Lemma
1.
(A
necessary
condition
on
the coboundary equivalence matrix.)
Let
LA
=
lim
n→∞PCF (a(n), b(n)) and LB
=
lim
n→∞PCF (c(n), d(n)) be converging PCFs
with
associated
companion
matrices
A(n), B(n)
∈
PGL2 (Q(n)).
If A(n) is
coboundary to B(n), then LA and LB are re-
lated through a rational Möbius transformation.
Moreover, if U(n) is the coboundary matrix,
then
LA = U(1)(LB) (U(1) applied to LB
as a Möbius transformation).
A proof and generalization to higher-order recurrences (Lemma 4), as well as a proof of the uniqueness
of the coboundary matrix (Lemma 5), are detailed in Appendix F. These combine to show that UMAPS
is sufficient to solve for the coboundary matrix, as stated in Corollary 1 (proof in Appendix C.3).
6


--- Page 7 ---
Figure 5: Coboundary equivalence: the mathematical framework connecting different formulas
once cast into their canonical forms. (a) The coboundary condition A(n) · U(n + 1) = U(n) ·
B(n) recasts formulas as (b,c) parallel trajectories in a CMF. (d) Example of two coboundary-
equivalent formulas, presenting their coboundary matrices and limits, which constitute proof of a
novel equivalence.
Corollary 1. (Sufficiency of UMAPS.) If a coboundary matrix exists for two matrices and every
rational-function entry of the coboundary matrix has polynomials of degree at most d, then running
UMAPS with N ≥2d + 1 suffices to recover the coboundary matrix.
Fig. 4 summarizes the flow of matching two canonical form formulas. Using this method, we
find that formulas 1,2 and 5 from Table 1 are equivalent and that formulas 3,4 are also equivalent.
Refer to Appendix B.1 for descriptions of how the algorithm is applied to these formulas, and refer
to Appendix C for a listing of the algorithms involved. A study of the algorithms’ sensitivity to
hyperparameters is provided in Appendix D. The same procedure is applied to each canonical form
formula, measuring its δ value and relying on its continuity as a function of direction in the CMF
to locate worthy directions that yield potential formula pairs for the coboundary algorithm. The
matching algorithm is then applied between formulas and representative recurrences from the CMF.
Finding a match between a formula and a CMF representative proves the formula is generated by the
CMF. The full list of results is provided in Appendix J. Selected results for π are detailed in Section 5.
4
Benchmarking
4.1
Comparison to other methods for symbolic unification
Our work is first to address the problem of symbolic unification at scale, thus there are no standard
benchmarks for performance comparison. Leading LLMs are generally unable to address the full
challenge. As an example, we compare our equivalence detection and proving capabilities to those
of LLMs: We tasked 2 leading LLMs—GPT-4o and Gemini 2.5 Pro Preview—with identifying and
proving 10 formula-pair equivalences proven by our algorithm (Table 2). The formulas are chosen
such that each pair has equal dynamical metrics (r, δ) after folding, which is the simpler situation to
prove (parallel trajectories in the CMF). Even with these simpler tasks, the LLMs exhibit only limited
success. We did not find cases in which any LLM succeeded in finding relations between a pair of
formulas without equal dynamical metrics.
4.2
Comparison of LLM model performance
We utilize LLMs for classification and extraction in two different ways. Table 3 compares the
performance of three choices for the extractor LLM, which we found to be the more sensitive choice,
as it is used for the more advanced LLM-code feedback loop. A ground truth is established by
merging the validated formulas (Section 3.2) found by the three compared LLMs.
7


--- Page 8 ---
Table 2: LLM performance when detecting and proving equivalence in a random set of 10 formula
pairs of equal dynamical parameters (Appendix H). All LLM proofs were validated manually.
LLM
Successful detections
Correct proofs
GPT-4o
1/10
2/10
Gemini 2.5 Pro Preview
8/10
5/10
Table 3: Performance of different extractor LLM choices in terms of successfully harvested formulas.
The LLM errors are split to “faulty code" for code that did not run, and “symbolic mistake" for
incorrect identification of some of the formula constituents like continued fraction polynomials. The
bold row marks the choice of LLMs used for all the rest of the results in this paper.
LLM classifier
LLM extractor
Successful extractions
Faulty code
Symbolic mistake
GPT-4o mini
GPT-4o
289 (97.6%)
2 (0.7%)
5 (1.7%)
GPT-4o mini
Claude 3.7 Sonnet
266 (89.9%)
21 (7.1%)
9 (3.0%)
GPT-4o mini
GPT-4o mini
206 (69.6%)
70 (23.6%)
20 (6.8%)
5
Results
5.1
Example equivalences among famous formulas
Our automated system proves previously unknown equivalences between formulas. Among the
formulas connected are famous examples, such as one of Ramanujan’s 1914 formulas, as well as
Lord Brouncker’s, Euler’s, and Gauss’s PCFs from the 17th, 18th, and 19th centuries [23, 28, 42]. For
example, the following series found by Ramanujan in 1914 [48],
4
π = P∞
k=0(−1)k ( 1
2)k( 1
4)k( 3
4)k
(1)3
k
· (1123 + 21460k) ·
  1
882
2k+1
(9)
was proven equivalent (Appendix B.4) to a newer series from a paper published in 2020 [54]:
341446000
π
= P∞
k=0
(
2k
k )
2(
4k
2k)
(k+1)(2k−1)(4k−1)(−210214)k ·
 1424799848k2 + 1533506502k + 1086885699

(10)
This equivalence demonstrates how two previously distinct mathematical expressions, discovered
over a century apart, are now proven to be equivalent by an automated process.
Fig. 5d proves the equivalence of another pair of famous formulas: (1) PCF(2n+3, n(n+2)), one of
the first computer-discovered π formulas from 2021 [46]. (2) PCF(2n + 1, n2), published by Gauss
in 1813 [28] and provided at the time an especially efficient way to calculate digits of π.
5.2
Formulas unified by a Conservative Matrix Field (CMF)
The CMF of π, Eq. (6), captures most of the harvested formulas (Table 4), with selected examples
presented graphically in Fig. 6 along with their corresponding trajectories.
Table 4: Summary of unification results, among all validated formulas (left columns) and among
the canonical forms (right columns). Formulas are harvested from 140 arXiv papers (Table 15), of
which 137/140 (98%) have at least one formula proved connected by UMAPS and 70/140 (50%)
have a formula residing in the same CMF.
Found relation
Same CMF
Found relation (canonical)
Same CMF (canonical)
360/385 (94%)
166/385 (43%)
136/153 (89%)
81/153 (53%)
The full list of canonical forms captured by the CMF appears in Table 16. Improvements in UMAPS
are likely to connect additional formulas (Table 17) to the same CMF.
5.3
Unification of formulas beyond π
Going beyond π, we automatically identified equivalent formulas for e, ζ(3), and Catalan’s con-
stant—demonstrating the generality of the approach. Consider these two formulas for Apéry’s
constant, the Riemann zeta function value ζ(3):
8


--- Page 9 ---
Figure 6: Formula unification by a Conservative Matrix Field (CMF). Numerous π formulas
harvested from the literature are automatically arranged as trajectories in a 3D CMF. These formulas
include famous ones by Gauss, Euler, and Lord Brouncker. The full list of unified formulas and
their canonical forms is available in Table 16. Each cluster (large dashed circles) denotes formulas
connected by coboundary, representing parallel trajectories or overlapping trajectories. The number
at each cluster center is the δ of all formulas in that cluster. Arrows show trajectory directions. Note
that multiple formula clusters can have the same δ value without being coboundary, showing that
sharing δ is necessary but not sufficient for formulas being coboundary-related.
ζ(3) =
∞
X
n=1
1
n3
5
4 −ζ(3) =
∞
X
n=2
1
n3(n2 −1)
(11)
The second formula [36] has faster convergence compared to the classical definition of ζ(3), though
both converge polynomially. Our automatic procedure proves their equivalence by the coboundary
transform and unifies them in the ζ(3) CMF (detailed in Appendix B.2).
As another example, the following two PCFs for Catalan’s constant [13] are also proven equivalent
by UMAPS (Appendix B.5).
1
2 −2G = 3 +
22
1 +
22
3 +
42
1 + 42
· · ·
1
2G −1 = 1
2 +
12
1
2 +
1 · 2
1
2 +
22
1
2 + 2 · 3
· · ·
(12)
A natural next step is to conduct exhaustive searches for other well-known constants, and fundamental
mathematical structures in fields such as physics and computer science. See Appendix B.3 for e
examples.
5.4
Formulas generated via a Conservative Matrix Field (CMF)
A sample of 1693 distinct π formulas was generated from the π-CMF (per Appendix C.5). The
CMF permits a new method of comparing between formulas, using the normalized convergence rate,
defined r/ℓ1(t), where r is the convergence rate from Eq. (4), t is a trajectory and ℓ1 is the ℓ1-norm.
57 of the formulas generated in our runs shared the best normalized r of 1.76, such as the formula
9


--- Page 10 ---
10
4−π = 12 +
−81
238 +
−6500
968 +
−67473
... + n2(−64n4 −96n3 + 12n2 + 52n + 15)
48n3 + 108n2 + 70n + 12 + ...
arising from trajectory (−1, −1, 0). By comparison, the best pre-existing formula unified by our CMF
has normalized convergence of 0.88 (the (1, 1, 2) direction, see Table 16). Details in Appendix G.6.
6
Discussion
6.1
Limitations
Currently, the harvesting step relies on the LLM’s ability to interpret and contextualize mathematical
LATEX strings. This step likely introduces data loss and false negatives in formula classification.
Improvements in prompt engineering and in validation techniques will enhance the robustness of this
LLM use. As more advanced LLMs become available, this step will become increasingly reliable.
Formulas often include additional symbols other than summation indices, like variables defined in
the text surrounding the formula, which should be extracted and substituted into formula evaluation.
We made several such substitutions manually to test the rest of the pipeline for these special cases.
Future improvements of the unification pipeline can address this limitation by more advanced use of
LLMs and automated validation.
Most formulas analyzed in this work are series or continued fractions. However, UMAPS and all the
other steps in our harvesting and clustering processes are applicable more broadly (to any formula
that generates a sequence of rational approximations for a given constant, e.g., deeper recurrences).
Expanding the system to accommodate additional cases is a promising direction for future work.
The same unification pipeline shown here could apply to the vast family of D-finite constants by
finding their corresponding CMFs [58].
6.2
Outlook
Increasing the dimension and rank of the π-CMF, along with further improvements to UMAPS [2], is
likely to yield a higher percentage of unified formulas in the near future. A planned future study will
employ the CMF to systematically search for fast-converging and irrationality-proving formulas.
Looking forward, the same approach of collection, analysis, and organization of mathematical
knowledge could help establish rigorous connections between different branches of mathematics.
The methodology presented in this work could help develop more general frameworks for identifying
connections between different scientific theories through their mathematical representations. As the
volume of information grows at an accelerating pace, finding automated ways to unify knowledge
will become increasingly essential, especially with the goal of providing more intuitive understanding
on complex concepts.
Pairing LLMs with pre-existing and novel tools for symbolic and numerical mathematics enabled the
automated discoveries in this paper. We believe this LLM–tool integration scheme will continue to
advance AI for mathematics and science in the coming years.
10


--- Page 11 ---
Acknowledgments
This research received support through Schmidt Sciences, LLC.
References
[1] Kunle Adegoke and Olawanle Layeni. The higher derivatives of the inverse tangent function
and rapidly convergent BBP-type formulas. arXiv preprint arXiv:1603.08540, 2016.
[2] After this work was accepted, Jakob Obrovsky from the Research Institute for Symbolic
Computation (RISC), Johannes Kepler University, proposed a stronger algorithm for finding
more general coboundary equivalences. This algorithm will be published in a future work.
[3] Alberto Alfarano, François Charton, and Amaury Hayat. Global lyapunov functions: a long-
standing open problem in mathematics, with symbolic transformers. In Advances in Neural
Information Processing Systems (NeurIPS), volume 37, pages 93643–93670. Curran Associates,
Inc., 2024.
[4] An interactive online demonstration of UMAPS and the matching algorithm is available at the
following Google Colab link.
[5] arXiv.org submitters. Kaggle arXiv dataset, 2024.
[6] David Bailey, Peter Borwein, and Simon Plouffe. On the rapid computation of various polylog-
arithmic constants. Mathematics of Computation, 66, 05 1996.
[7] D.H. Bailey, R. Barrio, and J.M. Borwein. High-precision computation: Mathematical physics
and dynamics. Applied Mathematics and Computation, 218(20):10106–10121, 2012.
[8] Daniel Barsky, Vicente Muñoz, and Ricardo Pérez-Marco. On the genesis of BBP formulas.
arXiv preprint arXiv:1906.09629, 2019.
[9] Itay Beit-Halachmi and Ido Kaminer. The ramanujan library – automated discovery on the
hypergraph of integer relations. In International Conference on Learning Representations
(ICLR), 2025.
[10] N. Ben David, G. Nimri, U. Mendlovic, Y. Manor, C. De la Cruz Mengual, and I. Kaminer.
On the connection between irrationality measures and polynomial continued fractions. Arnold
Mathematical Journal, 10(4):529–566, 2024.
[11] Alexander I. Bobenko and Yuri B. Suris. Discrete Differential Geometry: Integrable Structure,
volume 98 of Graduate Studies in Mathematics, chapter 6.2. American Mathematical Society,
Providence, Rhode Island, first edition, 2008.
[12] Jairo Bochi, Yakov Pesin, and Omri Sarig. Complete regularity of linear cocycles and the baire
category of the set of lyapunov-perron regular points. arXiv preprint arXiv:2409.01798, 2024.
[13] David M Bradley. Representations of Catalan’s constant, 2001.
[14] Tom Brown et al. Language models are few-shot learners. In Advances in Neural Information
Processing Systems (NeurIPS), volume 33, pages 1877–1901. Curran Associates, Inc., 2020.
[15] D. V. Chudnovsky and G. V. Chudnovsky. The computation of classical constants. Proceedings
of the National Academy of Sciences (PNAS), 86(21):8178–8182, 1989.
[16] Abhishek Dhar et al. How archimedes showed that π is approximately equal to 22/7. arXiv
preprint arXiv:2008.07995, 2020.
[17] Robert Dougherty-Bliss and Doron Zeilberger. Automatic conjecturing and proving of exact
values of some infinite families of infinite continued fractions. The Ramanujan Journal, 61:
31–47, 2023.
[18] Pedro Duarte and Silvius Klein. Lyapunov Exponents of Linear Cocycles: Continuity via Large
Deviations, volume 3 of Atlantis Studies in Dynamical Systems. Atlantis Press (Zeger Karssen),
Paris, first edition, 2016.
11


--- Page 12 ---
[19] Saber Elaydi. An Introduction to Difference Equations. Undergraduate Texts in Mathematics.
Springer Nature, New York, third edition, 2006.
[20] Rotem Elimelech, Ofir David, Carlos De la Cruz Mengual, Rotem Kalisch, Wolfgang Berndt,
Michael Shalyt, Mark Silberstein, Yaron Hadad, and Ido Kaminer. Algorithm-assisted discovery
of an intrinsic order among mathematical constants. arXiv preprint arXiv:2308.11829, 2023.
[21] Rotem Elimelech, Ofir David, Carlos De la Cruz Mengual, Rotem Kalisch, Wolfgang Berndt,
Michael Shalyt, Mark Silberstein, Yaron Hadad, and Ido Kaminer. Algorithm-assisted discovery
of an intrinsic order among mathematical constants. Proceedings of the National Academy of
Sciences (PNAS), 121(25):e2321440121, 2024.
[22] Hasan Ferit Eniser, Hanliang Zhang, Cristina David, Meng Wang, Maria Christakis, Brandon
Paulsen, Joey Dodds, and Daniel Kroening. Towards translating real-world code with llms: A
study of translating to rust. arXiv preprint arXiv:2405.11514, 2024.
[23] Leonhard Euler. Introductio in analysin infinitorum, volume 2. 1748.
[24] Siemion Fajtlowicz. On conjectures of graffiti. In J. Akiyama, Y. Egawa, and H. Enomoto,
editors, Graph Theory and Applications, volume 38 of Annals of Discrete Mathematics, pages
113–118. Elsevier, 1988.
[25] Alhussein Fawzi et al. Discovering faster matrix multiplication algorithms with reinforcement
learning. Nature, 610:47–53, 2022.
[26] Helaman R. P. Ferguson, David H. Bailey, and Paul Kutler. A Polynomial Time, Numerically
Stable Integer Relation Algorithm. Ames Research Center, 1998.
[27] Luyu Gao et al. PAL: Program-aided language models. In Proceedings of the 40th International
Conference on Machine Learning (ICML), volume 202 of Proceedings of Machine Learning
Research, pages 10764–10799. PMLR, 23–29 Jul 2023.
[28] Carl Friedrich Gauss. Werke, vol. 3, 1813.
[29] Zhibin Gou, Zhihong Shao, Yeyun Gong, Yelong Shen, Yujiu Yang, Minlie Huang, Nan Duan,
and Weizhu Chen. ToRA: A tool-integrated reasoning agent for mathematical problem solving.
In International Conference on Learning Representations (ICLR), 2024.
[30] Jesus Guillera. History of the formulas and algorithms for pi. arXiv preprint arXiv:0807.0872,
2008.
[31] Milad Hashemi et al. Can transformers do enumerative geometry? In International Conference
on Learning Representations (ICLR), 2025.
[32] Pierre-Alexandre Kamienny, Stéphane d’Ascoli, Guillaume Lample, and François Charton. End-
to-end symbolic regression with transformers. In Advances in Neural Information Processing
Systems (NeurIPS), volume 35, pages 10269–10281. Curran Associates, Inc., 2022.
[33] Manuel Kauers and Christoph Koutschan. Guessing with little data. In Proceedings of the 2022
International Symposium on Symbolic and Algebraic Computation, ISSAC ’22, page 83–90.
ACM, July 2022.
[34] Walter G. Kelley and Allan C. Peterson. Difference equations: An introduction with applications.
Harcourt/Academic Press, San Diego, CA, second edition, 2000.
[35] John R. Koza. Genetic programming as a means for programming computers by natural
selection. Statistics and Computing, 4:87–112, 1994.
[36] Ernst Eduard Kummer. Eine neue Methode, die numerischen Summen langsam convergirender
Reihen zu berechnen. Walter de Gruyter, Berlin/New York, 1837.
[37] L. J. Lange. An elegant continued fraction for π. American Mathematical Monthly, 106:
456–458, 1999.
12


--- Page 13 ---
[38] Aaron Meurer et al. Sympy: symbolic computing in python. PeerJ Computer Science, 3:e103,
January 2017.
[39] Victor S. Miller. Use of elliptic curves in cryptography. In Hugh C. Williams, editor, Advances
in Cryptology — CRYPTO ’85 Proceedings, pages 417–426, Berlin, Heidelberg, 1986. Springer
Berlin Heidelberg.
[40] Alexander Novikov et al. AlphaEvolve: A coding agent for scientific and algorithmic discovery.
Technical report, Google DeepMind, May 2025.
[41] OpenAI. GPT-4 technical report. arXiv preprint arXiv:2303.08774, 2023.
[42] Thomas J. Osler. Lord brouncker’s forgotten sequence of continued fractions for pi. International
Journal of Mathematical Education in Science and Technology, 41(1):105–110, 2010.
[43] Rangeet Pan et al. Lost in translation: A study of bugs introduced by large language models
while translating code. In Proceedings of the IEEE/ACM 46th International Conference on
Software Engineering, ICSE ’24, New York, NY, USA, 2024. Association for Computing
Machinery.
[44] Peter Paule and Carsten Schneider. Creative telescoping for hypergeometric double sums.
Journal of Symbolic Computation, 128:102394, 2025.
[45] Marko Petkovsek, Herbert S. Wilf, and Doron Zeilberger. A=B. AK Peters Ltd, 1996.
[46] Gal Raayoni, Shahar Gottlieb, Yahel Manor, George Pisha, Yoav Harris, Uri Mendlovic, Doron
Haviv, Yaron Hadad, and Ido Kaminer. Generating conjectures on fundamental constants with
the ramanujan machine. Nature, 590, 2021.
[47] Alec Radford, Jeff Wu, Rewon Child, David Luan, Dario Amodei, and Ilya Sutskever. Language
models are unsupervised multitask learners. 2019.
[48] Srinivasa Ramanujan. Modular equations and approximations to π. Quarterly Journal of
Mathematics 45, 1914.
[49] Ofir Razon, Yoav Harris, Shahar Gottlieb, Dan Carmon, Ofir David, and Ido Kaminer. Auto-
mated search for conjectures on mathematical constants using analysis of integer sequences. In
Proceedings of the 40th International Conference on Machine Learning (ICML), volume 202 of
Proceedings of Machine Learning Research, pages 28809–28842. PMLR, 23–29 Jul 2023.
[50] Bernardino Romera-Paredes, Mohammadamin Barekatain, Alexander Novikov, et al. Mathe-
matical discoveries from program search with large language models. Nature, 625:468–475,
2024.
[51] Jean-Pierre Serre and P Ion. Galois Cohomology. Springer Monographs in Mathematics.
Springer Berlin / Heidelberg, Berlin, Heidelberg, first edition, 1997.
[52] Michael Shalyt, Uri Seligmann, Itay Beit Halachmi, Ofir David, Rotem Elimelech, and Ido
Kaminer. Unsupervised discovery of formulas for mathematical constants. In Advances in
Neural Information Processing Systems (NeurIPS), volume 37, pages 113156–113190, 2024.
[53] J. Stoer and R. Bulirsch. Introduction to Numerical Analysis, chapter 2.2. Springer, third edition,
2002.
[54] Zhi-Wei Sun. New series for powers of π and related congruences, 2020.
[55] Yiming Tian, Wei Zhou, Matteo Viscione, et al. Interactive symbolic regression with co-design
mechanism through offline reinforcement learning. Nature Communications, 16:3930, 2025.
[56] Trieu H Trinh, Yuhuai Wu, Quoc V Le, He He, and Thang Luong. Solving olympiad geometry
without human demonstrations. Nature, 625(7995):476–482, 2024.
[57] Mark van Hoeij. Factoring linear recurrence operators, 2019.
13


--- Page 14 ---
[58] Shachar Weinbaum, Elyasheev Leibtag, Rotem Kalisch, Michael Shalyt, and Ido Kaminer.
On conservative matrix fields: Continuous asymptotics and arithmetic.
arXiv preprint
arXiv:2507.08138, 2025.
[59] Eric Zelikman, Qian Huang, Gabriel Poesia, Noah Goodman, and Nick Haber. Parsel: Algorith-
mic reasoning with language models by composing decompositions. In Advances in Neural
Information Processing Systems (NeurIPS), volume 36, pages 31466–31523. Curran Associates,
Inc., 2023.
[60] Yi Zhou. Algorithms for Factoring Linear Recurrence Operators. PhD thesis, Florida State
University, 2022.
[61] Wenhao Zhu et al. Multilingual machine translation with large language models: Empirical
results and analysis. In Findings of the Association for Computational Linguistics: NAACL
2024, pages 2765–2781, Mexico City, Mexico, June 2024. Association for Computational
Linguistics.
14


--- Page 15 ---
Appendix
A
Glossary
• Canonical form (CF) – the simplest polynomial linear recurrence generating a formula.
Found by running RISC’s Mathematica package [33], then validating numerically, and
finally minimizing the recurrence with a Maple package [57].
• Conservative Matrix Field (CMF) – a recently discovered mathematical structure consisting
of a lattice of matrices that enables unification of many formulas discovered over the years.
Originally discovered in [20] as a result of a large-scale experimental mathematics effort in
formula generation, the structure was found to be generalizable to any D-finite function in
[58].
• CMF dimension – the number of (parameterized) matrices the CMF is built of (3 for the
π-CMF).
• CMF rank – the number of rows (= number of columns) of the CMF’s matrices (2 for the
π-CMF).
• Coboundary equivalence – an equivalence between two matrices via a third matrix called
the coboundary matrix: for two matrices A(n), B(n) ∈PGLm (Q(n)) the equivalence is
of the form A(n) · U(n + 1) = U(n) · B(n). In this study we combine a novel coboundary
solver (UMAPS) with folding to create the matching algorithm (Appendix C.2), which finds
equivalences between formulas.
• Coboundary transformations – a transformation of the form A(n) →U −1(n)·A(n)·U(n+
1), for A(n), U(n) ∈PGLm (Q(n)).
• Companion matrix – a matrix with a structure suitable for directly representing a linear
recurrence, see Eq. (1).
• Dynamical metrics – numerical values derived from formulas, used to cluster and find
relations between the formulas (see r, δ).
• δ – the irrationality measure of a formula, measured empirically in this study, see Eq. (5). δ
is used in the matching algorithm to find candidate pairs for matching formulas, as the δ
was found to be invariant under coboundary transformations. The result of this clustering
phase was a 20-fold decrease in runtime, see Appendix D.
• Extraction – the stage in the formula harvesting pipeline translating formula LATEX into the
components of the formula, as executable SymPy code.
• Folding – a fold by k is a transformation mapping a matrix M(n) ∈PGLm (Q(n)) to the
matrix Πk
i=1M(k(n −1) + i). In the context of recurrences, the new matrix represents
taking k steps of the original recurrence at a time.
• Polynomial Continued Fraction (PCF) – an equivalent representation of order-2 recur-
rences. Any order-2 recurrence generating a mathematical constant can be represented as a
companion matrix (Lemma 2), and thus as a continued fraction.
• PSLQ – a numerical integer relation algorithm that finds integer coefficients (ai) such that
a1x1 +a2x2 +· · ·+anxn = 0 for given real numbers (xi), revealing algebraic relationships
among them [26].
• r – the exponential convergence rate of a formula, measured empirically in this study, see
Eq. (4). Used in the formula matching algorithm to ascertain the folds needed to find an
equivalence between two formulas.
• Retrieval – the stage of the formula harvesting pipeline in which regular expressions are
applied to filter for equations that may compute the constant of interest.
• Scraping – the first stage of the formula harvesting pipeline.
• Trajectory – a direction in a CMF.
• Trajectory matrix – the parameterized matrix resulting from walking in a trajectory in a CMF.
Every trajectory matrix corresponds to a polynomial linear recurrence, which has a canonical
form, and thus a match can be attempted between the canonical forms of trajectory matrices
and the canonical forms representing formulas. Trajectory matrices and the corresponding
linear recurrences are the CMF representative formulas enabling unification via CMF.
15


--- Page 16 ---
• Unification – embedding formulas in a single CMF to show there is a common and underlying
theory behind them, the main goal of the work.
• UMAPS – our novel coboundary-solving algorithm.
• Validation – the stage of the harvesting pipeline after extraction in which the limits of
formulas are recovered in terms of the constant of interest by running PSLQ on a numerical
evaluation of the formula. The two roles of this stage: (1) recovering the limits and (2)
validating convergence to the constant of interest (or a Möbius transformation thereof).
B
Special results
The examples shown below were found completely automatically via the algorithms discussed in
Section 3 and organized in Appendix C. The actions at each step are described as if being applied by
a human for clarity, but we emphasize that the connections were made automatically. A template for
proofs could have been written once and filled in by a computer as it executed the algorithms. Some
interactive examples are available at the online algorithm demonstration [4].
B.1
Unification by the π Conservative Matrix Field (CMF)
B.1.1
Unification example: formulas 1, 2 and 5 from Table 1
Formulas 1 and 2 have the same canonical form, showing they are equivalent. We will next prove
formulas 1,5 equivalent via the matching algorithm (Appendix C.2). We compute the irrationality
measure (δ) for formulas 1 and 5, resulting in −0.65 for both canonical forms. Next, we compute
convergence rates (r), resulting in 0.69 and 1.38 for formulas 1 and 5, respectively. Dividing the
two we get r1
r5 = 1
2. Folding canonical form 1 by 2 and canonical form 5 by 1 (meaning no change)
results in
PCF1,folded = PCF
 60n3 + 34n2 −11n −3, 2n
 −288n5 + 624n4 −230n3 −225n2 + 158n −24

Applying UMAPS (Appendix C.3), the following coboundary matrix and polynomials connecting
PCF1,folded and PCF5 are discovered:
U(n) =

48n3 −85n2 + 28n
2304n6 −9792n5 + 15440n4 −11100n3 + 3586n2 −408n
−1
−48n3 + 200n2 −223n + 51

pA(n) = 12n −17
pB(n) = 3n + 2
This means that the coboundary condition (Eq. (8)) holds:
pA(n) · CM1,folded · U(n + 1) = pB(n) · U(n) · CM5
Multiplying out the terms, we indeed get the expected relation:
(12n −17) ·

0
2n
 −288n5 + 624n4 −230n3 −225n2 + 158n −24

1
60n3 + 34n2 −11n −3

·
·

48n3 + 59n2 + 2n −9
2304n6 + 4032n5 + 1040n4 −1180n3 −434n2 + 88n + 30
−1
−48n3 + 56n2 + 33n −20

=
(3n + 2) ·

48n3 −85n2 + 28n
2304n6 −9792n5 + 15440n4 −11100n3 + 3586n2 −408n
−1
−48n3 + 200n2 −223n + 51

·
·

0
−9216n6 + 12288n5 + 11264n4 −15520n3 −764n2 + 3802n −714
1
240n3 + 164n2 −54n −29

We have therefore found a transformation from one canonical form to the other:
Coboundary( Fold(PCF1, 2) ) = Fold(PCF5, 1). Formulas 1,2 and 5 are equivalent—having a proof
for any one formula out of these three immediately proves the other two.
16


--- Page 17 ---
Are these formulas contained in the CMF, Eq. (6)? We find that the recurrence of trajectory (1, 0, 0) in
the CMF also has δ = −0.65. The recurrence generated by this direction is precisely the recurrence
PCF1, meaning a trivial coboundary equivalence (U(n) = I2×2) exists between formulas 1,2 and
the CMF. Note that in the general case, showing unification requires finding a nontrivial coboundary
equivalence (U(n) ̸= I2×2) between a representative canonical form of the equivalent formulas, and
the canonical form of the recurrence generated by the CMF (per Appendix C.1). See Appendix B.1.3
for an example.
B.1.2
Unification example: formulas 3 and 4 from Table 1
The canonical forms of formulas 3 and 4 have δ = −1 and convergence rates 0 (they converge
slowly). Given the similarity in δ, we conjecture that the formulas are coboundary. Applying UMAPS
yields the coboundary matrix:
U(n) =

4n2 −4n + 1
8n3 + 4n2 −10n + 3
2n + 1
4n2 + 8n + 7

and trivial external polynomials - pA(n) = 1, pB(n) = 1. So formulas 3 and 4 are equivalent. The
trajectory (1, 1, 1) of the CMF generates a recurrence with δ = −1 and upon inspection is found to
be precisely the canonical form of formula 3, PCF3, unifying formulas 3,4.
The next example requires a nontrivial coboundary equivalence between a recurrence of the CMF
and the formula of interest.
B.1.3
Unification example: cluster (−1, 3, 3) (δ = −0.91)
The following example pertains to the δ = −0.91 cluster in Table 16. The canonical form generated
by the CMF:
PCFCMF =PCF(−7568n5 −11664n4 + 6992n3 + 6036n2 −279n −162,
−24n(2n + 1)(4n −3)(4n −1)(6n −7)(6n −5)(22n2 −39n −1)(22n2 + 49n + 9))
and the canonical form corresponding to the series
2π =
∞
X
k=1
16k(22k2 −17k + 3)
 4k
2k

k(4k −3)(4k −1)
 3k
k
 6k
3k

is
PCF42 =PCF(3784n4 + 156n3 −1942n2 + 261n + 45,
−24n(2n −3)(4n −3)(4n −1)(6n −5)(6n −1)(11n −14)(11n + 8))
Computing convergence rates, we find both have r = 0.52, so they are not folded. Applying UMAPS
results in coboundary matrix and polynomials:
U(n) =

1848n5 −7676n4 + 10730n3 −5605n2 + 682n + 21
6690816n9 −50485248n8 + 157736064n7
1
2860n4 −10680n3 + 13481n2 −6348n + 756

pA(n) = −22n2 + 61n −42
pB(n) = 44n3 + 120n2 + 67n + 9
showing that the series is contained within the CMF.
B.1.4
Unification example: cluster (0, 0, 1) (δ = −1.00)
Here we show the four formulas listed explicitly in Fig. 6 for trajectory (0, 0, 1) are all equivalent,
these correspond to indices 71, 72, 75 and 76 of Table 16. All formulas have δ = −1.00 of course, so
they proceed to the convergence rate matching stage.
First, consider the two polynomial continued fractions (formulas 72 and 71):
PCF72 = PCF(1, n(n + 1))
PCF71 = PCF(2, n2)
17


--- Page 18 ---
These have convergence rates 0, so all combinations of folding up to 2 are passed to UMAPS.
Applying UMAPS, the coboundary algorithm (Appendix C.3), the two turn out to be coboundary to
each other with no folds necessary:
U(n) =

n
−n2
−1
n −1

with trivial “external" polynomials pA(n), pB(n) = 1.
Next, consider formulas 75 and 76: Applying the same steps as above shows they have convergence
rates of 0. Passing all three combinations of folding by 2 to UMAPS, we obtain a coboundary matrix
relating the two formulas with no folds necessary:
U(n) =

4n2 −4n + 1
16n2 −16n3 + 4n2
−1
−4n2 −4

these too with trivial “external" polynomials.
At this point there are two clusters. Can they be united? Consider the pair 72, 75. Passing all three
combinations for folds to the coboundary algorithm, a coboundary matrix comes up:
U(n) =

4n2 −4n + 2
16n4 −16n3 + 4n2
−1
1 −4n2

with external polynomials
pA(n) = 2n −1
pB(n) = 2n + 1
In conclusion, we have found that formulas 71, 72, 75, 76 are equivalent to each other. Only one need
be proven to prove all of the others.
B.2
Unification by the ζ(3) Conservative Matrix Field (CMF)
The following matrices define a 2D CMF that computes the constant ζ(3).
Mx =

0
−x3
(x + 1)3
x3 + 2y (2x + 1) (y −1) + (x + 1)3

My =

−x3 + 2x2y −2xy2 + y3
−x3
x3
x3 + 2x2y + 2xy2 + y3

(13)
Converting the two formulas for ζ(3), Eq. (11), to canonical forms, respectively yields
2
5 −4ζ(3) = 12 +
−48
40 +
−648
98 +
−3840
... +
−n(n + 1)4(n + 2)
2n3 + 9n2 + 17n + 12 + ...
ζ(3)
ζ(3) −1 = 9 +
−64
35 +
−729
91 +
−4096
... +
−(n + 1)6
2n3 + 9n2 + 15n + 9 + ...
Applying our methods, we find a coboundary matrix of degree 6 with linear external polynomials,
U(n) =

n3 + n2 + n + 1
n6 + 5n5 + 10n4 + 10n3 + 5n2 + n
−1
−n3 −4n2 −5n

pA(n) = n
pB(n) = n + 1
which are together a certificate of equivalence for the canonical forms, and hence for the original
formulas too.
Both of these formulas are found in the (1, 0) direction of the ζ(3) CMF (Eq. (13)), which corresponds
to the continued fraction:
1
ζ(3) = 1 +
−1
9 +
−64
35 +
−729
... +
−n6
2n3 + 3n2 + 3n + 1 + ...
18


--- Page 19 ---
B.3
Unification by the e Conservative Matrix Field (CMF)
The following matrices define a 2D CMF that computes the constant e.
Mx =
 1
−y −1
−1 x + y + 2

My =
 0
−y −1
−1 x + y + 1

(14)
We present below the unification of all 15 e formulas from [46].
Table 5: Unification of all 15 e formulas from [46] by CMF Eq. (14), via UMAPS. Because these
formulas converge super-exponentially, the convergence rates are unbounded and depend on the depth
to which they are computed. The folds needed to match the formulas in the (0,1) trajectory were
luckily still uncovered.
Cluster
Formula
Value
Convergence rate
(1, 1)
δ = 1.00
1
PCF(4n + 2,1)
1+e
−1+e
17.36
(1, 0)
δ = 0.00
2
PCF(n + 2,−n)
e
−1+e
7.30
3
PCF(n + 3,−n)
e
7.30
4
PCF(n2 + 3n +
3,−n3 −2n2)
4e
−1+2e
7.30
5
PCF(n2 + 4n +
3,−n3 −3n2)
3e
2(−1+e)
7.30
6
PCF(n + 4,−n)
e
−2+e
7.31
7
PCF(n + 5,−n)
e
6−2e
7.31
8
PCF(n + 6,−n)
e
−24+9e
7.31
9
PCF(n2 + 6n +
7,−n3 −3n2)
6e
−3+2e
7.31
(0, 1)
δ = 0.00
10
PCF(n,n)
1
−1+e
7.30
11
PCF(n + 1,n)
1
−2+e
7.30
12
PCF(n + 2,n)
1
−5+2e
7.31
13
PCF(n + 3,n)
1
−16+6e
7.31
14
PCF(4n2 + 14n +
11,−4n2 −6n)
3
3−e
15.98
15
PCF(4n2 + 10n +
5,−4n2 −2n + 2)
1 +
e
−2+e
15.98
For example, consider these two polynomial continued fractions:
6e
2e −3 = 7 +
−4
14 +
−20
23 +
−54
... +
n2(−n −3)
n(n + 6) + 7 + ...
4e
2e −1 = 3 +
−3
7 +
−16
13 +
−45
... +
n2(−n −2)
n(n + 3) + 3 + ...
Applying UMAPS, we find coboundary matrix
U(n) =

n3 + 4n2 + 6n + 6
n4 + 4n3 + 4n2
−n −1
−n2 −n + 2

19


--- Page 20 ---
and external polynomials
pA(n) = n + 2
pB(n) = n + 3
proving that the two formulas are equivalent.
In similar fashion, we arrive at the other equivalences summarized in Table 5.
B.4
Equivalence example: notable formulas for π
Eq. (9) [48] and Eq. (10) [54] are converted to recurrences, both of order 2, after which they are
converted to canonical form PCFs, respectively:
239018472
−3528 + 1123π = PCFRamanujan = PCF(a1(n), b1(n))
1047212167162854000
−341446000 + 108685699π = PCFSun = PCF(a2(n), b2(n))
a1(n) = 534215282560n4 + 1630601631968n3 + 1686512782328n2 + 618081838666n + 27955409115
b1(n) = n3(366856790423961600n5 + 588680355780034560n4 −56045383774765056n3
−487988770034755584n2 −247923828204062976n −34298642100691584)
a2(n) = 35468306308982528n5 + 180047738533689024n4 + 332745102731042192n3
+ 272631301503072468n2 + 89876772716256332n + 5411146610376015
b2(n) = n2(1617129676787301327212642304n8 + 4289585526894573435060486144n7
−283366210981584591028224000n6 −5781213621368637378454757376n5
−1039278977594267522852017152n4 + 1952285872621730578835212800n3
+ 65692626394504296555019008n2 −100482263421913916885155968n
−1599880200791331634560)
The canonical forms share δ = −0.29 and r = 13.56, so the recurrences are not folded and UMAPS
is applied, resulting in a coboundary matrix of degree 10, coupled with external polynomials of
degree 4, rendering Eqs. 9 and 10 equivalent:
pA(n) = 11398398784n4 −19077544640n3 + 9321191372n2 −1315967464n −20955
pB(n) = 171680n3 + 395264n2 + 290210n + 67749
U(n) =

U11(n)
U12(n)
U21(n)
U22(n)

U11(n) = 28876576000n5 −61950059840n4 + 1926362087953808n3
−1678583497631500n2 −139251745359750n
U12(n) = 1024204559309528510398464000n10 −2119123722024588790327541760n9
+ 1056569453502166636426985472n8 + 244974995622211634412208128n7
−205564834935781598084742144n6 −7035268079364204755916288n5
+ 8470527814505833597769472n4 + 134868258407972960640n3
U21(n) = 42050n −29337
U22(n) = 1491444197503390771200n6 −926743682638889031168n5
−1329170087838044354112n4 + 980655193799148492576n3
−117379649957600136708n2 −9013576532170267008n −143483055820335
B.5
Equivalence example: formulas for Catalan’s constant G
The two formulas for Catalan’s constant in Eq. (12) are equivalent via coboundary matrix
U(n) =

4n2 + 2n
16n4
−1
−4n2 + 2n −1

20


--- Page 21 ---
and trivial external polynomials—pA(n) = 1 and pB(n) = 1. Note that the formulas in Eq. (12)
are not polynomial continued fractions in their current form due to a periodicity of 2 in the an,
bn functions. To convert them into polynomial form, they are first inflated to make them integer
continued fractions, then folded by 2 to make them polynomial, resulting in the canonical forms:
1
2 −2G = 7 +
−16
23 +
−256
55 +
−1296
... +
−16n4
8n2 + 8n + 7 + ...
2
2G −1 = 5 +
−32
25 +
−384
61 +
−1728
... +
16n3(−n −1)
8n2 + 12n + 5 + ...
B.6
Example polynomial recurrences for formulas, some of order greater than 2
One of Ramanujan’s 1914 formulas (shown in Fig. 3) is represented by the following order-2
polynomial recurrence using RISC’s tool for finding minimal recurrences [33]:
0 =

−18426177
3162112 −n · 1603904319
63242240
−n2 · 185504787
3952640
−n3 · 605532897
12648448 −n4 · 22985937
790528
−n5 · 83133297
7905280 −n6 · 2072547
988160 −n7 · 729
4096

f(n)
+

−569520571
15810560 −n · 1927156365
12648448
−n2 · 1076882413
3952640
−n3 · 3379580191
12648448
−n4 · 122831663
790528
−n5 · 424008847
7905280
−n6 · 10066461
988160
−n7 · 3367
4096

f(1 + n)
+
40384
965
+ n · 171504
965
+ n2 · 61640
193
+ n3 · 60808
193
+ n4 · 35600
193
+ n5 · 61907
965
+ n6 · 23709
1930 + n7

f(2 + n).
Some formulas are generated by recurrences of higher order. The methods presented in this work can
be generalized to higher degree recurrences (see Lemma 4 of Appendix C.3). For example, these two
series for Catalan’s constant [13]
G = P∞
n=0
1
2n+1
Pn
k=0
 n
k
 (−1)k
(2k+1)2 ,
2G = P∞
n=0
2n
(2n+1)(
2n
n )
Pn
k=0
1
2k+1,
are given by the same recurrence of order 3:
0 =

−3
2 −5n
4 −n2
4

f(n) +
21
2 + 29n
4
+ 5n2
4

f(1 + n)
+

−85
4 −13n −2n2

f(2 + n) +
49
4 + 7n + n2

f(3 + n)
meaning their recurrence matrices, which are in general companion matrices (Eq. (1)), are trivially
coboundary, with the identity coboundary matrix. Other cases in which the recurrence is not
precisely the same require a generalization of the coboundary algorithm Appendix C.3 to solve for
the coboundary matrix. Additional examples of high-order recurrences, for π:
2
π =
∞
X
k=0
k
X
i=0
2k −2i
k −i
22i
i
2
· k
 1
32
k
is given by the order-3 recurrence
0 =

−4 −8n −6n2 −2n3 −n4
4

f(n) +
81
4 + 173n
4
+ 65n2
2
+ 21n3
2
+ 5n4
4

f(n + 1)
+

−137
4
−297n
4
−111n2
2
−35n3
2
−2n4

f(n + 2) +
 18 + 39n + 29n2 + 9n3 + n4
f(n + 3)
2
π =
∞
X
n=0
(−1)n (3n + 1)
32n
n
X
k=0
2n −2k
n −k
2k
k
n
k
2
is given by the order-3 recurrence
0 =

−35
9 −26n
3
−23n2
3
−121n3
36
−35n4
48
−n5
16

f(n) +

−365
9
−181n
2
−1879n2
24
−1589n3
48
−55n4
8
−9n5
16

f(n + 1)
+

−356
9
−503n
6
−1633n2
24
−1279n3
48
−81n4
16
−3n5
8

f(n + 2) +

84 + 183n + 154n2 + 568n3
9
+ 38n4
3
+ n5

f(n + 3)
21


--- Page 22 ---
C
Algorithms
This section contains an in-depth description of the algorithms discussed in Section 3. The algo-
rithms are ordered top-down, from the highest level algorithm to the lowest. A hyperparameter
sensitivity study supporting the hyperparameter choices below is included in Appendix D. All
algorithms used in the pipeline were run on a 13th Gen i5-13500H Intel Core and are available
at https://github.com/RamanujanMachine/euler2ai. Runs required for the sensitivity study were
conducted on the Technion High Performance Computing Zeus Cluster.
Table 6: Algorithms enabling unification by Conservaitve Matrix Field (CMF). The matching
algorithm and UMAPS are depicted also in Fig. 4.
Name
Dependencies
Input
Output
C.1
Coboundary graph
growing algorithm
C.2, C.4, C.5
canonical-form formulas and
CMF-derived representative
recurrences
a coboundary graph—a forest of
equivalent formulas with
equivalence-proving transformations stored
in the edges
C.2 Matching algorithm
C.3
two polynomial recurrences
A(n), B(n)
a triple of three transformations: a fold
transform for each recurrence (FA, FB)
and a coboundary transform
(U(n), pA(n), pB(n)) s.t.
pA(n)
pB(n) · U(n)−1 · FA(A(n)) · U(n + 1) = FB(B(n))
C.3
UMAPS: The
coboundary solving
algorithm
two polynomial recurrences
A(n), B(n)
a coboundary transform
(U(n), pA(n), pB(n)) s.t.
pA(n)
pB(n) · U(n)−1 · A(n) · U(n + 1) = B(n)
C.4
Conversion to
canonical form
RISC’s tool [33]
Diophantine formula
minimal polynomial recurrence (PCF for
second-order recurrences)
C.5
Recurrence
generation by CMF
CMF matrices, start point,
trajectory
polynomial trajectory matrix (polynomial
recurrence)
C.1
The coboundary graph growing algorithm
Input: (1) Initialized graph with no edges, where each node is a canonical-form recurrence for a
formula. Each node has precomputed attributes: irrationality measure (δ) and convergence rate (r)
(Section 2). (2) Dataframe of canonical forms generated by the CMF (see Appendix C.5), with
precomputed attributes as in (1).
Output: The graph as a forest, where each edge contains the rigorous transformation between the
two nodes it connects. This forest is termed a coboundary graph. Every tree groups formulas that are
rigorously-equivalent together—the trees found by the algorithm are actually subgraphs of cliques;
not all clique edges are computed during the matching phase to make the algorithm more efficient,
but they all exist. If a tree contains a CMF-generated canonical form, all of the formulas within are
unified.
Steps:
1. Cluster nodes according to δ: Initialize an empty list for each value between −1.00 and 0.05
(or higher upper bound, depending on the PCF with highest δ) at intervals of 0.05 (δ “granularity”)
including the edge values. For every cluster value δc, insert every node with δ obeying |δ −δc| < 0.03
(δ “similarity threshold”) into the cluster’s corresponding list. Note that a node can appear in two
clusters initially. The maximum distance between two nodes in the same cluster is 2 · 0.03 = 0.06.
This is intentional to prevent missing matches. Additionally, initialize an empty list “nonhubs.”
2. For every cluster of nodes indexed by δc:
• For each node, attempt to match it to all nodes appearing at higher indices that are not in
“nonhubs,” using Appendix C.2. Store successful matches as new graph edges containing
the transformations. Every formula matched to the current node is placed in the global
“nonhubs” list.
• At the end of this process, nodes not in the “nonhubs” list are deemed final non-CMF “hubs.”
They are currently the roots of a forest since a node is added to “nonhubs” as soon as it is
matched with the current node during the loop, and it is subsequently skipped.
22


--- Page 23 ---
3. Now, for each “hub,” attempt to match it to all CMF-generated canonical forms with δCMF that
obey |δ −δCMF | < 0.03. When an edge is found, break for the current hub—the hub and all nodes
connected to it have been unified in the CMF.
4. Output the resulting graph.
C.2
The matching algorithm
Equivalence is a binary relation between two formulas. To find one, formulas represented as canonical
form recurrences (Appendix E.4.1) are clustered based on dynamical metrics (Section 3.4). Promising
pairs, those with similar irrationality measure δ (Eq. (5)), are folded (Appendix E.5) according
to the ratio of their convergence rates r (Eq. (4)), then sent to UMAPS—the coboundary solving
algorithm (Appendix C.3). The result is a triple: the fold transform needed to be applied to each of
the recurrences, and the coboundary matrix and polynomials as outputted by UMAPS. This algorithm
is also summarized in Fig. 4.
Input: Two linear polynomial-coefficient recurrences with matrices A(n) and B(n).
Output: A list of three transformations connecting the recurrences (if found)
• fold transformation for each of the recurrences (FA, FB)
• coboundary
transformation
linking
the
two
recurrences
after
they
are
folded
(U(n), pA(n), pB(n)):
pA(n)
pB(n) · U(n)−1 · FA(A(n)) · U(n + 1) = FB(B(n))
Steps:
1. If unknown, compute the convergence rates of each of the recurrences using Eq. (4) at n = 2000.
If the convergence rate is less than 5 · 10−2, set it to 0.
2. Compute the ratio of the convergence rates of the recurrences, when defined, as R = |rA|
|rB|. Assume
this number can be approximated as a rational with low-enough denominator to good degree. Set
R = 0 if either of the convergence rates is 0 (this is normally the case when δ = −1, such PCFs
converge polynomially).
3. Fold recurrence A by rB and recurrence B by rA if R ̸= 0. If R = 0, all combinations of folding
the recurrences by up to 2 are passed to the next phase for a total of 3 options: fold neither or (one
option) or fold one of them by 2 (two options). This is because the convergence rate does not contain
fold information for PCFs with slow convergence.
4. Apply the coboundary solving algorithm Appendix C.3 between the recurrences. If a coboundary
transform is successfully found, output fold transforms from 4 and the coboundary transform.
C.3
UMAPS: The coboundary solving algorithm
We aim to find a coboundary relation between two recurrences, yet as mentioned in Section 3.5, this
constitutes a nonlinear problem. To see why, let us write the equations for the coboundary matrix and
polynomials in full for order m = 2. We have, given two polynomial matrices A(n) and B(n)
pA(n) · A(n) · U(n + 1) = pB(n) · U(n) · B(n) ⇐⇒
dpA
X
i=0
pA,ini·
 PdA11
i=0 A11,ini
PdA12
i=0 A12,ini
PdA21
i=0 A21,ini
PdA22
i=0 A22,ini
!
·
 PdU11
i=0 U11,i(n + 1)i
PdU12
i=0 U12,i(n + 1)i
PdU21
i=0 U21,i(n + 1)i
PdU22
i=0 U22,i(n + 1)i
!
=
dpB
X
i=0
pB,ini ·
 PdU11
i=0 U11,ini
PdU12
i=0 U12,ini
PdU21
i=0 U21,ini
PdU22
i=0 U22,ini
!
·
 PdB11
i=0 B11,ini
PdB12
i=0 B12,ini
PdB21
i=0 B21,ini
PdB22
i=0 B22,ini
!
The unknowns of this equation are the coefficients of pA(n), pB(n) and the coefficients of
the four polynomials of U(n): {pA,k|k = 0, . . . , dpA}, {pB,k|k = 0, . . . , dpB}, {Uij,k|k =
0, . . . , dUij; i, j ∈{1, 2}}. From the equation written above, it is clear that the coefficients are
23


--- Page 24 ---
coupled (e.g. the product pA,0 · U21,0 is in the expansion), making the equations resulting from
equating powers of n nonlinear.
An empirical method that takes care of nonlinearity and the ambiguity in unknown polynomial
degrees would be much preferred. Luckily, such a method is possible: we use Lemma 1 (proven
below), a necessary condition a coboundary matrix between two matrices must obey, to solve for
U(1) and then reconstruct the coboundary matrix in full. Lemma 4 generalizes this condition to
general matrix order m, enabling a coboundary-solving algorithm for recurrences of any depth.
Input: Two order-m recurrences that converge to the same irrational constants (m −1 constants at
most) up to Möbius transformations (Eq. (17) and a requested depth up to which a coboundary matrix
will be fit to “measurements” of the coboundary matrix. Denote the recurrence matrices by A(n)
and B(n), their limits by LA and LB (integer Möbius transformations of the irrational constant φ
for m = 2 and projective vectors for higher order recurrences—see the setup of Lemma 4) and the
requested depth as N.
Output: A polynomial matrix U(n) and two additional polynomials pA(n), pB(n), if found, satisfy-
ing the coboundary condition Eq. (8):
pA(n) · A(n) · U(n + 1) = pB(n) · U(n) · B(n).
Steps:
1. Solve for the first coboundary matrix U(1) up to a multiplicative factor using :
• (order m = 2) From Lemma 1, write the equation LA = U(1)(LB), where U(1)(·) is the
Möbius transformation, for the four unknowns of the first coboundary matrix
U(1) =

u11
u12
u21
u22

.
Writing the Möbius transformation explicitly, the equation reads LA = u11LB+u12
u21LB+u22 . Without
loss of generality, the above equation can be written as αφ+β
γφ+δ = aφ+b
cφ+d, where a, b, c, d
depend on {uij}i,j∈{1,2} and LB and LA = αφ+β
γφ+δ . By equating coefficients of powers of
φ in the numerator and denominator independently, we obtain four equations for the four
unknowns of U. (This must hold assuming the irrational number does not solve a quadratic
equation, a condition met by all non-algebraic constants like π and ζ(3).) The solution is
the four rational numbers of U(1) (up to a multiplicative factor).
• (general order m) From Lemma 4, write the equation LA = U(1)LB. Every row of
this equation can be written as LAi = U(1)i · LB where U(1)i is the ith row of U(1).
Since we are solving over the rationals, PSLQ [26] can be used to find a solution: ai ·
LAi −Pm
j=1 bijLBj = 0 (where ai, {bij}m
j=1 were found over the integers via PSLQ) =⇒
U(1)ij = bij
ai . If the symbolic limits are known in terms of a set of algebraically independent
constants, U(1) can also be found by equating coefficients.
2. Propagate the coboundary matrix to the requested depth N using the necessary condition for a
coboundary equivalence:
• A(n) · U(n + 1) ∝U(n) · B(n) =⇒U(n + 1) ∝A(n)−1 · U(n) · B(n)
• The resulting matrices are again the rational matrices {Ui}N
i=2, known only up to independent
multiplicative factors.
3. Divide each of the “measured” {U(i)}N
i=1 by, e.g., the U11 element of each matrix.
• Take care to pick an element U11, U12, U21, U22 (etc. for orders > 2) that does not zero out
on 1, 2, . . . , N. If all do then pick the element whose last 0 arrives at the earliest index and
toss out all measurements preceeding this index.
• The result is a new list of matrices. If a polynomial coboundary relation exists between the
two recurrences, pA(n) · A(n) · ˜U(n + 1) = pB(n) · ˜U(n) · B(n) for some polynomials
pA(n) and pB(n), then the matrices we have found are precisely the result of dividing ˜U(n)
by its (e.g.) first element. Meaning our measurements should be of a rational matrix.
24


--- Page 25 ---
4. Fit rational functions to each of the elements of the measured U:
• Writing a general m × m rational matrix requires 2m2 polynomials {pij(n), qij(n)}m
i,j=1.
Equating the rational function of each element pij(n)
qij(n) to the measurements of that element
Uij(n), yields a system of linear equations for the coefficients of the numerator polynomial
and the denominator polynomial:
pij(n)
qij(n) = Uij(n) =⇒pij(n) −Uij(n)qij(n) = 0 for
n = 1, . . . , N.
• The result is a rational coboundary matrix hypothesis Uh(n). Hypothesis—because this is a
rational fit to our empirical coboundary matrices.
5. The final stage of the algorithm is to verify the hypothesis.
• Multiply out A(n) · Uh(n + 1) and Uh(n) · B(n). If the resulting matrices differ by a
multiplicative factor (not a matrix, a rational function), meaning the condition A(n)·Uh(n+
1) ∝Uh(n) · B(n) holds, then the coboundary matrix hypothesis Uh(n) is a valid, though
still rational, coboundary matrix.
• Multiply both sides of A(n) · Uh(n + 1) ∝Uh(n) · B(n) by the least common multiple of
the denominators of Uh(n + 1), Uh(n) to convert the coboundary relation into a polynomial
one of the form pA(n) · A(n) · U(n + 1) = pB(n) · U(n) · B(n), where pA(n), pB(n) are
polynomials and U(n) is a polynomial matrix.
6. Output U(n), pA(n) and pB(n) (which are defined only if Uh was valid).
This algorithm (for m = 2) is also available on our interactive, online algorithm demonstration [4].
C.3.1
Sufficiency of UMAPS
We can show that UMAPS is sufficient to recover the coboundary matrix, provided an upper bound on
the degrees of the polynomials in its rational entries. We now proceed to prove Corollary 1. According
to this corollary, the sensitivity study (Appendix D) indicates that any coboundary matrix among the
harvested formulas that has not been recovered must involve rational entries with polynomials of
degree at least 60. Let us restate the corollary:
Corollary 1. (Sufficiency of UMAPS.) If a coboundary matrix exists for two matrices and every
rational-function entry of the coboundary matrix has polynomials of degree at most d, then running
UMAPS with N ≥2d + 1 suffices to recover the coboundary matrix.
Proof. By Lemma 1 (and the generalization to any recurrence order, Lemma 4), two matrices that
are coboundary have limits related by the transformation U(1). Therefore, during the execution of
UMAPS, the quantities U(1), . . . , U(N) correspond to correct measurements of U(n).
Assume that each rational-function entry of the coboundary matrix has numerator and denominator
polynomials of degree at most d. This gives a total of 2d + 2 coefficients. Since multiplying both the
numerator and denominator by a common nonzero factor yields the same rational function, there are
effectively 2d + 1 independent degrees of freedom.
Choosing N = 2d+1 produces a linear homogeneous system of 2d+1 equations in 2d+2 unknowns
for each element of the coboundary matrix. If a coboundary matrix exists, then it is unique up to scale
by Lemma 5. So this system has a one-dimensional null space, corresponding to a unique solution up
to overall scale. Increasing N beyond 2d + 1 introduces linearly dependent equations, leaving the
null space unchanged.
Hence, a rational fit to the empirical measurements of U(n) will recover the rational-function entries
whenever N ≥2d + 1.
C.3.2
Rational function fitting details
A rational function fit is attempted in step 4 of UMAPS, detailed above. Consult [53] for a thorough
treatment of rational fitting. The rational fit is conducted by finding the null space of a linear system
of equations:
25


--- Page 26 ---
When fitting rational functions, the equations are of the form P (i)
Q(i) =
pi
qi , where P, Q are the
polynomials of the rational function and pi
qi is the empirical value at i. This leads to equations of
the form qi
PdegP
k=0 Pkik −pi
PdegQ
k=0 Qkik = 0, for the degP + degQ + 2 polynomial coefficients.
These coefficients are determined by finding the null space of the system of equations.
In practice, the system is a SymPy matrix of integers (e.g. qiik for Pk). SymPy does this via the
linear system’s reduced row-echelon form, and uses rational number objects (not floats), so precision
is guaranteed.
Since the rational fit is not a least-squares fit, noise and finite precision are not sources of error.
Analytical correctness of the fit is guaranteed by subsequent substitution into the coboundary condition.
Once a matrix is successfully recovered, Lemma 5 guarantees this is the coboundary matrix, due to
U(n)’s projective uniqueness.
C.4
Conversion of formulas to canonical form
We use RISC’s Guess tool [33] to convert formulas into recurrences, after which correctness is
validated numerically. Minimality is then guaranteed using Maple’s MinimalRecurrence package
[57] (additional details available in [60]). Finally, formulas yielding second-order recurrences are
represented as continued fractions. The proper initial conditions needed for the continued fractions to
generate the formulas are found (Appendix C.4.1).
Our use of RISC’s Guess algorithm and the following steps can be summarized by:
Input: First N approximants of a formula.
Output: Minimal polynomial recurrence generating the formula.
As more terms of a sequence are considered, the likelihood that a guessed recurrence fits only the
initial terms but fails for later ones decreases. In our experiments, we use N = 200 partial sums
when converting each series into a corresponding recurrence. The hyperparameter sensitivity study
(Appendix D) supports this choice.
Once a recurrence is identified for a formula with a known closed form, we verify it by substituting
the formula back into the recurrence. If R is the recurrence operator and f(n) is the formula, then
the goal is to show ∀n : R[f](n) = 0. This verification is done numerically, since substituting
full series expressions or complex closed forms into the recurrence does not always allow algebraic
simplification. We perform 30 random numerical substitutions into the expression R[f](n), all of
which must agree to within 10−10 for the recurrence to be accepted. All recurrences were successfully
validated under this criterion.
Formulas given by a polynomial recurrence of order 2 can be represented as polynomial 2 × 2
companion matrices (polynomial continued fractions): given a recurrence xn
c(n)xn = a(n)xn−1 + b(n)xn−2
the corresponding canonical form is
PCF (a(n), b(n)c(n −1))
Which is achieved using inflation by c(n) (see E.4).
Converting a general series to a continued fraction can be done using a technique devised by Euler,
however, this technique relies on algebraic manipulation of the term of the series and also does not
necessarily yield polynomial recurrences, let alone recurrences of order 2. A formula can have a
recurrence of order 2 that is not polynomial, but have minimal polynomial recurrence of order 3 (see
for example Appendix B.6).
C.4.1
Conversion of series limit to Polynomial Continued Fraction (PCF) limit
Input: Series, with partial sums (not summand) to index n given by S(n), and continued fraction
CF(an, bn) from the recurrence fit to the series using RISC’s tool.
Output: x ∈Q such that the initial conditions

S0
xS1
1
x

26


--- Page 27 ---
generate the partial sums of the entire series when the continued fraction’s recurrence is applied from
index 2. By demanding the second convergent of the continued fraction is equal to the second partial
sum of the series (recall our notation for the Möbius transform defined by matrix U - U(·)):

S0
xS1
1
x

·

0
b2
1
a2

(0) = S2
we arrive at the equation
S0b2 + xS1a2
b2 + xa2
= S2
Solving for x, we obtain
x = −b2
a2
S2 −S0
S2 −S1

Note that only the first three partial sums of the series S0, S1 and S2 (more generally n0, n0 + 1,
n0 + 2, where n0 is the start index of the series summation) and a single partial-numerator and
partial-denominator pair of the continued fraction are needed. This is because the continued fraction
values pn
qn satisfy the recurrence, hence when equating the first two values to the values of the sum we
get the exact same series.
The algorithm’s result can be converted to initial conditions for when the continued fraction’s
recurrence is applied from any other index by multiplying by recurrence matrices of appropriate
indices and their inverses, i.e. the initial condition that calculates the series starting from n = 1 (using
the same notation as Eq. (2)) is

S0
xS1
1
x

·

0
b1
1
a1
−1
|
{z
}
new initial conditions
·

0
b1
1
a1

·

0
b2
1
a2

·

0
b3
1
a3

. . .
This method is convenient since there is no need to keep track of transformations applied to the
series’ recurrence in the process of conversion to continued fraction. In summary, the correct initial
conditions for recreating the series from the recurrence are found using only the recurrence and first
few partial sums of the series.
This algorithm is also available on our online algorithm demonstration [4].
C.5
Recurrence generation by Conservative Matrix Field (CMF)
A recurrence is generated from a CMF by selecting a starting point and a trajectory in the CMF. We
calculate their corresponding trajectory matrix M(n) (see G.1), and finally convert it to the canonical
companion form (see E.2) in order to generate a recurrence.
Input: A CMF, a starting point p and a trajectory t, both vectors of dimension equal to that of the
CMF. Denote the number of matrices in the CMF (the CMF’s dimension) by d and the number of
rows and columns in these square matrices (the CMF’s rank) by r.
Output: Polynomial recurrence of order r.
Steps:
1. Compute a single trajectory step from p+(n−1)t to p+nt (see Appendix G.1 for a more rigorous
definition):
• initialize M = Ir×r and cur_pos = p + (n −1)t.
• for i in 1, . . . , d:
•
for j in range(ti):
•
M = M · Mxi(cur_pos)
•
cur_pos = cur_pos + ei (where ei is 1 at index i and zero elsewhere)
27


--- Page 28 ---
By the end of this loop cur_pos = p + nt and M is the work matrix from p + (n −1)t to p + nt.
2. If interested in companion form (Eq. (1), which corresponds to a PCF), bring the resulting rational
matrix M into polynomial companion form per Lemma 2.
3. Return M.
It is worth mentioning that there are degrees of freedom in the calculation of the trajectory matrix,
due to the conserving property of the CMF. The order of matrix multiplication can be selected, which
is advantageous in preventing matrix singularities.
Our search space for formulas in the CMF defined in Eqs. (6) and (25) consisted of the trajectory
subspace T3 = {(a, b, c) ∈Z3 : max{|a|, |b|, |c|} ≤3} and the initial positions P1 = ( 1
2, 1
2, 1
2) +
{(a, b, c) ∈Z3 : max{|a|, |b|, |c|} ≤1}. In cases where M(n) had a singularity at some point along
the trajectory p + kt (where t ∈T3 and p ∈P1), we shifted the initial position to p′ = p + (k + 1)t
to avoid it.
As can be seen from the definition of P1, starting points are actually non-integer. The CMF starting
points appearing in dark blue in Fig. 6 are shown in terms of the difference from ( 1
2, 1
2, 1
2) which is
the true (0, 0, 0) point.
D
Hyperparameter sensitivity study
Below we provide a sensitivity study showing the linkage percentage and runtime for different δ-
clustering granularities and similarity thresholds, values of UMAPS’s fit depth, as well as an analysis
of the sensitivity of RISC’s Guess algorithm to its fit depth. Parameters used in the paper are denoted
in bold. Runtimes are normalized by the runtimes for the parameters used in the paper. Runs required
for the sensitivity study were conducted on the Technion High Performance Computing Zeus Cluster.
Table 7: Linkage rate via UMAPS for different δ clustering granularities and similarity thresholds in
the graph growing algorithm (Appendix C.1). The numbers listed are % of max linkage achieved
(136) between canonical form formulas. The linkage percentage with no clustering criterion is found
by setting similarity threshold = 2 and is 100%, as expected.
Clustering granularity
Similarity threshold
0.01
0.05
0.1
0.2
0.3
0.5
0.001
85
76
68
58
54
64
0.003
95
79
74
64
60
70
0.005
100
80
75
64
60
70
0.01
100
97
83
64
62
73
0.02
100
100
86
64
65
73
0.03
100
100
86
64
65
73
0.05
100
100
100
73
71
73
0.1
100
100
100
100
90
73
0.2
100
100
100
100
100
87
0.3
100
100
100
100
100
100
0.5
100
100
100
100
100
100
28


--- Page 29 ---
Table 8: Runtime for different δ clustering granularities and similarity thresholds. The algorithm
(Appendix C.1) first matches formulas to find hubs (stage 1), then matches each hub with CMF
representatives (stage 2). For coarser granularities (> 0.1), the runtime shows three phases across
similarity thresholds (regular text, bold, regular). This can be explained by the number of hubs from
stage 1 (decrease as similarity threshold increases) vs. the number of CMF representatives that meet
the similarity criterion in stage 2 (increase as similarity threshold increases). The runtime value
results from their product, which is largest for medium similarity threshold values. Runtime without
clustering (similarity threshold = 2): 20.0.
Clustering granularity
Similarity threshold
0.01
0.05
0.1
0.2
0.3
0.5
0.001
0.8
0.6
0.8
0.8
0.7
0.7
0.003
0.9
0.8
1.1
1.1
1.1
1.0
0.005
1.1
0.9
1.3
1.2
1.3
1.2
0.01
1.0
0.7
1.2
2.0
2.0
1.3
0.02
1.0
1.0
1.5
3.4
3.5
1.6
0.03
1.0
1.0
1.4
4.7
4.9
2.4
0.05
1.0
1.0
1.0
4.0
3.9
3.2
0.1
1.0
1.0
0.9
1.0
2.9
5.4
0.2
0.9
0.9
0.9
0.9
0.9
6.1
0.3
1.0
0.9
0.9
1.0
0.9
1.0
0.5
1.0
0.9
1.1
1.0
0.9
0.9
Table 9: Linkage rate and runtime for different maximum fitting depths in UMAPS. The total runtime
of the graph growing algorithm (Appendix C.1) has a clear minimum. The two forces at play: the
average UMAPS time increases with N, while the number of hubs from stage 1 decreases with N;
the runtime (their product) is smallest at intermediate N. Note the maximum polynomial degree
found as a function of N closely follows the upper bound stipulated by Corollary 1.
UMAPS N
Found relation (canonical) (x/153)
Same CMF (canonical) (x/153)
Max poly deg found
Avg UMAPS time
Total runtime
4
28
22
1
0.5
6.7
8
45
38
3
0.5
3.7
12
80
67
5
0.7
3.1
16
95
78
7
0.8
2.5
20
130
81
9
0.9
1.2
24
132
81
11
0.9
1.0
29
136
81
13
0.8
0.8
30
136
81
14
1.1
0.9
40
136
81
14
1.0
1.0
50
136
81
14
1.0
1.3
65
136
81
14
1.1
2.9
80
136
81
14
1.7
9.7
100
136
81
14
7.1
48.8
120
136
81
14
18.3
137.3
Table 10: Success rate and runtime of RISC’s Guess [33] for different fit depths N over 100 random
formulas. These findings indicate that Guess generates robust fits that generalize well.
Guess N
Recurrences found (x/100)
Of which correct
Avg runtime
8
0
0
0.02
10
24
24
0.05
15
30
30
0.08
20
57
57
0.18
25
76
76
0.26
30
92
92
0.31
50
99
99
0.46
100
100
100
0.67
200
100
100
1.00
500
100
100
2.79
29


--- Page 30 ---
E
Recurrences and limit-preserving transformations
E.1
On linear recurrences
Recurrences, also known as “difference equations,” [34] are the discrete analog of differential
equations. They play a prominent role in various areas of mathematics and science, including
Newton’s approximation algorithms, counting problems (combinatorics), special functions, and the
modeling of economic and biological systems. In this section, we revisit the notion of a linear
recurrence that we introduced in Section 2.
A function un satisfies a recurrence of order m if it is a solution to the equation:
un = a1,nun−1 + a2,nun−2 + . . . am,nun−m
It is customary to represent the recurrence via the associated companion matrix:
CM(n) :=






0
0
. . .
0
am,n
1
0
. . .
0
am−1,n
0
1
. . .
0
am−2,n
...
...
...
...
...
0
0
. . .
1
a1,n






(15)
Observe that [un−m, . . . , un−2, un−1] CM(n) = [un−(m−1), . . . , un−1, un]. Thus, the companion
matrix represents a single step in the recurrence at time n. By incrementally multiplying the
companion matrix over n steps, we get the matrix:
Mn :=
n
Y
i=1
CM(i) =






p1,n−m
. . .
p1,n−1
p1,n
p2,n−m
. . .
p2,n−1
p2,n
p3,n−m
. . .
p3,n−1
p3,n
...
...
...
...
pm,n−m
. . .
pm,n−1
pm,n






(16)
which we call the n-th step matrix. The functions p1,n, . . . pm,n are solutions to the recurrence
equation with initial conditions pi,j = δj
i , and any other solution is a linear combination of these.
Hence this matrix encapsulated all the information about the recurrence. Explicitly to get a different
set of solutions we multiply the step matrix Mn from left by the initial condition matrix Uinit where
each row represents the initial condition for a solution.
Alternatively, let A(n) ∈PGLm (Q(n)) be a matrix with coefficient functions. Similar to the process
done for the companion matrix, we incrementally multiply the matrix:
An :=
n
Y
i=1
A(i)
We regard An as a “cocycle” (see E.4.2 and E.4.3). We are fundamentally interested in the situation
where the matrix A(n) is coboundary equivalent (Eq. (7)) to the companion matrix of a recurrence.
In the context of Diophantine approximation formulas for constants, we examine the ratios of elements
in the last column of the step matrix Mn. Diophantine approximation formulas can also be derived
by taking ratios of elements in An.
We will now provide a detailed analysis for the case of second-order recurrences. In this case, we
utilize the fact that a 2-by-2 matrix acts by Möbius transformation (linear fractional transformation)
on R ∪∞, and we provide a complete characterization of coboundary equivalence between matrices.
E.2
Second-order recurrences
Recall that any 2-by-2 matrix M can perform a fractional linear transformation. The action of M on
the number l is defined as:

a
b
c
d

(l) = a · l + b
c · l + d
(17)
30


--- Page 31 ---
This is known as the Möbius transformation of the matrix acting on l. It is customary to extend this
action to R ∪∞by defining

a
b
c
d

(∞) = a
c .
Let an, bn ∈Q(n) be rational functions, and consider the recurrence relation un = anun−1+bnun−2.
By incrementally multiplying the companion matrix CM(n) and examining the ratio of the elements
in the first (or second) column, we effectively apply a Möbius transformation. Explicitly, we have:
MN(0) = pn
qn
,
MN(∞) = pn−1
qn−1
Alternatively, we can start with a general matrix A(n) ∈PGL2 (Q(n)) and incrementally multiply
to obtain the matrix:
An :=
n
Y
i=1
A(i)
We can then examine the ratios of elements in the first or second column of this matrix, or even
apply it as a Möbius transformation at a value l ∈Q. This can potentially provide a Diophantine
approximation to some constant, similar to how a recurrence relation provides a formula via a Möbius
transformation of the step matrices.
We call such a matrix A(n) a formula generating matrix if, for any l ∈Q ∪{∞}, the sequence An(l)
provides an approximation formula for a constant L.
Indeed as the following lemma asserts any such matrix is coboundary equivalent (see Definition (7))
to a companion matrix of a recurrence equation.
Lemma 2. A matrix A(n) ∈PGL2 (Q(n)) is a formula-generating matrix if and only if there exist a
matrix U(n) ∈PGL2 (Q(n)) and a companion matrix CM(n) associated to a recurrence un, such
that
U(n) · A(n) = CM(n) · U(n + 1)
Proof. First, assume
A(n) =

α(n)
β(n)
γ(n)
δ(n)

is a formula-generating matrix, and denote by An = Qn
i=1 A(i). If γ(n) = 0 then the bottom left
entry in An will remain 0 for any n, resulting in limn→∞An.∞= ∞. In this case it must be that β(n)
is nonzero since if it is zero then so is the top right entry of An, resulting in limn→∞An.0 = 0 ̸= ∞.
Hence we may assume that either γ(n) or β(n).
If γ(n) ̸= 0 then define
U(n) =

γ(n)
−α(n)
0
1

And get that
U(n) · A(n) · U −1(n + 1) =

0
−α(n)δ(n) + β(n)γ(n)
γ(n)
γ(n+1)
α(n+1)γ(n)
γ(n+1)
+ δ(n)

And if γ(n) = 0 define
U(n) =

1
0
α(n −1)
β(n −1)

to get that
U(n) · A(n) · U −1(n + 1)
=

0
1
−α(n)(α(n−1)β(n)+β(n−1)δ(n))
β(n)
) + α(n −1)α(n)
α(n−1)β(n)+β(n−1)δ(n)
β(n)
)

Where these matrices are projectively equivalent to a matrix in a companion form [49].
31


--- Page 32 ---
To conclude the proof, it is left to show that companion form matrices are formula-generating.
Let CM(n) =

0
bn
1
an

be a companion form matrix with lim
n→∞
pn
qn
= L.
Mn(l) = pn−1 · l + pn
qn−1 · l + qn
= pn
qn
·
pn−1
pn
· l + 1
qn−1
qn
· l + 1
And since the ratio of pn
qn converges, the growth rate of these solutions is the same, implying that
lim
n→∞
 pn−1
pn
· l + 1
qn−1
qn
· l + 1
!
= 1 making lim
n→∞Mn(l) = L.
E.3
Proof of expected limit value
We call a companion matrix A(n) Poincaré-Perron type if the recurrence relation represented by
A(n) is of Poincaré-Perron type, that is
un = a1,nun−1 + a2,nun−2 + . . . + am,nun−m
where the limit
lim
n→∞ai,n = αi ∈R
exists and is finite, and the characteristic roots, i.e., the solutions λi to the equation
X
i
αi · Xm−i = Xm
are all with different absolute values
|λ1| > · · · > |λm|
In this case, the theorem of Poincaré-Perron [19, Chapter 8, Theorem 10] states that there are
m-linearly independent solutions Pi to the recursion un such that
lim
n→∞
Pi(n + 1)
Pi(n)
= λi
Lemma 3. Given a companion matrix A(n) with the step matrix:
An =
n
Y
i=1
A(i) =






p1,n−m
. . .
p1,n−1
p1,n
p2,n−m
. . .
p2,n−1
p2,n
p3,n−m
. . .
p3,n−1
p3,n
...
...
...
...
pm,n−m
. . .
pm,n−1
pm,n






Assume A(n) represents a Poincaré-Perron companion matrix with fundamental roots
|λ1| > · · · > |λm|.
Then any column of the limit matrix
e
A = lim
n→∞A−t
n
is projectively equivalent to the vector ˆX =






X1
X2
X3
...
Xm






, where ˆX is the initial condition for the
"slowest" growing solution and Xi ̸= 0, i.e, the one that grows like |λm|n. In particular
e
Ai,j
e
Ai′,j
= Xi
Xi′
32


--- Page 33 ---
Proof. Let yn be a solution for the recursion defined by A(n), setting
Yn = (yn
yn+1
yn+2
. . .
yn+m−1)
We get that
Y0An = Yn
Hence
A−t
n ·





yn
yn+1
yn+2
. . .
yn+m−1




=





y0
y1
y2
. . .
ym−1





Each row gives the equation
 A−t
n

i,1 · yn

·


m
X
j=1
(A−t
n )i,j
 A−t
n

i,1
· yn+j−1
yn

= yi
Assuming yn is the "slowest" solution to the recurrence, we get that
lim
n→∞
yn+1
yn
= λm
Hence (A−t
n )i,1 · yn does not converge exponentially. On the other hand, the sum Pm
j=1
(A−t
n )i,j
(A−t
n )i,1
·
yn+j−1
yn
converges exponentially, so since the limit is non-zero, the limit must be bounded. Note that
each row of eA is a general solution to the system defined by A−t(n) so by Poincare-Perron theorem
(A−t
n )i,j+1
(A−t
n )i,1
= λ−j
m is independent of i, so we get that
lim
n→∞
Pm
j=1
(A−t
n )i,j
(A−t
n )i,1
· yn+j−1
yn
Pm
j=1
(A−t
n )i′,j
(A−t
n )i′,1
· yn+j−1
yn
= 1
Hence
lim
n→∞

(A−t
n )i,1 · yn

·
Pm
j=1
(A−t
n )i,j
(A−t
n )i,1
· yn+j−1
yn

 A−t
n

i′,1 · yn

·
Pm
j=1
(A−t
n )i′,j
(A−t
n )i,1
· yn+j−1
yn
 = yi
yi′
As needed.
E.4
Coboundary transform
Given a recurrence relation un, we are interested in analyzing the dynamics of its solutions, which
translates to analyzing the behavior of the companion matrix CM(n) increments, i.e., the behavior of
the step matrix Mn as n approaches infinity.
We are interested in the ratio between solutions to the recurrence. Consequently, we look at these ma-
trices as elements in the projective group PGLm (Q(n)) We will recall the definition of a coboundary
equivalence:
Two matrices A(n), B(n) ∈PGLm (Q(n)) are said to be coboundary equivalent if there exist a
matrix U(n) such that
A(n) · U(n + 1) = U(n) · B(n)
(18)
From the equation above we see that A(n) = U(n)·B(n)·U −1(n+1) thus exhibiting a “telescoping
effect” on the product, resulting in the equation:
(
n
Y
i=1
A(n)) · U(n + 1) = U(1) · (
n
Y
i=1
B(n))
33


--- Page 34 ---
This suggests that these matrices share similar dynamics.
We denote A(n) ∼B(n), to indicate that they are coboundary equivalent, and we often call the
matrix U(n) a coboundary transform from A(n) to B(n).
Index shift:
Notice that the matrices A(n) and A(n+1) are coboundary equivalent by simply taking U(n) = A(n).
This implies that an index shift is a coboundary operation. Since coboundary is an equivalence, by
transitivity, any integer index shift is also a coboundary operation.
Inflation:
Given a function un satisfying the relation
un = a1,nun−1 + a2,nun−2 + . . . + am,nun−m
We can define eun = un ·
n
Y
i=1
ci for some function cn. The function eun satisfied the relation
eun = a1,ncneun−1 + a2,ncncn−1eun−2 + . . . + am,ncncn−1 · · · cn−(m−1)eun−m
Let CM(n) denote the companion form of un and g
CM(n) denote the companion form of eun, then
the matrix
U(n) =













m−1
Y
i=1
c(n −i)
0
. . .
0
0
0
m−2
Y
i=1
c(n −i)
. . .
0
0
...
...
...
...
...
0
0
. . .
c(n −1)
0
0
0
. . .
0
1













Is a coboundary transform between CM(n) and g
CM(n). This process is called inflation and it allows
one to construct a Polynomial Continued Fraction (PCF) from a recurrence given by rational function
coefficients. In [52], this is done by taking cn to be the LCM of the denominators. In the other
direction starting from a PCF (a(n), b(n)) and taking Cn = n−deg(a), the inflation by cn is called
factorial reduction [10].
E.4.1
Canonical form
We have seen that a recurrence relation with rational function coefficients can be transformed via
inflation to a recurrence with polynomial coefficients. We say that a recurrence
un = a1,nun−1 + a2,nun−2 + . . . + am,nun−m
is in canonical form if the coefficients ai,n are polynomials, and for any other recurrence with
polynomial coefficients a′i,n which is coboundary equivalent to it, the degree of each ai,n is less than
or equal to the degree of the corresponding a′i,n. Appendix C.4 explains how the minimal recurrence
is found for each formula.
Lemma 2 asserts that in the case of second-order recurrences, any formula-generating matrix is
equivalent to a companion matrix. In turn, this is equivalent to a companion matrix of a recurrence
un = a(n)un−1 + b(n)un−2 with polynomial coefficients through the process of inflation. We
denote such recurrences by PCF (a(n), b(n)) as they are associated with a polynomial continued
fraction
M(n)(0) =
b(1)
a(1) +
b(2)
a(2) +
...
+ b(n)
a(n)
= pn
qn
34


--- Page 35 ---
The canonical form of PCF
 n2 + n + 1, n4 + n2 + 1

, for example, is equal to PCF (1, 1), the
simplest continued fraction for the Golden Ratio.
E.4.2
Group cocycle and coboundary
We now describe the mathematical context that motivates our definition of coboundary equivalence.
Let Γ be a group acting by automorphisms on a group G via the map:
φ: Γ →Aut(G)
A Γ-cocycle with respect to φ is a map M: Γ →G satisfying the cocycle condition:
M(γ1γ2) = M(γ1) · φγ1(M(γ2))
(19)
We declare two cocycles, M and M′, to be coboundary equivalent if there exists an element g ∈G
such that:
g · M(γ) = M′(γ) · φγ(g)
(20)
For further details, we refer the interested reader to Chapter 5 of [51].
Here, we focus on the case where Γ = Z and G = PGLm (Q(n)).
For any k ∈Γ, and A(n) ∈G, the action map is defined by φm(A(n)) = A(n + k). Since Z is
generated by a single element, any cocycle M: Γ →G is determined by the value M1(n) ∈G. For
k > 0 the cocycle condition implies the
Mk(n) =
k−1
Y
i=0
M1(n + i)
Moreover since M0(n) = Idm, have that Mk(n) = (M−k(n −k))−1
From the definition of the coboundary equivalence in the context of group cocycles, we get that two
Γ-cocycles, M and M′, are coboundary equivalent if there exists U(n) ∈G such that:
U(n) · M1(n) = M′
1(n) · U(n + 1)
When regarding a matrix A(n) ∈PGLm (Q(n)) as the matrix M1(n) generating the cocycle, this
equivalence is precisely the definition given in Definition (7).
E.4.3
Cocyles in dynamical systems
Let T be a homeomorphism T : X →X of some topological space. In dynamical systems, one
studies the evolution of the system under the repeated application of the transformation T.
A function
A: Z × X →GLm(R)
satisfying
A(k1 + k2, x) = A(k1, x)A(k2, T k1(x))
is called a continuous linear cocycle [12].
Also in this context, a single matrix A(n) ∈GLm (Q(n)) defines a cocycle. This is done by taking
X = R, and constructing a cocycle by defining
A(k, x) =
k−1
Y
i=0
A(x + i)
Typically, it is assumed that the topological space X is a compact space or a probability measure
space. [18] Our definition of coboundary equivalence (7) is not only mathematically natural but also
captures the essence of our dynamic framework. The vast data collected on related formulas suggest
that this notion is effective for equating formulas, as it preserves the measure of irrationality.
35


--- Page 36 ---
E.5
Fold transform
Consider the matrix A(n) as encoding a process defined by incrementally multiplying the matrix.
We might wish to associate a matrix with an accelerated process, one that goes “k steps at a time.”
That is, a matrix Ak-fold(n) such that taking one step in Ak-fold(n) is equivalent to taking k-steps in A.
This requirement can be expressed as:
nk
Y
i=1
A(i) =
n
Y
i=1
Ak-fold(i)
And the k-fold matrix is given by the product:
Ak-fold(n) :=
k
Y
j=1
A (k(n −1) + j)
When the matrix A(n) is a trajectory matrix within CMF (as described in Appendix G.1 ), the
k-folding of A(n) corresponds to the trajectory matrix associated with a direction that is k-times the
original direction.
E.5.1
An example of folding per convergence rate
The ratio of r (Eq. (4)) between formulas, when they exist and are non-zero, hints that one may be a
transformation of a subsequence of the other. To see why, consider two series; one with summand
s(n) and the other with summand s(3n −2) + s(3n −1) + s(3n). These series have the same
limit, as the latter produces a subseries of the former, but its convergence rate may be 3 times higher.
Evidently, their summands do not appear directly equivalent. Our algorithm thus applies folding
(Appendix E.5) to equate the r values of each pair of formulas that are candidates for equivalence.
following is an example of two such series for π (120 and 121 from Table 17):
∞
X
n=0
an :=
∞
X
n=0
(−1)n4−n(
1
4n + 3 +
2
4n + 2 +
2
4n + 1) = π
(21)
featured in [1, 30], with a convergence rate of 1.39, and
∞
X
k=0
bk :=
∞
X
k=0
16−k(−
1
4(8k + 7)−
1
2(8k + 6)−
1
2(8k + 5)+
1
8k + 3+
2
8k + 2+
2
8k + 1) = π (22)
featured in [8], with a convergence rate of 2.77, are not directly coboundary equivalent. However,
one can examine that when summing over Eq. (21) in pairs, meaning:
∞
X
n=0
an =
∞
X
k=0
a2k + a2k+1
it is easily verified that bk = a2k + a2k+1. Thus, these formulas ought to be considered equivalent,
and indeed were matched by our algorithm (Appendix C.2) by first folding the sum in Eq. (21) by
2.77
1.39 = 2.
F
Coboundary matrix properties
F.1
A necessary condition on the coboundary matrix
Below we include a proof of the necessary condition a coboundary matrix must obey that was
leveraged to create UMAPS Appendix C.3. We start with the case of 2 × 2 matrices (second-order
recurrences), then generalize to any order.
Lemma 1.
(A necessary condition on the coboundary equivalence matrix.)
Let LA
=
lim
n→∞PCF (a(n), b(n)) and LB = limn→∞PCF (c(n), d(n)) be converging PCFs with asso-
ciated companion matrices A(n), B(n) ∈PGL2 (Q(n)). If A(n) is coboundary to B(n), then LA
and LB are related through a rational Möbius transformation, moreover, if U(n) is the coboundary
matrix then LA = U(1)(LB) (U(1) applied to LB as a Möbius transformation).
36


--- Page 37 ---
Proof. Let An and Bn be the step matrices of the PCF recurrence.
An =
n
Y
i=1
A(i) =

pn−1
pn
qn−1
qn

,
Bn =
n
Y
i=1
B(i) =

sn−1
sn
tn−1
tn

Let
U(n + 1) =

α(n)
β(n)
γ(n)
δ(n)

with α, β, γ, δ polynomials. Since A(n) and B(n) are coboundary equivalent
An · U(n + 1) = U(1) · Bn
This implies equality when applying a factional linear transformation to 0.

pn−1
pn
qn−1
qn

· U(n + 1)

(0) =

U(1) ·

sn−1
sn
tn−1
tn

(0)
(23)
Taking the limit, The left hand side of equation (23) above yields
lim
n→∞
pn−1β(n) + pnδ(n)
qn−1β(n) + qnδ(n) = lim
n→∞
pn−1
qn−1
·


β(n)
δ(n) +
pn
pn−1
β(n)
δ(n) +
qn
qn−1


While on the right-hand side:
lim
n→∞

U(1) ·

sn−1
sn
tn−1
tn

(0) = U(1)

lim
n→∞

sn−1
sn
tn−1
tn

(0)

= U(1)(LB)
The matrix A(n) is a companion matrix for a second-order linear recurrence, any solution for the
recurrence is composed of two prime solutions xn, yn, where the growth of xn is dominant over
the growth of yn. Since pn
qn converge, we know that pn and qn both have an xn component to them,
making
pn
pn−1 and
qn
qn−1 both grow asymptotically the same, this renders lim
n→∞(
β(n)
δ(n) +
pn
pn−1
β(n)
δ(n) +
qn
qn−1
) = 1
and we may conclude that
lim
n→∞
pn−1β(n) + pnδ(n)
qn−1β(n) + qnδ(n) = lim
n→∞
pn−1
qn−1
·


β(n)
δ(n) +
pn
pn−1
β(n)
δ(n) +
qn
qn−1

= LA · 1
Hence LA = U1(LB) as needed.
Let us generalize Lemma 1 for matrices of higher dimensions.
Lemma 4. (Generalized necessary condition on the coboundary equivalence matrix.) Given two
coboundary equivalent companion matrices A(n), B(n) ∈PGLm (Q(n)) , A(n)U(n + 1) =
U(n)B(n) with m ≥2 and the step matrices:
An = Qn
i=1 A(i) =






p1,n−m
. . .
p1,n−1
p1,n
p2,n−m
. . .
p2,n−1
p2,n
p3,n−m
. . .
p3,n−1
p3,n
...
...
...
...
pm,n−m
. . .
pm,n−1
pm,n






,
Bn = Qn
i=1 B(i) =






q1,n−m
. . .
q1,n−1
q1,n
q2,n−m
. . .
q2,n−1
q2,n
q3,n−m
. . .
q3,n−1
q3,n
...
...
...
...
qm,n−m
. . .
qm,n−1
qm,n






s.t the right most columns of An, Bn both converge projectively:
LA, LB ∈Pn−1R , LA := lim
n→∞



p1,n
...
pm,n


, LB := lim
n→∞



q1,n
...
qm,n



and all entries of LA, LB are non-zero, we have:
LA = U(1)LB
37


--- Page 38 ---
Proof. Let
U(n + 1) =






u1,1(n)
. . .
u1,m−1(n)
u1,m(n)
u2,1(n)
. . .
u2,m−1(n)
u2,m(n)
u3,1(n)
. . .
u3,m−1(n)
u3,m(n)
...
...
...
...
um,1(n)
. . .
um,m−1(n)
um,m(n)






With ui,j(n) rational functions. Given A(n)U(n+1) = U(n)B(n), we have AnU(n+1) = U(1)Bn.
This implies the following equality:
AnU(n + 1)




0
0
...
1



= U(1)Bn




0
0
...
1



=⇒An




u1,m(n)
u2,m(n)
...
um,m(n)



= U(1)




q1,n
q2,n
...
qm,n




(24)
Taking the projective limit on both sides of this equation yields on the right:
lim
n→∞U(1)




q1,n
q2,n
...
qm,n



= U(1)LB
On the left, we first need to claim a few things regarding the growth rate of solutions to the recurrence
represented by A(n). Using Poincare Perron asymptotics, we can claim that there are m different
canonical solutions x(i)
n , with different growth rates. Thus any solution is a linear combination of
these canonical solutions. For a solution rn = P aix(i)
n , we shall call the fastest growing canonical
solution x(i)
n s.t ai ̸= 0 the dominating solution. The projective convergence of



p1,n
...
pm,n


to nonzero
limits, implies that all pi,n have the same dominating solution. Otherwise, if the dominating solution
of pj,n grows faster than the dominating solution of pk,n, then limn→∞
pk,n
pj,n = 0, in contradiction to
our assumption of non-zero entries in LA.
Finally, let us return to the left-hand side of (24):
An




u1,m(n)
u2,m(n)
...
um,m(n)



=




Pm
i=1 p1,n−i+1ui,m(n)
Pm
i=1 p2,n−i+1ui,m(n)
...
Pm
i=1 pm,n−i+1ui,m(n)




As we are interested in the projective limit, let us consider the limit of the ratio of the kth and jth
elements in the left-hand side:
Pm
i=1 pk,n−i+1ui,m(n)
Pm
i=1 pj,n−i+1ui,m(n) = pk,n
pj,n
·
Pm
i=1
pk,n−i+1
pk,n
ui,m(n)
Pm
i=1
pj,n−i+1
pj,n
ui,m(n)
Now, given that both pk,n, pj,n have the same dominating solution, we have that pk,n−i+1
pk,n
, pj,n−i+1
pj,n
grow asymptotically the same in n, making:
lim
n→∞
Pm
i=1
pk,n−i+1
pk,n
ui,m(n)
Pm
i=1
pj,n−i+1
pj,n
ui,m(n) = 1 =⇒
lim
n→∞
Pm
i=1 pk,n−i+1ui,m(n)
Pm
i=1 pj,n−i+1ui,m(n) = lim
n→∞
pk,n
pj,n
Which implies, by definition of projective convergence:
lim
n→∞An




u1,m(n)
u2,m(n)
...
um,m(n)



= LA
Which finally gives
LA = U(1)LB
38


--- Page 39 ---
F.2
Uniqueness
Lemma 5. (Projective uniqueness of coboundary matrices.) Let A(n), B(n) ∈PGLm (Q(n)) be
two rational matrices as in Lemma 4. Suppose further that the projective limit LB of B(n) has no
algebraic relations over the rationals. Then, if A(n), B(n) are coboundary equivalent, there exists a
unique coboundary matrix realizing this equivalence.
Proof. Let U1(n), U2(n) be two coboundary matrices between A(n), B(n). We therefore have
⇒A(n) = U1(n) · B(n) · U1(n + 1)−1 = U2(n) · B(n) · U2(n + 1)−1. So B(n) is coboundary to
itself with U3(n) = U1(n)−1U2(n). We will show that U3(n) is the identity in PGLm (Q(n)), Im,
i.e. that there are no non-trivial coboundary matrices between B(n) and itself. By construction
B(k) = U3(k) · B(k) · U3(k + 1)−1
Therefore if U3(1) = Im then U3(k) = Im for any k ∈N. Assuming LB has no algebraic relations
over the field of rational numbers, it follows that no non-trivial matrix U with rational coefficients
satisfies
U · LB = LB
By Lemma 4 we have that LB = U3(1)LB, hence U3(1) = Im as desired.
G
The Conservative Matrix Field (CMF)
The CMF defined in [21] has polynomial coefficients, which is not enough for our purposes since the
π-CMF (Eq. (25)) has rational function as coefficients. We redefine the CMF in a way that allows
one to insert rational functions as coefficients.
Definition 1. A d-dimensional CMF of rank m is defined by a collection of d-matrices Mx1, . . . , Mxd
in PGLm (Q(x1, . . . , xd)) satisfying the conserving property, that is, for any pair i ̸= j
Mxi(x1, . . . , xi, . . . , xj, . . . , xd)Mxj(x1, . . . , xi + 1, . . . , xj, . . . , xd)
=
Mxj(x1, . . . , xi, . . . , xj, . . . , xd)Mxi(x1, . . . , xi, . . . , xj + 1, . . . , xd)
Envision a d-dimensional lattice where each edge has a displacement function representing the “work"
of moving between vertices. The conserving property is that: the work is path-independent.
G.1
Trajectory matrices in a CMF
Let M, be a d-dimensional CMF of rank m. Given a point x ∈Qd and a direction v ∈Zd the
evaluation map v 7→Mv(x) describes the displacement from point x to point x + v. By the
conserving property, the total work for a displacement along a broken path, say, first from x to x + v
and then from x + v to (x + v) + w, is equal to the total displacement from x to x + v + w, in terms
of the evaluation map this is translated to:
Mv+w(x) = Mv(x)Mw(x + v)
We can construct a general matrix representing the work going from the point x + (n −1)v to the
point x + nv, this matrix is in PGL2 (Q(n)) and is given by
Tx,v(n) = Mv(x + (n −1)v)
We call this matrix the trajectory matrix associated with the point x in direction v.
Note that by the conserving property Id = M−v+v(x) = M−v(x)Mv(x −v), this provides us with
the identity
M−v(x) = M −1
v (x −v)
Taking a point x′ in the lattice x + Zd with the same direction v yields the trajectory matrix
Tx′,v(n) = Mv(x′ + (n −1)v)
39


--- Page 40 ---
Since x′ is in the same lattice, the difference w = x′ −x is in Zd. The direction w represents the
direction from x to x′. By the conserving property taking U(n) = Tx,w(n), the trajectory matrix
from x in the direction w is a coboundary transform between Tx,v(n) and Tx′,v(n).
In terms of the evaluation functions we see explicitly :
Mv+w(x + (n −1)v) = Mv+w(x + (n −1)v)Mw(x + (n −1)v + v) = Tx,v(n)Tx,w(n + 1)
and
Mv+w(x + (n −1)v) = Mw(x + (n −1)v)Mv(x + (n −1)v + (x′ −x)) = Tx,w(n)Tx′,v(n)
Appendix C.5 describes how to construct a trajectory matrix given a CMF and a trajectory.
G.2
The π-CMF
The following three matrices describe a 3D rank 2 CMF (same as Eq. (6)).
Mx =
1
y
1
x
2x+y−2z+2
x

My =
1
x
1
y
x+2y−2z+2
y

Mz =
 z(−x−y+z)
(y−z)(x−z)
zxy
(y−z)(x−z)
z
(y−z)(x−z)
−z2
(y−z)(x−z)
!
(25)
The cocycle M: Z3 →PGL2 (Q(n)) is defined on the generators of Z3 as
Me1 = Mx,
Me2 = My,
Me3 = Mz
G.2.1
Fundamental properties of the π-CMF
Let 2F1(a1, a2, a3; z) represent the Gauss hypergeometric function
2F1(a1, a2, a3; z) =
∞
X
n=0
(a)n(b)n
(c)n
zn
n!
Denoting the Euler operator by Θ = z ·
d
dz, the Gauss hypergeometric function has well-known
contiguous relations that are encoded by the Mei matrices as detailed in [58]. In particular, we have
the following property:
[2F1(a1, a2, a3; 1
2), Θ2F1(a1, a2, a3; 1
2)]·Me1 = [2F1(a1 +1, a2, a3; 1
2), Θ2F1(a1 +1, a2, a3; 1
2)]
[2F1(a1, a2, a3; 1
2), Θ2F1(a1, a2, a3; 1
2)]·Me2 = [2F1(a1, a2 +1, a3; 1
2), Θ2F1(a1, a2 +1, a3; 1
2)]
[2F1(a1, a2, a3; 1
2), Θ2F1(a1, a2, a3; 1
2)]·Me3 = [2F1(a1, a2, a3 +1; 1
2), Θ2F1(a1, a2, a3 +1; 1
2)]
G.2.2
Example of a formula arising as a trajectory in the CMF
Let x = ( 1
2, −1
2 , 3
2) be an point in space defining the lattice x + Z3. Directions between points in this
lattice correspond to a vast collection of formulas for π as seen in Fig. 6.
For completeness of the exposition, we take the most simple direction e3 = (0, 0, 1) and show how
the famous Euler formula PCF (1, n(n + 1)) =
2
π−2 sits as a trajectory matrix over the point x in
the direction e3.
CM(n) =

0
n(n + 1)
1
1

is the companion form of Euler’s PCF.
40


--- Page 41 ---
The trajectory matrix is equal to
Tx, e3(n) = Me3(1
2, −1
2 , 3
2 + (n −1)) =
 (2n+1)2
4n(n+1)
−2n−1
8n(n+1)
2n+1
2n(n+1)
−(2n+1)2
4n(n+1)
!
Following the process described in Lemma 2 we define
U(n) =
 
2n+1
2n(n+1)
−(2n+1)2
4n(n+1)
0
1
!
and get that
E(n) = U(n)T(n)U −1(n + 1) =
 
0
n2+2n+ 3
4
n2+3n+2
1
n+ 3
2
n2+3n+2
!
· 2n2 + 5n + 2
n(2n + 3)
Is in companion form. We let I(n) be the inflation by cn = n2 + 3n + 2 (see E.4) and we get the
relation
I(n) · E(N) = CM(n) · I(n + 1)
Concluding T(n) ∼E(n) ∼CM(n), which states the equivalence of the trajectory with Euler’s
PCF.
G.3
The CMF proves the convergence formula
Recall that the π-CMF records the data of the contiguous relations of the Gauss hypergeometric
function as shown in G.2.1.
For a trajectory v ∈Z3, we denote
Fn = 2F1(1
2 + v1 · n, 1
2 + v2 · n, 1
2 + v3 · n; 1
2)
Gn = Θ2F1(1
2 + v1 · n, 1
2 + v2 · n, 1
2 + v3 · n; 1
2)
Under this notation, we get that the trajectory matrix Tx,v(n) at the initial point x = ( 1
2, 1
2, 1
2) in
direction v is the matrix that represents a forward shift in the parameter n, i.e
Tx,v(n) : [Fn, Gn] 7→[Fn+1, Gn+1]
Following the procedure in Lemma 2, we get that Cx,v(n), the companion form of Tx,v(n), is the
matrix that encodes the step going from [Fn, Fn+1] to [Fn+1, Fn+2]
[Fn, Gn]
[Fn+1, Gn+1]
[Fn, Fn+1]
[Fn+1, Fn+2]
Tx,v(n)
U −1(n+1)
U(n)
Cx,v(n)
In the case Cx,v(n) is Poincaré-Perron type see Section E.3, it follows by Lemma 3 that the projective
limit
lim
n→∞
n
Y
i=1
Cx,v(i)−t = [1, F2
F1
]
Where Fn is the solution growing like |λ2|n where |λ1| > |λ2| the characteristics roots of the
recurrence equation.
Notice that
(
n
Y
i=1
Cx,v(i)−1)(
n
Y
i=1
Cx,v(i)) = Id
Hence the first column of Qn
i=1 Cx,v(i)−t is perpendicular to the second column of Qn
i=1 Cx,v(i).
So in the limit, the second column is projectively equal to [−F2
F1 , 1], hence the limit is equal to −F2
F1 .
In conclusion, given a trajectory matrix T(n) with companion form matrix C(n) that is Poincaré-
Perron type, we get that the limit of C(n) is −F2
F1 and consequently the limit of the trajectory matrix
T(n) is U(1).

−F2
F1

for a solution Fn of the recursion with the smaller λ2 growth rate.
41


--- Page 42 ---
G.4
Proof for the trajectory (1,1,2)
Taking the trajectory v = (1, 1, 2) we get Fn = 2F1( 1
2 + n, 1
2 + n, 1
2 + 2n; 1
2). The trajectory matrix
and companion form are
T(n) =





(4n + 5)(4n + 7)
2(n + 1)2
−(4n + 5)(4n + 7)2
4(n + 1)2
−(16n + 28)(4n + 5)2
4(n + 1)2(2n + 3)2
(4n + 5)(4n + 7)(80n + 104)
(n + 1)2(32n + 48)





C(n) =





0
−(4n + 11)(4n + 7)(4n + 9)2
(n + 2)2(2n + 5)2
1
(4n + 7)(4n + 9)(8n + 22)(6n2 + 21n + 17)
(n + 2)2(2n + 5)2(4n + 5)





With the limit matrix C(∞) being Poincaré-Perron type
C(∞) =
 
0
−64
1
48
!
Having the characteristic roots (eigenvalues) {24 −16
p
(2), 24 + 16
p
(2)}. All we need to show is
that Fn does not grow exponentially like 24 + 16
p
(2) ≈46.627.
By the Euler identity for the hypergeometric function
2F1(a, b, c; x) =
Γ(c)
Γ(a)Γ(c −a)
Z 1
0
t a−1(1 −t)c−a−1(1 −xt)−b dt.
We get that
F(n) =
Γ
  1
2 + 2n

Γ
  1
2 + n

Γ(n)
Z 1
0
t n−1
2 (1 −t) n−1 1 −t
2
−(n+ 1
2 ) dt.
Setting
f(t) = log
t(1 −t)
1 −t
2

,
ψ(t) = t−1/2(1 −t)−1 1 −t
2
−1/2 ,
so that
2F1 =
Γ
  1
2 + 2n

Γ
  1
2 + n

Γ(n)
Z 1
0
enf(t) ψ(t) dt.
Using Stirling’s formula
Γ(z) ∼
√
2π z z−1
2 e−z,
(z →∞),
we find
Γ
  1
2 + 2n

Γ
  1
2 + n

Γ(n) ∼
√
2π (2n)2ne−2n
 √
2π nne−n √
2π n n−1
2 e−n = 4 n√n
√
2π
 1 + O(1/n)

.
Hence, the Gamma prefactor contributes an exponential growth factor 4n.
The function f(t) has a maximal value at t∗∈(0, 1)
t∗= 2 −
√
2,
fmax = log(6 −4
√
2) = 2 log(2 −
√
2).
Thus
max
t∈(0,1) enf(t) = (6 −4
√
2)n.
Note that although ψ(t) diverges at the endpoints, the full integrand
t n−1
2 (1 −t) n−1 1 −t
2
−(n+ 1
2 ) = enf(t)ψ(t)
42


--- Page 43 ---
is integrable for every n, therefore by the Laplace method, we get:
Z 1
0
enf(t)ψ(t) dt ≤C (6 −4
√
2)n
for some constant C > 0.
Combining the two parts gives
Fn ≤4 n√n
√
2π (6 −4
√
2)n C = poly(n)
 24 −16
√
2
n,
Fn ≤
 24 −16
√
2
n · poly(n)
The exponential growth rate is thus governed by (24 −16
√
2)n proving the convergence of the
companion form matrix C(n) will be to −F2
F1 .
G.5
Proof for the entire π-CMF and related hypergeometric constants
To prove the convergence for the entire CMF we need to estimate Fn for each trajectory (α, β, γ) ∈
Z3. We will estimate the exponential growth in a way similar to the process done for direction
(1, 1, 2), but keep it general and symbolic. This will give us the exponential growth rate of Fn in each
trajectory (α, β, γ). Next, we will analyze the CMF to estimate the possible growth rates from the
eigenvalues and show that the smallest one is equal to the estimated rate of Fn we had before.
G.5.1
The growth rates for given directions in the CMF
Recall that the CMF is constructed as a D-finite CMF with respect to bases {2F1, Θ ·2 F1}. We can
conduct a change of basis to get an equivalent CMF with bases {2F1,
y0
x0x1Θ ·2 F1}. This CMF is
defined by the matrices:
Mx =
1
z
x+1
y
z
2x+y−2z+2
x+1

My =
1
z
y+1
x
z
x+2y−2z+2
y+1

Mz =
 z(−x−y+z)
(y−z)(x−z)
z(z+1)
(y−z)(x−z)
xy
(y−z)(x−z)
−z(z+1)
(y−z)(x−z)
!
(26)
The matrices here now have coefficients of balanced degree 0: When going to infinity in x, y, z, only
the dominant factors from the denominator and numerator contribute, so at infinity we get these three
commuting matrices:
f
Mx =
1
z
x
y
z
2x+y−2z
x

f
My =
1
z
y
x
z
x+2y−2z
y

f
Mz =
 z(−x−y+z)
(y−z)(x−z)
z2
(y−z)(x−z)
xy
(y−z)(x−z)
−z(z+1)
(y−z)(x−z)
!
(27)
These matrices can be mutually diagonalized, set
∆= x2 + 6xy −4xz + y2 −4yz + 4z2 = (x + y −2z)2 + 4xy
S1 = 3x + y −2z, S2 = x + 3y −2z
43


--- Page 44 ---
We have the eigenvalues:
f
Mx −→S1
2x ±
√
∆
2x = {λ1,−, λ1,+},
f
My −→S2
2y ±
√
∆
2y = {λ2,−, λ2,+},
f
Mz −→−
z(x + y)
2(x −z)(y −z) ±
z
√
∆
2(x −z)(y −z) = {λ3,−, λ3,+}.
Hence







|λ1,−| ≤|λ1,+|
if ∆= 0 or S1 ≥0,
|λ2,−| ≤|λ2,+|
if ∆= 0 or S2 ≥0,
|λ3,−| ≤|λ3,+|
if ∆= 0 or z = 0 or x + y ≤0.
The growth rates of a trajectory matrix in direction v = (α, β, γ) are exactly the eigenvalues of Tv(∞),
which is the limit of the trajectory matrix Tx′,v(n) with n going to infinity. By our construction of
the "infinity matrices" f
M, we have that
Tv(∞) = ˜
Mx(α, β, γ)α · ˜
My(α, β, γ)β · ˜
Mz(α, β, γ)γ
If we assume, for example, that
S1((α, β, γ) ≤0, S2((α, β, γ) ≤0, α + β ≥0
We get that the minimal growth is given by
B(α, β, γ) = λ1,+(α, β, γ)α · λ2,+(α, β, γ)β · λ3,+(α, β, γ)γ
(28)
G.5.2
The growth rates for the Fn in each direction
We consider the Gauss hypergeometric function in the scaling form
F(n; x) = 2F1(a, b; c; x)
with
a = a0 + αn,
b = b0 + βn,
c = c0 + γn,
for fixed real slopes (α, β, γ) and a fixed x ∈(0, 1). As n →∞, the asymptotic growth of Fn is
governed by a Laplace–type integral representation, and takes the general form
|F(n; x)| ≍B(α, β, γ; x) n,
where B(α, β, γ; x) > 0 is the exponential base.
The base B depends on which integral representation (Euler–b, Euler–a, or Kummer at x ≈1) is
valid, and whether the dominant contribution comes from an interior saddle or an endpoint. For
x = 1
2 these regimes can be described explicitly as follows.
Assume
γ > α,
γ ≥β ≥0,
In this regime, the integral
2F1(a, b; c; x) =
Γ(c)
Γ(b)Γ(c −b)
Z 1
0
t b−1(1 −t)c−b−1(1 −xt)−a dt
is convergent and admits an interior stationary point t∗∈(0, 1).
The phase function is
Φ1(t) = β log t + (γ −β) log(1 −t) −α log(1 −xt),
and for x = 1
2 the saddle equation Φ′
1(t) = 0 has the exact solution
t∗= −(α −β −2γ) −
√
∆
2(γ −α)
,
∆= α2 + 6αβ −4αγ + β2 −4βγ + 4γ2.
44


--- Page 45 ---
Substituting t∗into the integrand and adding the Stirling rate coming from the Gamma prefactors
Sb = γ log |γ| −β log |β| −(γ −β) log |γ −β|
yields the simplified closed form
Bint(α, β, γ) =
 
3α + β −2γ −
√
∆
2α
!α  
α + 3β −2γ −
√
∆
2β
!β
×
 
−γ(α + β −
√
∆)
2(α −γ)(β −γ)
!γ
.
Thus, in this regime,
|y1(n; 1
2)| ≍Bint(α, β, γ) n.
Which is equal to the function B(α, β, γ)!
To see this, recall that
t∗= −(α −β −2γ) −
√
∆
2(γ −α)
.
Then
1 −t∗=
S
2(γ −α),
1 −t∗
2 =
L3
4(γ −α),
where we introduce the linear forms
L1 := 3α+β −2γ +s,
L2 := α+3β −2γ +s,
L3 := (2γ −3α−β)+s,
S := s−(α+β).
Step 1: LHS in linear forms. From the definitions,
eΦ(t∗) = (t∗)β(1 −t∗)γ−β
(1 −t∗
2 )α
=

−(α −β −2γ) −s
β Sγ−β
Lα
3
· (4(γ −α))α
(2(γ −α))γ .
Multiplying by the prefactor gives
LHS =

−(α −β −2γ) −s
β Sγ−β
Lα
3
· (4(γ −α))α
(2(γ −α))γ ·
γγ
ββ(γ −β)γ−β .
Step 2: RHS in linear forms. By definition of the λ’s,
RHS = (λ1,+)α(λ2,+)β(λ3,+)γ =
Lα
1 Lβ
2Sγ
(2α)α(2β)β [ 2(γ −α)(γ −β) ]γ γγ.
Step 3: Reduce to two linear identities. Cancel γγ and the common factor Sγ−β. We need to show

−(α −β −2γ) −s
β
Lα
3
· (4(γ −α))α
(2(γ −α))γ ·
1
ββ(γ −β)γ−β =
Lα
1 Lβ
2Sβ
(2α)α(2β)β[ 2(γ −α)(γ −β) ]γ .
After clearing constants this is equivalent to

−(α −β −2γ) −s
β  8α(γ −α)
α 2β(γ −β)β = Lα
1 Lβ
2Sβ Lα
3 .
(∗)
It suffices to establish the following two identities (both linear or quadratic in s):
(I)

−(α −β −2γ) −s

· 2(γ −β) = L2 S,
(II)
L1 L3 = 8 α(γ −α).
Verification of (I). Expand the right-hand side:
L2 S = (α + 3β −2γ + s)( s −α −β ) = s2 −(α + β)(α + 3β −2γ) + s(α + 3β −2γ −α −β).
45


--- Page 46 ---
Using s2 = ∆= (α + β −2γ)2 + 4αβ, a short simplification yields
L2 S = 2(γ −β)
 −α + β + 2γ −s

= 2(γ −β)

−(α −β −2γ) −s

,
which is exactly (I).
Verification of (II). Note L3 = (2γ −3α −β) + s = −(3α + β −2γ) + s. Hence
L1L3 = (s + 3α + β −2γ) (s −(3α + β −2γ)) = s2 −(3α + β −2γ)2.
But
(3α + β −2γ)2 = (α + β −2γ + 2α)2 = (α + β −2γ)2 + 4α(α + β −2γ) + 4α2.
Therefore,
L1L3 =

(α + β −2γ)2 + 4αβ

−

(α + β −2γ)2 + 4α(α + β −2γ) + 4α2
= 8 α(γ −α),
which is (II).
Finish. Raise (I) to the power β and (II) to the power α; multiply them and use 2β(γ −β)β on the
left to obtain (∗). This matches LHS and RHS, hence the claimed identity holds.
Example.
For (α, β, γ) = (1, 1, 2) one obtains B = Bint = 24−16
√
2, matching direct evaluation.
And for example over the point (α, β, γ) = (1, 1, 3) one obtains B = Bint = (−297
4 + 135 ·
√
5
4 ).
G.5.3
Proof method
For each regime of the parameters α, β, γ, one can establish the growth rates of the hypergeometric
function and the possible eigenvalues of the trajectory matrix at infinity. When the growth rate of the
hypergeometric match the value of the slowest eigenvalue we have by Lemma 3 that the limit is a
ratio of the Gauss hypergeometric function.
This procedure is can be dome for 2F1(a0+α·n, b0+β·n, c0+γ·n; x) and the correspondent values
of with depend only on α, β and γ so using the same CMF for another initial point (a0, b0, c0) one
can get a unified proof that the trajectory converges to the ratio of the hypergeometric functions. In
our case, with initial points being half integers, the ratio is always a rational function of π but we get
infinitely many new proving formulas for any other constant that is a ratio of Gauss Hypergeometrics
(such as log(2) if we take integer initial points), some values even have a positive irrationality
measure!
G.5.4
General D-finite CMF
This above process can be done for a general D-finite CMF (see [58]). We can base-change the CMF
to have balanced degree coefficients and symbolically find the eigenvalues in each trajectory. We can
also apply analysis to the D-finite function the CMF is built from in order to estimate the growth rate
- all we need to do is see that the smallest eigenvalue matches the growth rate of the D-finite function.
G.6
Scanning the dynamical metrics of the π-CMF
Fig. 7 and Fig. 8 visualize the dynamical metrics of the π-CMF on a unit sphere.
The normalized convergence rate is defined r/ℓ1(t), where r is the convergence rate from Eq. (4),
t is a trajectory and ℓ1 is the ℓ1-norm. It allows an unbiased comparison between formulas arising
from the CMF. The need for such an unbiased convergence parameter for CMF formulas stems from
the artificial convergence acceleration that taking multiples of trajectories can cause: if trajectory
(1, 2, 3) has (exponential) convergence rate r, then trajectory (2, 4, 6) will have convergence rate 2r.
The convergence performance of these parallel trajectories, though, remains constant when measured
by the normalized convergence rate. This enables a well-defined convergence measurement for each
direction.
46


--- Page 47 ---
𝛿
Figure 7: The irrationality measure δ, Eq. (5), for different directions in the π-CMF.
𝑟/ℓ1 𝒕
Figure 8: The normalized convergence rate r/ℓ1(t) for different trajectories t in the π-CMF.
47


--- Page 48 ---
H
LLM formula equivalence detection and proving
LLMs were independently asked whether formula pairs proven equivalent by our system are equivalent
(equivalence detection) and subsequently tasked with proving equivalence (equivalence prooving),
regardless of the answer to the first question.
H.1
Test formula pairs
The following equivalent formula pairs, proven by our system, were given to GPT-4o and Gemini 2.5
Pro Preview for detection and proof: (1,2), (3,4), (1,5) from Table 1; (9,10), (63,66), (75,76) from
Table 16; and (82,84), (101,103), (120,121), (140,142) from Table 17. Detection is binary and easily
checked, while proofs were checked manually (recall Table 2). The full results are shown in Table 11.
H.2
Equivalence detection and proving prompts
Detection - system message:
You are an equivalence detector. Your task is to decide whether two given formulas are
mathematically equivalent.
Two formulas are equivalent if one formula implies the other, and vice versa. In other words,
you need to determine whether the following statement is true: Formula A converges to Value
A if and only if Formula B converges to Value B.
You are not required to prove the equivalence—only to determine whether the equivalence
appears to hold. Base your decision on mathematical structure, known identities, or other
relevant patterns. Respond with a clear answer: Yes (equivalent) or No (not equivalent).
Detection - user message:
Table 11: Detailed outcomes of LLM equivalence detection and proving attempts. The three
segments of the table respectively contain formulas from Tables 1, 16 and 17. Gemini 2.5 Pro Preview
is remarkable in proving 50%, sometimes by finding Wilf-Zeilberger pairs [45], but still falls short of
the full challenge.
Formula pair
Note
GPT-4o
detect
GPT-4o
prove
Gemini 2.5 Pro Preview
detect
Gemini 2.5 Pro Preview
prove
(1,2)
equal term by term
-
-
-
+
(3,4)
partial fraction
decomposition
-
+
+
+
(1,5)
-
-
-
-
(9,10)
-
-
+
-
(63,66)
equal term by term
up to added constant
-
-
+
-
(75,76)
-
-
+
-
(82,84)
Ramanujan-Sun pair
from Section 5
-
-
+
-
(101,103)
-
-
+
+
(120,121)
direct fold by 2 (see
Appendix E.5)
+
+
+
+
(140,142)
-
-
+
+
48


--- Page 49 ---
Two formulas are said to be equivalent if one holds if and only if the other does. Specifically,
Formula A converges to and equals value A if and only if Formula B converges to and equals
value B.
In other words, the truth of one formula guarantees the truth of the other, and vice versa.
Given the following two formulas:
FORMULAA_VALUEA
FORMULAB_VALUEB
Are these formulas equivalent?
Proving - system message:
You are an equivalence prover. Your task is to determine whether two given formulas are
mathematically equivalent. That is, proving one formula should be sufficient to establish the
other.
In other words, your goal is to rigorously assess and demonstrate that:
If formula A converges to a value A, then formula B must converge to value B, and vice
versa.
Do not assume equivalence—justify it. Use mathematical reasoning, transformations, or
known identities to support your argument.
The proof of equivalence should be rigorous and detailed.
Proving - user message:
Two formulas are said to be equivalent if one holds if and only if the other does. Specifically,
Formula A converges to and equals value A if and only if Formula B converges to and equals
value B.
In other words, proving the validity of one formula must be sufficient to establish the validity
of the other.
Given the following two formulas:
FORMULAA_VALUEA
FORMULAB_VALUEB
These formulas are equivalent. Please provide a rigorous and detailed justification, a complete
proof of equivalence.
I
Formula harvesting details
I.1
Article retrieval
arXiv’s search API was not reliable for retrieving papers with π formulas. Some simple queries
such as “formula for pi" or “π formula" returned few results (and if the search method is not set
to word-for-word results are mostly irrelevant). Not knowing all patterns in which π tends to be
calculated in, we went with a more exhaustive approach.
455,050 articles from the following categories which were indexed in the arXiv metadata dataset
[5] as of 24 November, 2024, were scraped: math.CA, math.NT, math.PR, math.CO, math.GM,
math.HO, cs.AI, cs.LG and cs.DC.
I.2
LATEX equation patterns and preprocessing
The following unnumbered or inline LATEX math environments were scraped from all articles:
• $ · $,
• $$ · $$,
• \[ · \]
• \( · \)
49


--- Page 50 ---
• math
The following LATEX equation environments were scraped from all articles:
• equation
• align
• gather
• multline
• alignat
• eqnarray
Starred (*) versions of the latter equation environments were also collected, for a total of 17 environ-
ments.
Equation environments were kept so strings with multiple equations could be split into distinct
formulas during preprocessing. Preprocessing was mainly aimed at removing text within equations
and setting uniform symbols for objects like \ddots, \cdots.
I.3
Formula retrieval patterns
Table 12: LATEX formula patterns. Each pattern was paired with both “\pi =” and “= \pi,” and the
\cfrac-based variants of the \frac-containing regular expressions were also included, resulting in
a total of 10 patterns.
Pattern for -
Python re pattern
Series
\ sum \ s*_{(?s:.)*}\ s*\ char‘ˆ\ s*
Sum of \ frac
(\ s*\ frac\ s*{\ s*[^{}]*\ s*}\s*{\ s*[^{}]*\ s*})
((?:\ s*\+\ s*\ frac\ s*{\ s*[^{}]*\ s*}\ s*{\ s*[^{}]*\ s*})+)
Nested \ frac
(\ frac\ s*{\ s*[^{} ]*\ s*}\ s*{\ s*[^{} ]*)
((?:\ frac\ s*{\ s*[^{} ]*\ s*}\ s*{\ s*[^{} ]*)+\ s*}\ s*})
In addition to positive regular expressions (Table 12), presence of any of the following strings in
preprocessed data halted processing: sqrt, tan, cos, sin, log, ln, zeta, pi^
I.4
Formula classification and extraction
LLMs were run via API—GPT-4o with the OpenAI API, Claude 3.7 Sonnet with Anthropic’s API
and Gemini 2.5 Pro Preview through Google AI Studio.
As a formula is extracted, information collected from previous prompts is appended to the following
prompts to reinforce context. See Appendix I.6 for the prompts used. All prompts to the LLM use
a temperature of 0 to promote consistency. The OpenAI GPT API supports a return format called
Structured Outputs, which guarantees a json schema of choice is returned by the LLM. Formula
candidates are passed to the LLM for zero-shot binary classification, into classes: formulas that
compute the constant π and formulas that do not. Candidates are then passed again for trinary
classification into classes: series, continued fraction (the targets of this study), and other formulas
(which are either not π formulas or are but are not series or continued fractions). The third class is
intentionally redundant, as some strings which GPT-4o mini gets wrong may be correctly filtered out
by GPT-4o: out of 3367 strings classified as π-computing series or continued fractions by GPT-4o
mini, 1711 were discarded by GPT-4o, leaving 1656. All examples which were checked manually
were false positives, discarded when double checked by GPT-4o. Example: g(x) = π
2 + P∞
j=1 anxn
(arXiv 2206.11256).
The vast majority of formulas classified as π formulas by GPT-4o were series rather than nested
fractions (1,591 vs 65). In some instances the LLM successfully generalized sequences of numbers
50


--- Page 51 ---
to polynomial expressions, see Table 13. The cost for API calls for the entire analysis—classification
and extraction—was under $50.
Table 13: OpenAI’s GPT-4o extracts the partial numerator and partial denominator of a continued
fraction. Explanation is by the LLM. LATEX taken from [46] (arXiv 1907.00205).
LATEX
3 + \frac{1 * 3}{5 + \frac{2 * 4}{7 +
\frac{3 * 5}{9 + \frac{4 * 6}{11 + ...}}}} =
3\frac{1}{_{2}F_{1} ( 1,\frac{1}{2}; \frac{5}{2}; - 1 ) } =
\frac{4}{\pi - 2}
Rendered
3 +
1·3
5+
2·4
7+
3·5
9+
4·6
11+...
= 3 ·
1
2F1(1, 1
2 ; 5
2 ;−1) =
4
π−2
Prompt
Identify the partial denominator an and partial numerator bn.
Extract each of them and write them as proper SymPy expressions as a
function of depth n.
Output
an = 2*n + 3, bn = n * (n + 2)
Explanation
The partial denominator an is the sequence 5, 7, 9, 11,... which can be expressed as 2*n + 3.
The partial numerator bn is given by the sequence 1*3, 2*4, 3*5, 4*6,...
which can be expressed as n*(n + 2).
In the future, additional formulas could be gathered by allowing the LLM to decide whether to call a
polynomial fitting function on such sequences.
I.5
Formula validation
Validating the collected formulas presents a challenge. The safest way to validate that a formula con-
verges to the expected constant is by computing the formula (attempting to automatically reconstruct
and verify a proof in a formal language is beyond the scope of this study). As exemplified in Table 14,
when prompted for the value of a formula, GPT-4o sometimes omitted free constants, multipliers, or
simple arithmetic adjustments required for the proposed value to match the true value of the formula.
Table 14: A typical extraction by OpenAI’s GPT-4o: The LLM extracts the partial numerator and
partial denominator of a continued fraction, but fails to find the correct value of the formula it collects,
which needs to be isolated through simple arithmetic; the correct value is

2
1−π
4 · 3·3·5·5
2·4·4·6 −1

=
256+75π
256−75π. LATEX taken from arXiv 1806.03346.
LATEX
\frac{\pi}{4} = \frac{2}{3} * \frac{4}{3}
* \frac{4}{5} * \frac{6}{5} * [ 1 - \cfrac{2}{25 + \cfrac{1 * 3}{24 +
\cfrac{3 * 5}{24 + \cfrac{5 * 7}{24 + ...
}}}}} ]
Rendered
π
4 = 2
3 · 4
3 · 4
5 · 6
5 ·













1 −
2
25 +
1 · 3
24 +
3 · 5
24 +
5 · 7
24 + . . .













Prompt
Extraction pipeline (Appendix I.6) with an added prompt for identifying the value.
Output
an = 24, bn = (2n-1)*(2n+1), value = pi / 4.
PSLQ [26] addresses this by finding the correct Möbius transformation between the constant of
interest and the formula’s value, relying solely on the algebraic expression extracted by the LLM.
51


--- Page 52 ---
Given the prior belief that a formula computes a constant and that a nontrivial integer relation exists
between the formula’s empirical value and the constant of interest, the integer relation found is likely
the correct one. The validity of collected formulas is strengthened further when equivalence proofs
are found between them.
After classifying and extracting, GPT-4o still produces some expressions that do not compute π. The
PSLQ-validation stage removes these false positives by finding the precise limit of each formula
in terms of π. Of the 660 candidates, 147 are not Diophantine formulas (e.g. they contain π itself
in the series term), leaving 535 formulas. 150 of these did not pass validation, and many of these
were formulas that do not compute π like −4
π
P∞
n=0
(−1)n
(2n+1)2 = −4G
π (arXiv 1906.04927), and
formulas with mistakes like P∞
i=1
1
i2 = π
6 (arXiv 1811.05831, under proofs.tex). Example for a
non-Diophantine formula for π: P∞
n=0
( 1
2 )n( 1
3 )n( 2
3 )n
(1)3n
( 2
27)n =
3π
4 Γ2( 2
3 )Γ2( 5
6 ) (arXiv 2001.08104), as π
can be computed only when given the irrational denominator.
I.6
Prompts for harvesting formulas
We utilized the Structured Output feature of OpenAI’s models and used a temperature of 0 for all
prompts. The return schemas are included with the prompts. LATEX from prompts is rendered for
readability.
I.6.1
Classification prompts
Initial classification by GPT-4o mini:
System message:
You are a model that classifies whether a LATEX string is a formula that can be rearranged to
calculate the constant
{constant}. Specifically, we are interested in continued fractions and series.
User message:
Is this a continued fraction or a series that can be rearranged to calculate the constant
{constant}? {latex_string}
Structured output: boolean.
I.6.2
Extraction prompts
For added context during extraction, the second classification query shown in Fig. 3c is actually
conducted during the extraction stage. Values in source strings were not collected (see Appendix I.5).
System message:
52


--- Page 53 ---
You are a model that extracts formula information from a LATEX string.
Your task is to:
a. Classify the type of formula: series, continued fraction, or neither.
b. Extract its components and identify the variable.
This information will be used to compute the formula later, so it is critical that the extracted
value and components are accurate to ensure correctness.
You will be asked separately about each of the following steps:
Step 1. Classify the formula: Determine whether the LATEX string represents a series or a
continued fraction that can be rearranged to calculate the constant {constant}.
Step 2. Identify the formula type: Specify whether it is a series or a continued fraction.
Step 3. Extract the formula components:
- For series: Identify the term and the start value.
- For continued fractions: Identify the partial numerator and partial denominator.
Step 4. Identify the variable of the formula: Clearly state the variable used in the formula.
User message: step 1
Step 1:
Is this formula a series or a continued fraction that can be rearranged to calculate the constant
{constant}?
{latex_string}
Structured output: boolean.
User message: step 2
Step 2:
Determine the type of formula.
Is this formula a continued fraction or a series?
{latex_string}
Structured output: ‘series’ or ‘cf’ (for continued fraction).
User message: step 3
The prompt in step 3 depends on the classification result.
If formula_type == ‘cf’ (continued fraction)
(LATEX for one-shot example taken from [46] (arXiv 1907.00205).)
53


--- Page 54 ---
Step 3:
The formula is a continued fraction. Identify the following components:
1. The partial denominator (an) as a function of depth (n).
2. The partial numerator (bn) as a function of depth (n).
3. Any unknown variables or expressions (other than the depth n).
Write each component as a proper SymPy expression. For example:
The string
∀z ∈C :
1 +
1 · (2 · z −1)
4 +
2·(2·z−3)
7+
3·(2·z−5)
10+ 4·(2·z−7)
13+...
= 22·z+1
π
 2·z
z

has the following:
- an: ‘3*n + 1’
- bn: ‘n*(2*z - (2*n - 1))’
- unknowns: [‘z’]
The continued fraction is:
{latex_string}
Structured output: {‘an’: str, ‘bn’: str, ‘unknowns’: list[str]}
If formula_type == ‘series’
(LATEX for one-shot example adapted from arXiv 1806.03346. Note the adapted formula is incorrect
as the unknown was inserted at random.)
Step 3:
The formula is a series. Identify the following components:
1. The term as a SymPy expression.
2. The dummy variable.
3. The start value of the dummy variable.
4. Any unknown variables (other than the dummy variable).
For example:
The string
π · z = 22
7 −24
∞
X
n=2
(−1)n
(2n + 1 + z)(2n + 2 + z)(2n + 3)(2n + 4)(2n + 5)
has the following:
- Term: ‘(-1)**n / ((2*n + 1)*(2*n + 2)*(2*n + 3)*(2*n + 4)*(2*n + 5))’
- Dummy variable: ‘n’
- Start: ‘2’
- Unknowns: [‘z’]
Pay attention to special symbols like _symbol (e.g., \frac12)_n ), which often indicate
a SymPy RisingFactorial. Another symbol to look out for is H_, which often means a
SymPy harmonic.
The series is:
{latex_string}
Structured output: {‘term’: str, ‘dummy_var’: str, ‘start’: int, ‘unknowns’: list[str]}.
User message: step 4
(LATEX for one-shot example taken from arXiv 1806.03346)
54


--- Page 55 ---
Step 4:
Identify the variable used in the formula.
If the formula is a series, focus on the variable used in the outermost summation.
If the formula contains nested summations or other variables, ensure you extract only the
variable from the outermost summation and exclude all others.
For example:
The string
π = 22
7 −24
∞
X
n=2
(−1)n
(2n + 1)(2n + 2)(2n + 3)(2n + 4)(2n + 5)
has the outermost summation variable: ‘n’.
Extract the variable from the formula:
{latex_string}.
Structured output: str.
I.6.3
Code-correcting prompts
After extraction, each of the code components extracted in steps 3, 4 from the above prompts went
through an execution test. Faulty code was sent back to GPT-4o for correction to SymPy code that
runs properly. A total of only 16 code-correction iterations were needed during a run on 847 classified
formulas, a testament to the LLM’s ability to write executable code. We are confident that this stage
could be removed in future runs with minimal consequences to the size of the formula dataset. Since
the number of corrections is so low, the cost of leaving this stage in is minimal. In short, the correction
stage is largely insignificant when using GPT-4o to derive executable code from LATEX.
The following prompts were used in the loop for up to three iterations:
System message:
You are a helpful assistant tasked with extracting mathematical expressions from strings and
rewriting them in proper SymPy format.
Your output must be valid Python code that can be executed without errors.
Always focus on processing the original string provided and ensure the response contains
only the corrected SymPy expression, formatted as executable Python code.
User message:
(Includes the Python error message from a failed execution attempt - e.)
The last attempt was invalid SymPy code: {str(e)[:400]}.
Last attempt:
{string}
Task:
1. Extract the expression from the original string below.
2. Rewrite it in proper SymPy format as valid, executable Python code.
3. Only return the corrected SymPy expression, formatted as valid Python code.
Original string:
{original_string}
Process the original string and provide the corrected SymPy expression.
Structured output: str.
55


--- Page 56 ---
J
Tables of full results
This section contains the full list of order-2 canonical forms (PCFs) derived by our system, grouped
in equivalence classes discovered by running the matching algorithm (per Appendix C.1). Formula
sources are shown in Table 15. Tables 16 and 17 list the formulas that have been unified by the π
CMF and those that have not yet been unified, respectively. We believe wider scans of the CMF
(Appendix C.5), with deeper, more complicated trajectories, will unify additional formulas from the
latter. Enlarging the π-CMF to higher dimensions and rank will also likely increase the unification
percentage.
We invite the reader to explore the formulas and algorithms leading to these tables, available in our
project repository https://github.com/RamanujanMachine/euler2ai. Some results are also discussed in
the online algorithm demonstration [4].
The supplementary material accompanying this paper contains two Python Pandas DataFrames as
pickle files:
• pcfs.pkl: The full dataset of order-2 canonical forms (PCFs) harvested, along with their
sources.
Columns:
– ab: tuple containing an, bn of the PCF, both as strings.
– a: just an.
– b: just bn.
– limit: string of the symbolic limit of the PCF in terms of π.
– delta: the empirical irrationality measure of the formula, Eq. (5), as a float.
– convergence_rate: the empirical convergence rate of the formula, Eq. (4), as a float.
– sources: list of dictionaries, each describing a harvested formula that led to the PCF
when canonicalized.
Keys:
* type: ‘cf’ or ‘series’.
* formula: as a string.
* formula_limit: in terms of π, as a string.
* id: the arXiv id of the source paper, string.
* file: TEX file in which the formula was located, string.
* line: exact line in the above TEX file, int.
* equation: the source equation string.
• cmf_pcfs.pkl: A dataset of order-2 canonical forms (PCFs) sampled from the π-CMF.
Columns:
same as pcfs.pkl except for
– sources: list of 2-tuples where each tuple contains a trajectory and a starting point in
the CMF, both lists. Generating a trajectory matrix using these (trajectory, starting point)
pairs and converting to companion form yields the PCF (Appendix C.5). Trajectories
are lists of ints. Starting points are lists of strings for easy storage of rational numbers.
56


--- Page 57 ---
Table 15: Formula sources. Summary of papers from the literature containing π formulas, showcas-
ing the success rate of UMAPS (colored indices). Canonical forms are shown in gold if connected to
at least one other canonical form by UMAPS and in cyan if unified by the CMF; 98% of papers with
π formulas had at least one formula connected via canonicalization and UMAPS (gold or cyan) and
50% included a formula unified by the CMF (cyan). Black indices represent formulas that remain
unconnected to to other formulas via UMAPS. See Table 4 for statistics in terms of formula counts.
Formula indices are consistent with Tables 16,17. Canonical forms 150-153 are not included in this
table as they are order-3 recurrences (see Appendix B.6).
* Tabulated formulas from the data provided in this paper were added manually.
arXiv source
Canonical forms
arXiv source
Canonical forms
arXiv source
Canonical forms
1907.00205*
1, 2, 3, 13, 20, 21, 22,
28, 29, 30, 31, 32, 48
2305.14995
44
1807.07394
96
2308.11829
4
2307.05607
44
1906.07384
96
2307.03086
5, 6, 7, 87, 96, 107,
137
2307.08063
44
1908.05123
96, 126
1407.8465
7
2312.17402
44
2305.00498
96, 126, 137
2204.08275
8, 9, 10, 11, 38, 39,
40, 41, 86, 87
2409.06658
44
2310.04642
96
2405.02776
12, 130, 144
math/0006141
44
1008.3171
106, 113
2412.12361*
14, 15, 17, 19, 23, 24,
25, 26, 27, 33, 34, 35,
36, 37
math/0206179
44
2001.08104
108, 137, 140
0707.2124
16
math/0402462
44
1209.2348
113
1507.01703
16, 18, 118
2305.14367
45
1302.2898
113
2112.00622
16
2105.11771
49
1910.04328
113
2211.11484
16, 96, 126
2206.08284
49
2103.07872
113, 115, 116
2310.03699
42
1601.03180
51
2203.02631
113
1806.03346
43, 44, 45, 46, 47, 48,
50, 51, 52, 59, 60, 61,
62, 63, 64, 65, 66, 67,
68, 69, 70, 71, 72
1806.08411
51
2205.08617
113
0707.2122
44
1209.5739
53
2208.07696
113
0707.2500
44
2411.00280
55
2305.04935
113
0708.2564
44
1504.01028
73, 126
2108.12796
114, 115
0806.0150
44
1804.08210
73, 74, 78, 79
0911.2415
117
0807.0872
44, 108, 113, 118,
120, 126
1805.06568
73, 74, 78, 79, 81,
148
1103.3893
117
1206.3431
44
2005.04672
73
1110.5308
117
1209.3657
44
2111.10998
73, 75
1804.00394
117
1301.2584
44
2204.04535
73, 75, 76
0708.3307
126
1302.0471
44
2403.04944
77
1210.0269
126
1303.1856
44
1708.04269
80
1302.5984
126, 140, 146
1310.5610
44
0712.1332
82
1303.6228
126
1406.1168
44
0911.5665
82, 87
1510.02575
126
1501.05457
44, 53
1203.1255
82, 96
1808.03213
126
1511.08568
44
1302.0548
82, 96, 126
1901.07962
126
1602.00336
44
1610.04839
82, 107
1909.10294
126
1704.02498
44
1611.02217
82, 96, 126
1910.07551
126
1801.09181
44
1911.05456
83, 84, 90, 91, 97, 98,
100, 103, 109, 111,
127, 128, 136, 138,
141, 142
1912.00765
126
1802.01473
44
2110.03651
85, 89, 92, 93, 94, 95,
96, 98, 101, 102, 104,
105, 110, 112, 122,
123, 124, 126, 127,
134, 135, 139, 143
2003.02572
126
1802.01506
44, 126
1101.0600
87
2101.09753
126
1809.00998
44
2210.07238
87, 96, 137
2109.09877
126
1812.06643
44
math/0503507
87
2203.16047
126, 127, 128
1906.09629
44, 57, 106, 113, 121
2212.09965
88, 99, 119, 125, 133
2210.01331
126
1907.04089
44
0805.2788
96, 126, 137
2301.12932
126
1911.12551
44
1103.6022
96
2303.05402
126
1912.03214
44, 51, 147
1104.0392
96, 126, 137
2310.15207
126
1912.03527
44
1104.1994
96
1808.04717
128
2009.10774
44
1104.3856
96, 126, 140
1501.06413
129
2104.12412
44, 96
1410.5514
96, 113
2305.00626
131, 132, 145
2105.05809
44
1504.01976
96
0704.2438
137
2106.04517
44
1512.04608
96, 108, 126
1004.4623
137
2110.07457
44
1604.00193
96
1802.04616
137
2203.09465
44, 53, 54, 56, 149
1604.01106
96, 126
0909.2387
149
2206.07174
44, 51, 58
1609.07276
96
math/0502582
149
2212.13687
44
1804.02695
96, 140
57


--- Page 58 ---
Table 16: Formulas unified by the π Conservative Matrix Field (CMF) as shown in Fig. 6. Clusters
of formulas harvested from the literature are given in terms of their corresponding trajectory in the
CMF. Dashes indicate a formula’s canonical form (CF) is the same as the formula collected. Each
canonical form has a numbered row and some are followed by additional source formulas.
Cluster
Formula
Value
Canonical form (CF)
CF value
Convergence rate
(1, 1, 2)
δ = −0.21
1
PCF(2n + 1,n2)
4
π
-
-
1.76
2
PCF(2n + 3,n2 + 2n)
4
−2+π
PCF(2n + 3,n2 + 2n)
4
−2+π
1.76
3
PCF(2n + 5,n2 + 4n)
8
−8+3π
PCF(2n + 5,n2 + 4n)
8
−8+3π
1.76
4
PCF(−48n3 −108n2 −70n −
12,−64n6 −96n5 + 12n4 +
52n3 + 15n2)
10
−4+π
PCF(−48n3 −108n2 −
70n −12,−64n6 −96n5 +
12n4 + 52n3 + 15n2)
10
−4+π
3.53
(3, 1, 1)
δ = −0.45
5
P∞
k=1
(−4)k(280k−51)(
2k
k )
k(
3k
k )(
6k
3k)
−6π −10
PCF(29120n3 +
110616n2 + 132106n +
49845,33868800n6 +
173940480n5 +
322863792n4 +
252606312n3 +
62976828n2 −9173682n −
2336310)
229050+137430π
154−45π
3.29
6
P∞
k=1
(−4)k(952k−201)(
2k
k )
(
3k
k )(
6k
3k)
−15π −42
PCF(99008n3 +
369416n2 + 427970n +
153045,391523328n6 +
2379573504n5 +
5231138352n4 +
4800421464n3 +
1334845140n2 −
258125598n −61614540)
12874680+4598100π
872−225π
3.29
7
P∞
k=1
(−4)k(7k−1)(
2k
k )
k(2k−1)(
3k
k )(
6k
3k)
−π
4
PCF(728n3 + 2822n2 +
3469n + 1360,21168n6 +
89208n5 + 130380n4 +
78570n3 + 15162n2 −
1458n −390)
130π
16−5π
3.30
(2, 1, 1)
δ = −0.48
8
P∞
k=1
(−2)kk(126k+29)
(
4k
2k)
−65
3 −2π
PCF(1764n4 + 8596n3 +
14767n2 + 10143n +
2053,508032n8 +
4552128n7 + 16355000n6 +
29955532n5 +
29379250n4 +
14855861n3 +
3459708n2 + 293364n)
3372π+36530
15−π
2.07
9
P∞
k=1
(−2)k−1(6k−1)
k(2k−1)(
4k
2k)
π
4
PCF(84n3+328n2+411n+
164,1152n6 + 4800n5 +
6968n4 + 4220n3 +
838n2 −95n −33)
33π
10−3π
2.08
10
P∞
k=0
(−2)k(30k−7)
(
4k
2k)
−32
3 −π
2
PCF(420n3 + 232n2 −
121n −44,28800n6 +
960n5−57352n4−8996n3+
27766n2 + 4697n −2553)
−1472−69π
3π+22
2.08
11
P∞
k=1
(−2)k(18k+1)
(2k−1)(
4k
2k)
−3π
2 −1
PCF(252n3 + 1004n2 +
1321n + 591,10368n6 +
58176n5 + 116024n4 +
100084n3 + 38458n2 +
5843n + 222)
444+666π
32−9π
2.08
12
P∞
j=0
64−j(3j+2)(112j2+144j+41)( 1
4)(j)( 1
2)(j)( 3
4)(j)j!
( 9
8)(j)( 11
8 )(j)( 13
8 )(j)( 15
8 )(j)
105π
4
PCF(1397760n7 +
11104768n6 +
36657792n5 +
65007040n4 +
66685140n3 +
39437842n2 +12401823n+
1591920,−29595009024n14−
248739004416n13 −
868936056832n12 −
1606677430272n11 −
1605350604800n10 −
651457732608n9 +
282238639104n8 +
446685049344n7 +
175738683712n6 −
1178920416n5 −
20395524172n4 −
5128349922n3 −
106481538n2 +
98454690n + 8419950)
935550π
−328+105π
4.16
58


--- Page 59 ---
Cluster
Formula
Value
Canonical form (CF)
CF value
Convergence rate
(1, 0, 0)
δ = −0.65
13
PCF(3n + 1,−2n2 + n)
2
π
-
-
0.69
14
PCF(3n + 2,−2n2 −n + 1)
π+4
2+π
-
-
0.69
15
PCF(3n + 4,−2n2 −3n + 2)
12+4π
π+4
-
-
0.69
16
P∞
i=1
2i
i(
2i
i )
π
2
PCF(3n+4,−2n2 −3n−1)
π
−2+π
0.69
P∞
k=1
2k
k(
2k
k )
π
2
P∞
k=0
k!
(2k+1)!!
π
2
P∞
j=0
2j+1
(2j+1)(
2j
j )
π
17
PCF(3n + 5,−2n2 −5n + 3)
84+27π
6π+20
-
-
0.69
18
P∞
i=1
2i
(2i+1)(
2i
i )
−1 + π
2
PCF(3n+7,−2n2 −7n−6)
12−6π
8−3π
0.69
19
PCF(3n2 + 9n + 5,−2n4 −9n3 −
9n2 + n + 3)
102π+357
85+34π
-
-
0.69
20
PCF(3n,−2n2 + 3n)
2
2+π
PCF(3n,−2n2 + 3n)
2
2+π
0.70
21
PCF(3n + 3,−2n2 + n)
4
−8+3π
-
-
0.70
22
PCF(3n + 3,−2n2 −n)
−
2
−4+π
-
-
0.70
23
PCF(3n + 4,−2n2 + n)
12
−44+15π
-
-
0.70
24
PCF(3n + 4,−2n2 −n)
−
2
−10+3π
-
-
0.70
25
PCF(3n + 5,−2n2 + n)
48
−320+105π
-
-
0.70
26
PCF(3n + 5,−2n2 −n)
−
4
−48+15π
-
-
0.70
27
PCF(3n + 5,−2n2 −3n)
6
−8+3π
-
-
0.70
28
PCF(3n + 3,−2n2 −n + 1)
1 + π
2
-
-
0.70
29
PCF(3n + 4,−2n2 −n + 1)
−
π
−4+π
-
-
0.70
30
PCF(3n + 5,−2n2 −n + 1)
4−3π
−20+6π
-
-
0.70
31
PCF(3n + 5,−2n2 −3n + 2)
2π+8
π
-
-
0.70
32
PCF(3n + 6,−2n2 −3n + 2)
8
−8+3π
-
-
0.70
33
PCF(3n + 6,−2n2 −5n + 3)
15π+48
8+3π
-
-
0.70
34
PCF(3n + 7,−2n2 −3n + 2)
32−6π
−64+21π
-
-
0.70
35
PCF(3n + 7,−2n2 −5n + 3)
3 + 9π
8
-
-
0.70
36
PCF(3n + 8,−2n2 −5n + 3)
−
9π
−32+9π
-
-
0.70
37
PCF(3n + 9,−2n2 −5n + 3)
32−15π
−96+30π
-
-
0.70
38
P∞
k=0
4kk
(
4k
2k)
2
3 + π
4
PCF(20n3 + 86n2 + 123n +
59,−64n6 −416n5 −
1004n4 −1090n3 −
504n2 −72n)
64
π + 24
1.38
39
P∞
k=1
4k(12k2+1)
(
4k
2k)
50
3 + 11π
2
PCF(240n4 + 1320n3 +
2792n2 + 2726n +
1043,−9216n8−78336n7−
265920n6 −456096n5 −
413728n4 −195792n3 −
53804n2 −13194n −1764)
19600+6468π
16+11π
1.38
40
P∞
k=1
4k(3k−1)
k(2k−1)(
4k
2k)
π
2
PCF(60n3 + 214n2 +
237n + 80,−576n6 −
2208n5 −2860n4 −
1330n3+46n2+178n+30)
30π
−8+3π
1.39
41
P∞
k=1
4k(12k−5)
(2k−1)(
4k
2k)
2 + 3π
2
PCF(240n3 + 884n2 +
994n + 321,−9216n6 −
43008n5 −65536n4 −
31904n3 + 4900n2 +
6914n + 1140)
912+684π
−16+9π
1.39
(-1, 3, 3)
δ = −0.91
42
P∞
k=1
16k(22k2−17k+3)(
4k
2k)
k(4k−3)(4k−1)(
3k
k )(
6k
3k)
2π
PCF(3784n4 + 15292n3 +
21230n2 + 11981n +
2304,−3345408n8 −
13229568n7 −
16699200n6 −
4912608n5 + 4514544n4 +
2792280n3 + 27384n2 −
173304n −20520)
6840π
−32+15π
0.52
59


--- Page 60 ---
Cluster
Formula
Value
Canonical form (CF)
CF value
Convergence rate
(1, 1, 1)
δ = −1.00
43
PCF(4,4n2 −1)
2+π
−2+π
-
-
0.00
44
P∞
k=0
(−1)k
2k+1
π
4
PCF(2,4n2 + 4n + 1)
π
4−π
0.00
P∞
l=0
(−1)l
2l+1
π
4
P∞
m=0
(−1)m
2m+1
π
4
P∞
n=0
(−1)n
2n+1
π
4
P∞
n=1
(−1)n
2n−1
−π
4
P∞
j=1
(−1)j−1
2j−1
π
4
P∞
k=1
(−1)k+1
2k−1
π
4
P∞
n=1
(−1)n+1
2n−1
π
4
P∞
n=1
(−1)n−1
2n−1
π
4
P∞
ν=0
(−1)ν
2ν+1
π
4
P∞
p=0
(−1)p
p+ 1
2
π
2
45
P∞
k=1
(−1)k
(2k−1)(2k+1)
1
2 −π
4
PCF(4,4n2 + 8n + 3)
−6+3π
10−3π
0.00
P∞
n=1
(−1)n−1
(2n−1)(2n+1)
−1
2 + π
4
46
PCF(4,4n2 −8n + 3)
3π+10
2+π
-
-
0.00
47
PCF(6,4n2 + 4n −3)
3π
−8+3π
-
-
0.00
48
PCF(6,4n2 −4n + 1)
3 + π
-
-
0.00
P∞
n=1
(−1)n+1
n(n+1)(2n+1)
π −3
49
P∞
n=1
(−1)n+1
2n+1
1 −π
4
PCF(2,4n2 + 12n + 9)
−36+9π
8−3π
0.00
P∞
ℓ=1
(−1)ℓ
2ℓ+1
−1 + π
4
50
P∞
n=1
(−1)n−1
(2n−1)(2n+1)(2n+3)
−1
3 + π
8
PCF(6,4n2 + 12n + 5)
−40+15π
48−15π
0.00
51
P∞
k=2
(−1)k+1
k(k−1)(2k−1)
3 −π
PCF(6,4n2 + 12n + 9)
−27+9π
19−6π
0.00
P∞
k=1
(−1)k+1
2k(2k+1)(2k+2)
−3
4 + π
4
P∞
n=1
(−1)n−1
2n(2n+1)(2n+2)
−3
4 + π
4
P∞
n=1 (−1)n+1 
−
4
2n+1 +
1
n+1 + 1
n

−3 + π
P∞
n=1
2(−1)n(
1
n+1 + 1
n)
(2n+1)2
6 −2π
52
P∞
n=1
(−1)n−1
(2n−1)(2n+1)(2n+3)(2n+5)
−11
90 + π
24
PCF(8,4n2 + 16n + 7)
−308+105π
332−105π
0.00
53
P∞
n=1
1
(4n−3)(4n−1)
π
8
PCF(32n2 + 64n +
38,−256n4 −512n3 −
352n2 −96n −9)
9π
−8+3π
0.00
P∞
k=1

−
1
4k−1 +
1
4k−3

π
4
P∞
n=1

−
1
4n−1 +
1
4n−3

π
4
54
P∞
n=1
1
(4n−3)(4n−1)(4n+1)
−1
8 + π
16
PCF(32n2 + 80n +
66,−256n4 −768n3 −
800n2 −336n −45)
90−45π
46−15π
0.00
55
P∞
n=1
1
16n2−1
1
2 −π
8
PCF(32n2 + 96n +
78,−256n4 −1024n3 −
1504n2 −960n −225)
900−225π
52−15π
0.00
56
P∞
n=1
1
(2n−1)(2n+1)(4n−1)(4n+1)
−1
2 + π
6
PCF(32n2 + 96n +
110,−256n4 −1024n3 −
1504n2 −960n −225)
225−75π
47−15π
0.00
57
P∞
k=1

−
1
4k+3 +
1
4k+1

−2
3 + π
4
PCF(32n2 + 128n +
134,−256n4 −1536n3 −
3424n2 −3360n −1225)
9800−3675π
304−105π
0.00
58
P∞
n=1
3
n(n+1)(4n+1)(4n+3)
19
3 −2π
PCF(32n2 + 128n +
166,−256n4 −1536n3 −
3424n2 −3360n −1225)
23275−7350π
1321−420π
0.00
59
PCF(8,4n2 −1)
π+4
4−π
PCF(8,4n2 −1)
π+4
4−π
0.01
60
PCF(8,4n2 + 8n −5)
20−15π
44−15π
-
-
0.01
61
PCF(10,4n2 + 4n −3)
6
10−3π
-
-
0.01
62
PCF(10,4n2 −4n + 1)
5 + 16
π
-
-
0.01
63
P∞
n=1
(−1)n−1
n(2n+1)(2n+2)(2n+3)(4n−2)
5
36 −π
24
PCF(10,4n2 + 12n + 5)
−50+15π
94−30π
0.01
64
PCF(10,4n2 + 12n −7)
224−105π
320−105π
-
-
0.01
65
P∞
n=1
(−1)n−1
(2n−1)(2n+1)(2n+3)(2n+5)(2n+7)
−2
63 + π
96
PCF(10,4n2 + 20n + 9)
−960+315π
992−315π
0.01
66
P∞
n=2
(−1)n
(2n+1)(2n+2)(2n+3)(2n+4)(2n+5)
11
84 −π
24
PCF(10,4n2 + 28n + 45)
−14850+4725π
3958−1260π
0.01
67
P∞
n=1
(−1)n−1
(2n−1)2(2n+1)2(2n+3)2(2n+5)2
−
7
4050 +
π
1728
PCF(32n + 80,16n4 +
128n3+312n2+224n+49)
−10976+3675π
11552−3675π
0.01
68
P∞
n=1
(−1)n−1
(2n−1)2(2n+1)2(2n+3)2(2n+5)2(2n+7)2(2n+9)2
41
44651250 −
π
3456000
PCF(48n + 168,16n4 +
192n3+664n2+528n+121)
−2540032+800415π
2514432−800415π
0.01
69
PCF(24,4n2 −1)
75π+256
256−75π
-
-
0.02
70
P∞
n=1
(−1)n−1
(2n−1)2(2n+1)2(2n+3)2(2n+5)2(2n+7)2(2n+9)2(2n+11)2(2n+13)2
−
14789
134221791453750 +
π
28449792000
PCF(64n + 288,16n4 +
256n3 + 1144n2 + 960n +
225)
−181727232+57972915π
182128640−57972915π
0.02
*
60


--- Page 61 ---
Cluster
Formula
Value
Canonical form (CF)
CF value
Convergence rate
(0, 0, 1)
δ = −1.00
71
PCF(2,n2)
2
4−π
-
-
0.00
72
PCF(1,n(n + 1))
2
π−2
-
-
0.00
73
P∞
n=0
4−2n(
2n
n )
2
n+1
4
π
PCF(8n2+16n+9,−16n4−
32n3 −20n2 −4n)
4
4−π
0.00
P∞
n=0
2−4n−3(
2n
n )(
2n+2
n+1 )
2n+1
1
π
P∞
n=0

( 1
2)(n)
2
n!(n+1)!
4
π
P∞
k=0

( 1
2)(k)
2
(k+1)k!2
4
π
P∞
n=0
4

( 1
2)(n)
2
2(n)n!
16
π
P∞
n=0

( 1
2)(n)
2
(n+1)n!2
4
π
74
P∞
n=0

( 1
2)(n)
2
n!(n+2)!
16
9π
PCF(8n2 + 20n +
13,−16n4 −48n3 −36n2 −
8n)
32
32−9π
0.00
P∞
n=0

( 1
2)(n)
2
(n+1)(n+2)n!2
16
9π
75
P∞
n=0
4−2n(
2n
n )
2
(n+1)2
−4 + 16
π
PCF(8n2 + 20n +
17,−16n4 −48n3 −52n2 −
24n −4)
−16+4π
−16+5π
0.00
P∞
n=0
2−4n−4(
2n
n )(
2n+2
n+1 )
(n+1)(2n+1)
4−π
2π
76
P∞
n=1
24n
n2(2n+1)(
2n
n )
2
−4 + 2π
PCF(8n2 + 24n +
19,−16n4 −64n3 −92n2 −
56n −12)
24−12π
8−3π
0.00
77
P∞
i=1
(2i−1)!!2
(i+1)(2i−1)(2i)!!2
−8
3 +π
π
PCF(8n2 + 28n +
27,−16n4 −80n3 −
140n2 −100n −24)
192−72π
64−21π
0.00
78
P∞
n=1

( 1
2)(n)
2
(n+1)!2
−5 + 16
π
PCF(8n2 + 36n +
45,−16n4 −112n3 −
292n2 −336n −144)
−2304+720π
−256+81π
0.00
79
P∞
n=1

( 1
2)(n)
2
(n+1)!(n+2)!
256−81π
18π
PCF(8n2 + 40n +
57,−16n4 −128n3 −
372n2 −468n −216)
−18432+5832π
−2048+651π
0.00
P∞
n=1

( 1
2)(n)
2
(n+2)(n+1)!2
256−81π
18π
80
P∞
n=1
16n
(2n+1)2(2n+3)2(
2n
n )
2
−28
9 + π
PCF(8n2 + 44n +
65,−16n4 −144n3 −
484n2 −720n −400)
11200−3600π
704−225π
0.00
81
P∞
n=1

( 1
2)(n)
2
(n+2)!2
2048−651π
108π
PCF(8n2 + 44n +
73,−16n4 −144n3 −
468n2 −648n −324)
−73728+23436π
−8192+2607π
0.00
61


--- Page 62 ---
Table 17: Additional formulas for π that were automatically harvested from arXiv, clustered,
and proven equivalent within the clusters, but not unified. We expect these formulas to be
unified in the future, by enlarging the π-CMF (Eq. (25)) to new dimensions, i.e. adding matrices and
directions to walk in, and by improving the matching algorithm. This table complements Table 16;
the formulas are mutually exclusive and were collected using the same harvesting pipeline. These
formulas were then connected among themselves as described in Appendix C.1, resulting in clusters.
Cluster
Formula
Value
Canonical form (CF)
CF value
Convergence rate
δ = −0.29
82
P∞
k=0
(−1)k882−2k(21460k+1123)( 1
4)(k)( 1
2)(k)( 3
4)(k)
k!3
3528
π
PCF(534215282560n4 +
1630601631968n3 +
1686512782328n2 +
618081838666n +
27955409115,366856790423961600n8+
588680355780034560n7 −
56045383774765056n6 −
487988770034755584n5 −
247923828204062976n4 −
34298642100691584n3)
239018472
−3528+1123π
13.56
P∞
n=0
(−1)n882−2n(21460n+1123)( 1
4)(n)( 1
2)(n)( 3
4)(n)
n!3
3528
π
P∞
k=0
(−1)k882−2k−1(21460k+1123)( 1
4)(k)( 1
2)(k)( 3
4)(k)
k!3
4
π
P∞
n=0
(−
1
777924)
n(21460n+1123)( 1
4)(n)( 1
2)(n)( 3
4)(n)
n!3
3528
π
P∞
n=0
(−1)n882−2n−1(21460n+1123)( 1
4)(n)( 1
2)(n)( 3
4)(n)
n!3
4
π
83
P∞
k=0
(−199148544)−k(413512k2−50826k−3877)(
2k
k )
2(
4k
2k)
(2k−1)(4k−1)
−12180
π
PCF(10293775858432n5 +
29616108563136n4 +
26989135212112n3 +
6208537419732n2 −
1554777635156n −
96512721945,136211370064688185344n10−
101589980989452189696n9−
264690152463365701632n8+
176607156266987249664n7+
130723278949247781888n6−
76446780832924992000n5−
7169513755287663360n4 +
4112854339342396032n3)
4370293620
−12180+3877π
13.56
84
P∞
k=0
(−199148544)−k(1424799848k2+1533506502k+108685699)(
2k
k )
2(
4k
2k)
(k+1)(2k−1)(4k−1)
341446000
π
PCF(35468306308982528n5+
180047738533689024n4 +
332745102731042192n3 +
272631301503072468n2 +
89876772716256332n +
5411146610376015,1617129676787301327212642304n10+
4289585526894573435060486144n9−
283366210981584591028224000n8−
5781213621368637378454757376n7−
1039278977594267522852017152n6+
1952285872621730578835212800n5+
65692626394504296555019008n4−
100482263421913916885155968n3−
1599880200791331634560n2)
1047212167162854000
−341446000+108685699π
13.56
85
P∞
k=0 (−199148544)−k k3  643835623600k2 −1361740501968k + 711617288021
  2k
k
2 4k
2k

11907
5π
1948560328369940813539200
−32934190464+10479317245π
13.56
PCF(16027345274169049600n5+
46238118052856925952n4+
42393702411206957504n3+
10025851657990883552n2−
2313657716521897662n −
156579723130929021,330207651328802238267628584960000n10+
1409957788010219812691718399590400n9+
1203874285923329826320292682727424n8−
2329106526247884032940943409971200n7−
4015077152785672561965154974486528n6−
223367340714308589746355369486336n5+
2387849672288336744650632714720000n4+
1048094645820050271615304567478400n3)
δ = −0.29
86
P∞
k=1
2−k(5k−2)
k(2k−1)(
3k
k )
π
6
PCF(145n3 + 517n2 +
572n + 188,−1350n6 −
4995n5−6186n4−2565n3+
420n2 + 540n + 96)
8π
−3+π
2.60
87
P∞
k=0
2−k(25k−3)
(
3k
k )
π
2
PCF(725n3 + 713n2 +
160n + 4,−33750n6 −
8775n5 + 63564n4 +
15957n3 −30972n2 −
4644n + 3696)
22π
π+6
2.60
P∞
n=0
2−n(50n−6)
(
3n
n )
π
62


--- Page 63 ---
Cluster
Formula
Value
Canonical form (CF)
CF value
Convergence rate
δ = −0.34
88
P∞
n=1
(2n+1)(3n+1)(14n+11)(
2n
n )
(2n−1)(4n+1)2(4n+3)(
4n
2n)
2
5
3 −π
2
PCF(21840n6 +264512n5 +
1320976n4 + 3480988n3 +
5103299n2 + 3944955n +
1255590,−7225344n12 −
128163840n11 −
1015908352n10 −
4751034368n9 −
14575174464n8 −
30842090208n7 −
46062845088n6 −
48807290832n5 −
36316590692n4 −
18450538102n3 −
6054381960n2 −
1147592250n −94594500)
191100−57330π
22−7π
4.16
δ = −0.49
89
P∞
k=0 (−82944)−k k3  2428400k2 −5044368k + 2584321
  2k
k
2 4k
2k

243
5π
PCF(25099942400n5 +
73089143552n4 +
68107981504n3 +
16786867552n2 −
3892088262n −
560080521,1956525061570560000n10+
8502121389529497600n9 +
7771802427851341824n8−
13080888260893900800n7−
24151221026510819328n6−
2397288296314791936n5 +
13672048552352582400n4+
6215310504603446400n3)
64935193276800
−279936+52745π
5.77
90
P∞
k=0
(−82944)−k(1144k2−102k−19)(
2k
k )
2(
4k
2k)
(2k−1)(4k−1)
−60
π
PCF(11824384n5 +
34473792n4 +
32217904n3 +
8117004n2 −1648652n −
198015,434207195136n10−
294532153344n9 −
867809230848n8 +
536815558656n7 +
429636897792n6 −
240626557440n5 −
23568433920n4 +
13014131328n3)
61380
−60+19π
5.78
91
P∞
k=0
(−82944)−k(3224k2+4026k+637)(
2k
k )
2(
4k
2k)
(k+1)(2k−1)(4k−1)
2000
π
PCF(33323264n5 +
175163712n4 +
340624496n3 +
302122284n2 +
116510516n +
13200945,3448538136576n10+
10337057243136n9 +
2209893580800n8 −
11941876998144n7 −
3960532620288n6 +
3945642969600n5 +
453938141952n4 −
202478424192n3 −
13492448640n2)
15774000
−2000+637π
5.78
92
P∞
k=0 (−82944)−k  2475740800k2 + 4950772932k + 2475031103
   2k
k+1
2 4k
2k

−2238840
π
PCF(25589256908800n6 +
307024146260352n5 +
1483653045985888n4 +
3682571629531512n3 +
4933895619830194n2 +
3372826099775973n +
919254248208450,2033552151394532720640000n12+
37619550613226372412211200n11+
308445231345910090393780224n10+
1476028855603509052602580992n9+
4565376629008757961859399680n8+
9536441599068207233102567424n7+
13623723826190777310302174976n6+
13142549025479964764182704768n5+
8192764123025109436770174720n4+
2979947458777007024574045696n3+
480243127503056112414213120n2)
9653638716124064686080
−2063314944+660102989π
5.78
63


--- Page 64 ---
Cluster
Formula
Value
Canonical form (CF)
CF value
Convergence rate
δ = −0.50
93
P∞
k=0 4096−kk3  198k2 −425k + 210
  2k
k
3
−
1
21π
PCF(102960n5 +
299344n4 + 276000n3 +
61356n2 −22843n −
4600,−160579584n10 −
675569664n9 −
526950400n8 +
1278275584n7 +
2128862208n6 +
232229376n5 −
1054909440n4 −
441262080n3)
2101248
512−357π
4.15
P∞
k=0 4096−kk2  5544k3 −11900k2 + 5880k
  2k
k
3
−4
3π
94
P∞
k=0 4096−kk2  504k2 −314k −11
  2k
k
3
4
3π
PCF(262080n5 +
1419280n4 + 2902704n3 +
2814416n2 + 1289208n +
220475,−1040449536n10 −
8587837440n9 −
28095496192n8 −
44392325120n7 −
29396893696n6 +
5069131776n5 +
17276599296n4 +
6864182784n3 +
209392128n2)
76142592
2048−537π
4.15
95
P∞
k=0 4096−k  k2 + 1
  126504k2 −921334k −109205
  2k
k
3
−1063412
3π
PCF(65782080n7 −
279217360n6 −
1232128016n5 −
1846926048n4 −
1980776344n3 −
1616603667n2 −
653455030n −
57721030,−65549361217536n14+
856473516638208n13 −
1849611118133248n12 −
5920093389561856n11 −
1760186613374976n10 +
6901075810324480n9 −
5014055826994176n8 −
23245912331160064n7 −
5991956674019328n6 +
13900726975086592n5 +
9537554582155264n4 +
1737844908349440n3)
1922723334840
−1063412+327615π
4.15
96
P∞
k=0 4096−k (42k + 5)
 2k
k
3
16
π
PCF(21840n4 + 67952n3 +
73008n2 + 29508n +
2607,−7225344n8 −
12558336n7 −876544n6 +
8491008n5 + 5127168n4 +
890368n3)
752
16−5π
4.16
P∞
n=0 2−12n (42n + 5)
 2n
n
3
16
π
P∞
n=0 2−12n−4 (42n + 5)
 2n
n
3
1
π
P∞
n=0 4096−n  n + 5
42
  2n
n
3
8
21π
P∞
m=0
4096−m(42m+5)(2m)!3
m!6
16
π
P∞
n=0
64−2n(42n+5)(2n)!3
n!6
16
π
P∞
k=0
64−k(42k+5)

( 1
2)
(k)3
k!3
16
π
P∞
n=0
64−n(42n+5)

( 1
2)
(n)3
n!3
16
π
P∞
n=0
2−6n(42n+5)

( 1
2)
(n)3
n!3
16
π
P∞
n=0
2−6n(n+ 5
42)

( 1
2)
(n)3
n!3
8
21π
P∞
k=0
64−k( 21k
8 + 5
16)

( 1
2)
(k)3
k!3
1
π
97
P∞
k=0
4096−k(28k2−4k−1)(
2k
k )
3
(2k−1)2
−3
π
PCF(14560n5 + 41264n4 +
36272n3 + 6488n2 −
3578n −
489,−3211264n10 +
2523136n9 + 6930432n8 −
4874240n7 −3977216n6 +
2521088n5 + 611328n4 −
365056n3)
69
3−π
4.16
64


--- Page 65 ---
Cluster
Formula
Value
Canonical form (CF)
CF value
Convergence rate
δ = −0.50
(cont.)
98
P∞
k=0
4096−k(42k2−3k−1)(
2k
k )
3
(2k−1)3
27
8π
PCF(21840n5 + 63120n4 +
58976n3 + 15348n2 −
2925n −
550,−7225344n10 +
11870208n9 +
7790592n8 −21516288n7 +
5676032n6 + 7635456n5 −
5004288n4 + 856064n3)
1026
−27+8π
4.16
99
P∞
n=0
4096−n(2n+1)(6n+1)(14n−3)(
2n
n )
3
(2n−1)2
−8
π
PCF(43680n5 +
128624n4 + 121776n3 +
31176n2 −6934n −
1305,−28901376n10 −
11698176n9 +
97304576n8 +
12771328n7 −
101953536n6 +
12584960n5 +
32441344n4 −10053120n3)
1848
8−3π
4.16
100
P∞
k=0
4096−k(56k2+118k+61)(
2k
k )
3
(k+1)2
192
π
PCF(29120n5 +
206288n4 + 567664n3 +
758432n2 + 493160n +
125163,−12845056n10 −
99090432n9 −
309805056n8 −
509747200n7 −
479764480n6 −
260722688n5 −
76624896n4 −9241088n3 +
358400n2 + 120320n)
45120
192−61π
4.16
101
P∞
k=0
4096−k(42k2+81k+38)(
2k
k )
3
(k+1)3
−512 + 1728
π
PCF(21840n5 +
172320n4 + 529856n3 +
789396n2 + 566379n +
155809,−7225344n10 −
60383232n9 −
210518016n8 −
398905344n7 −
447026176n6 −
299017728n5 −
111091200n4 −
16026624n3 + 2519040n2 +
1073664n + 82432)
−139104+41216π
−864+275π
4.16
102
P∞
k=0 4096−kk
 210k2 −5k + 1
  2k
k
3
4
3π
PCF(109200n5 +
764320n4 + 2076080n3 +
2737956n2 + 1761115n +
444325,−180633600n10 −
1888051200n9 −
8364728320n8 −
20346408960n7 −
29314630656n6 −
24973633024n5 −
11606320128n4 −
2246787072n3 −
55296n2 −11487744n)
22975488
1024−309π
4.16
103
P∞
k=0
4096−k(420k2+992k+551)(
2k
k )
3
(k+1)2(2k−1)
−1728
π
PCF(218400n5 +
1599440n4 + 4564144n3 +
6337720n2 + 4282754n +
1126485,−722534400n10 −
5219450880n9 −
14278672384n8 −
18150825984n7 −
9547198464n6 +
916187136n5 +
3095921664n4 +
1071358464n3 +
48646144n2 −21106176n)
3392064
−1728+551π
4.16
104
P∞
k=0
4096−kk(2128k2+4050k+1861)(
2k
k )
3
(k+1)3
31232 −98112
π
PCF(1106560n6 +
15359184n5 +
86935120n4 +
255921504n3 +
411374988n2 +
340256619n +
112128678,−18548260864n12−
376648237056n11 −
3433659121664n10 −
18548547182592n9 −
65961076154368n8 −
162097652928512n7 −
280802726061056n6 −
342734209244672n5 −
288669949054976n4 −
159659246702592n3 −
52134516228096n2 −
7603919511552n)
−133626321174528+42537276407808π
−133955584+42639411π
4.16
65


--- Page 66 ---
Cluster
Formula
Value
Canonical form (CF)
CF value
Convergence rate
δ = −0.50
(cont.)
105
P∞
k=0
4096−kk2(78162k2+145175k+64431)(
2k
k )
3
(k+1)3
−1321984 + 4153360
π
PCF(40644240n7 +
603553472n6 +
3740699664n5 +
12504251940n4 +
24268130979n3 +
27259698627n2 +
16367928552n +
4050187164,−25023685607424n14−
555894186860544n13 −
5601703483531264n12 −
33854715025600512n11 −
136645305543681024n10 −
387937847576512000n9 −
794055668810237952n8 −
1180136086421543424n7 −
1263161025479455744n6 −
948859671284379648n5 −
474348094193147904n4 −
141516190384201728n3 −
19023203258744832n2)
−153284543710986240+48789345068384256π
−2126520320+676891779π
4.16
δ = −0.59
106
P∞
k=0 (−1)k 2−10k 
1
10k+9 −
4
10k+7 −
4
10k+5 −
64
10k+3 +
256
10k+1 −
1
4k+3 −
32
4k+1

64π
PCF(2684352000000000n13+
38090960000000000n12 +
245000065120000000n11 +
944869784312000000n10 +
2435218351929120000n9 +
4424192355790080000n8 +
5821651713360384000n7 +
5609901140010836800n6 +
3952412820744570848n5 +
2007080164781810560n4 +
712485836218990920n3 +
166987020313319310n2 +
23083685299707597n +
1415404977216930,7050625024000000000000000000n26+
101374230528000000000000000000n25+
652528456826880000000000000000n24+
2465108672380928000000000000000n23+
5988171776162529280000000000000n22+
9507079778423275520000000000000n21+
9154983459598486732800000000000n20+
3155400509259243847680000000000n19−
4399616995545381312921600000000n18−
7236476374495916090982400000000n17−
4265372330790924839813120000000n16−
39670105167726505885696000000n15+
1608243322433796856212357120000n14+
1003875367531610931241943040000n13+
142208650082332906941579264000n12−
131353172670351967155335987200n11−
76335863865628076468903346176n10−
11452003239546502086378127360n9+
3524016088399505544133738496n8+
1707190197990808862507925504n7+
186030732855351047414611968n6−
32329095769907407247671296n5−
10027373335724022275321856n4−
582635353945987520262144n3+
77843351835543790568448n2+
11551536496499025954816n+
417789746290203033600)
787032791496000π
31669−10080π
6.93
P∞
k=0 (−1)k 2−10k 
1
640k+576 −
1
256k+192 −
1
160k+112 −
1
160k+80 −
1
10k+3 +
4
10k+1 −
1
8k+2

π
δ = −0.61
107
P∞
k=0
(−64)−k(28k2+10k+1)(
2k
k )
5
(6k+1)(
3k
k )(
6k
3k)
3
π
PCF(23296n7 +
125248n6 + 276544n5 +
320864n4 + 207200n3 +
72320n2 + 12192n +
801,21676032n14 +
69672960n13 +
53256192n12 −
48660480n11 −
89803776n10 −
28091904n9 +
23292672n8 +
20539776n7 +
5356800n6 + 92352n5 −
164880n4 −17784n3)
117
−3+π
3.30
P∞
n=0
(−1
27)
n(28n2+10n+1)

( 1
2)(n)
5
(6n+1)( 1
6)(n)( 5
6)(n)n!3
3
π
66


--- Page 67 ---
Cluster
Formula
Value
Canonical form (CF)
CF value
Convergence rate
δ = −0.64
108
P∞
n=0
1458−n(15n+2)(2n)!(3n)!
n!5
27
4π
PCF(3915n4 + 12132n3 +
13047n2 + 5354n +
520,−984150n8 −
1738665n7 −137781n6 +
1151091n5 + 668979n4 +
107406n3)
918
27−8π
2.60
P∞
n=0 2−n3−6n  n + 2
15
  2n
n
2 3n
n

9
20π
P∞
n=0
( 27
2 )
−n(15n+2)( 1
3)(n)( 1
2)(n)( 2
3)(n)
n!3
27
4π
109
P∞
k=0
1458−k(111k2−7k−4)(
2k
k )
2(
3k
k )
(2k−1)(3k−1)
−45
4π
PCF(28971n5 + 82089n4 +
74487n3 + 17735n2 −
4602n −
872,−53892054n10 +
33743223n9 +
114043302n8 −
66518334n7 −
58348674n6 +
31906143n5 +
5149170n4 −2770200n3)
4500
45−16π
2.60
110
P∞
k=0 1458−kk3  900k2 −2097k + 929
  2k
k
2 3k
k

−27
20π
PCF(234900n5 +
683883n4 + 611136n3 +
69813n2 −136828n −
45024,−3542940000n10 −
13604889600n9 −
4483826766n8 +
40519719045n7 +
52000563627n6 +
2841693759n5 −
19266142005n4 −
4537514700n3)
131876100
6561−10720π
2.60
111
P∞
k=0
1458−k(1524k2+899k+263)(
2k
k )
2(
3k
k )
(k+1)(2k−1)(3k−1)
3375
4π
PCF(397764n5 +
1757115n4 + 2799174n3 +
2058041n2 + 755034n +
130504,−10158947424n10−
17064898560n9 +
13492053522n8 +
24444146385n7 −
13486145949n6 −
12680237907n5 +
6562189971n4 +
1130544378n3 −
579595824n2)
9065250
3375−1052π
2.60
112
P∞
k=0 1458−k  56025k2 + 112584k + 56551
   2k
k+1
2 3k
k

6615
4π
PCF(14622525n6 +
176113899n5 +
855263871n4 +
2136724149n3 +
2887845868n2 +
1997567096n +
553123200,−13729113933750n12−
254250324752175n11 −
2087327331723069n10 −
10004733078193332n9 −
31006251982463400n8 −
64925286141963699n7 −
93024351789956001n6 −
90051659766526338n5 −
56364085245495780n4 −
20596254103734696n3 −
3336437076176160n2)
19513829338920
321489−90064π
2.60
67


--- Page 68 ---
Cluster
Formula
Value
Canonical form (CF)
CF value
Convergence rate
δ = −0.68
113
P∞
k=0
16−k(120k2+151k+47)
512k4+1024k3+712k2+194k+15
π
PCF(1044480n6 +
7458304n5 +21619136n4 +
32438504n3 +
26456230n2 +11070645n+
1852434,−60397977600n12−
393593487360n11 −
1039730212864n10 −
1408627638272n9 −
974252605440n8 −
202269474816n7 +
170414705664n6 +
128014877184n5 +
25005952192n4 −
4802519872n3 −
2768834448n2 −
394428960n −18316800)
71550π
−47+15π
2.77
P∞
i=0 16−i 
−
1
8i+6 −
1
8i+5 −
2
8i+4 +
4
8i+1

π
P∞
k=0 16−k 
−
1
8k+6 −
1
8k+5 −
2
8k+4 +
4
8k+1

π
P∞
m=0 16−m 
−
1
8m+6 −
1
8m+5 −
2
8m+4 +
4
8m+1

π
P∞
n=0 16−n 
−
1
8n+6 −
1
8n+5 −
2
8n+4 +
4
8n+1

π
P∞
k=0 2−4k 
−
1
8k+6 −
1
8k+5 −
2
8k+4 +
4
8k+1

π
114
P∞
n=0
16−n(40n2−7n+1)(−1
2)(n)(−3
8)(n)(−1
4)(n)( 1
8)(n)
( 1
2)(n)( 3
4)(n)( 9
8)(n)( 13
8 )(n)
5π
16
PCF(348160n6 +
1270272n5 + 1612608n4 +
788632n3 + 85322n2 −
12295n +
5514,−6710886400n12 +
9059696640n11 +
11161042944n10 −
18064867328n9 −
3976396800n8 +
11906629632n7 −
1939592192n6 −
2448268800n5 +
933823680n4 −
839872n3 −33462672n2 +
1279968n + 391680)
510π
16−5π
2.78
115
P∞
k=0
16−k(120k2+235k+99)(−3
8)(k)( 1
8)(k)( 1
2)(k)( 3
4)(k)
( 9
8)(k)( 13
8 )(k)( 5
2)(k)( 11
4 )(k)
63π
2
PCF(1044480n6 +
10094080n5 +
39436736n4 +
79283912n3 +
85961374n2 +47272809n+
10188954,−60397977600n12−
538548633600n11 −
1946303856640n10 −
3616349880320n9 −
3524063330304n8 −
1407537070080n7 +
354994965504n6 +
533609175552n5 +
138379472320n4 −
20669097856n3 −
15123977328n2 −
2291475168n−109831680)
28602π
22−7π
2.78
P∞
n=0
16−n(120n2+235n+99)(−3
8)(n)( 1
8)(n)( 1
2)(n)( 3
4)(n)
( 9
8)(n)( 13
8 )(n)( 5
2)(n)( 11
4 )(n)
63π
2
68


--- Page 69 ---
Cluster
Formula
Value
Canonical form (CF)
CF value
Convergence rate
δ = −0.68
116
P∞
k=0 16−k 
−
1
8k+7 +
4
8k+4 +
4
8k+3 +
8
8k+2

2π
PCF(4177920n7 +
31889408n6 +
100376832n5 +
167914400n4 +
159965424n3 +
85913234n2 +23812437n+
2611170,−966367641600n14−
7135014420480n13 −
21160699887616n12 −
30977820721152n11 −
19361501806592n10 +
5089203585024n9 +
16296553857024n8 +
9574298615808n7 +
722307942400n6 −
1770106902528n5 −
932890659904n4 −
197879557824n3 −
13151503632n2 +
1452925152n+199825920)
780570π
−65+21π
2.77
δ = −0.71
117
P∞
k=0
16−k(
2k
k )
2k+1
π
3
PCF(20n2 + 44n +
25,−64n4 −96n3 −
48n2 −8n)
π
−3+π
1.39
P∞
k=0
2−4k(
2k
k )
2k+1
π
3
P∞
q=0
3·2−4q(
2q
q )
2q+1
π
118
P∞
i=1
16−i(
2i
i )
2i+1
−1 + π
3
PCF(20n2 + 84n +
89,−64n4 −352n3 −
720n2 −648n −216)
216−72π
25−8π
1.39
P∞
n=1
16−n(
2n
n )
2n+1
−1 + π
3
119
P∞
n=0
16−n(6n+5)(
2n
n )
(2n−1)(2n+1)(2n+3)
−π
2
PCF(120n3 + 460n2 +
514n + 189,−2304n6 −
7296n5 −4480n4 +
2880n3 + 1264n2 −264n)
33π
10−3π
1.39
δ = −0.74
120
P∞
n=0 (−1)n 4−n 
1
4n+3 +
2
4n+2 +
2
4n+1

π
PCF(1920n5 + 11296n4 +
25016n3 + 25646n2 +
11905n +
1962,1638400n10 +
8355840n9 +15609856n8 +
11624448n7 −371968n6 −
5753472n5 −3107120n4 −
303408n3 + 229828n2 +
74472n + 6624)
414π
10−3π
1.39
69


--- Page 70 ---
Cluster
Formula
Value
Canonical form (CF)
CF value
Convergence rate
δ = −0.74
(cont.)
121
P∞
k=0 −16−k−1 
1
8k+7 +
2
8k+6 +
2
8k+5 −
4
8k+3 −
8
8k+2 −
8
8k+1

π
4
PCF(34225520640n11 +
406696493056n10 +
2143316606976n9 +
6597952929792n8 +
13147113750528n7 +
17745614598144n6 +
16486173371904n5 +
10483446296768n4 +
4438464202992n3 +
1179435143940n2 +
174547215315n +
10695273750,−64851834634135142400n22−
770655968235639275520n21−
3990364910235726905344n20−
11659787910064822550528n19−
20474781202902757146624n18−
20009735019373038403584n17−
4470827785003632427008n16+
14792666534806265266176n15+
20205165716406391537664n14+
10262461920189293264896n13−
1171047348656337321984n12−
4651261809826751053824n11−
2619491664736064372736n10−
472035066965010677760n9+
169226552586375200768n8+
113762368223059935232n7+
23112713279753342976n6+
44656589320839168n5 −
813054260841253632n4 −
140873401622019456n3 −
7987170386065680n2 +
142566415135200n +
21743515584000)
3145763250π
−109+35π
2.77
P∞
k=0 16−k 
−
1
32k+28 −
1
16k+12 −
1
16k+10 +
1
8k+3 +
2
8k+2 +
2
8k+1

π
δ = −0.75
122
P∞
k=0 256−kk3  6k2 −19k + 6
  2k
k
3
−
1
12π
PCF(240n5 + 608n4 +
120n3 −1008n2 −1193n −
440,−9216n10 −19968n9 +
61952n8 + 190720n7 +
60096n6 −166752n5 −
74304n4 + 41472n3)
1728
−8+21π
1.38
123
P∞
k=0 256−k  k2 + 1
  192k2 −626k −103
  2k
k
3
−1373
3π
PCF(7680n7 + 1840n6 −
41056n5 −84504n4 −
105848n3 −90009n2 −
37922n −
4370,−9437184n14 +
47382528n13 +
13908992n12 −
156557824n11 −
127080960n10 +
257140480n9 +
117536448n8 −
613944736n7 −
357328896n6 +
270441472n5 +
247601920n4 +
49146240n3)
1474602
−1373+309π
1.38
124
P∞
k=0 256−k  13608k2 + 25050k + 10589
   2k
k+1
3
27296 −84604
π
PCF(544320n8 +
8676912n7 +59045024n6 +
223752600n5 +
516148260n4 +
742418115n3 +
651298770n2 +
319555044n +
67415544,−47405481984n16−
1146343145472n15 −
12680362939392n14 −
84945259660800n13 −
384414182215168n12 −
1240661079383808n11 −
2936757342030912n10 −
5159671581960928n9 −
6724120738987392n8 −
6414378191822976n7 −
4348938878740480n6 −
1981782604878336n5 −
543034218313728n4 −
67406723610624n3)
−538566289956864+173758988353536π
−21658624+6938529π
1.38
70


--- Page 71 ---
Cluster
Formula
Value
Canonical form (CF)
CF value
Convergence rate
δ = −0.75
(cont.)
125
P∞
n=0
256−nn2(
2n
n )
3
(2n−3)(2n−1)
−
1
12π
PCF(40n3+148n2+166n+
55,−256n6 −896n5 −
832n4 + 96n3 + 288n2)
72
−8+3π
1.39
126
P∞
k=0 256−k (6k + 1)
 2k
k
3
4
π
PCF(240n4 + 736n3 +
792n2 + 336n +
39,−9216n8 −16896n7 −
2560n6 + 9984n5 +
6336n4 + 1120n3)
28
4−π
1.39
P∞
n=0 256−n (6n + 1)
 2n
n
3
4
π
P∞
n=0 2−8n (6n + 1)
 2n
n
3
4
π
P∞
n=0 256−n  n + 1
6
  2n
n
3
2
3π
P∞
n=0
2−8n(6n+1)(2n)!3
n!6
4
π
P∞
k=0 (−1)k 4−k (6k + 1)
 −1
2
k
3
4
π
P∞
k=0
4−k(6k+1)

( 1
2)(k)
3
k!3
4
π
P∞
n=0
4−n(6n+1)

( 1
2)(n)
3
n!3
4
π
P∞
n=0
2−2n(6n+1)

( 1
2)(n)
3
n!3
4
π
P∞
k=0
4−k( 3k
2 + 1
4)

( 1
2)(k)
3
k!3
1
π
127
P∞
k=0
256−kk(6k−1)(
2k
k )
3
(2k−1)3
1
2π
PCF(240n4 + 1280n3 +
2504n2 + 2120n +
651,−9216n8 −47616n7 −
94720n6 −91904n5 −
43840n4 −7712n3 +
896n2 + 352n)
176
16−5π
1.39
128
P∞
k=0
256−k(12k2−1)(
2k
k )
3
(2k−1)2
−2
π
PCF(480n5 + 1296n4 +
1088n3 + 208n2 −94n −
21,−36864n10 + 18432n9 +
89088n8 −44544n7 −
50944n6 + 25472n5 +
7744n4 −3872n3)
22
2−π
1.39
δ = −0.75
129
P∞
n=0
2−6n(2100n2+1160n+63)( 1
10)(n)( 3
10)(n)( 7
10)(n)( 9
10)(n)
(2n+1)( 1
2)(n)n!3
200
π
PCF(1365000000n6 +
6886000000n5 +
13628850000n4 +
13283880000n3 +
6461275900n2 +
1346342040n +
61108047,−28224000000000000n12−
101740800000000000n11 −
96724480000000000n10 +
47073536000000000n9 +
126021900800000000n8 +
54539290880000000n7 −
12829349632000000n6 −
14719958809600000n5 −
3316987367040000n4 −
201577965120000n3)
125609400
200−63π
4.16
δ = −0.77
130
P∞
j=0
4−j(48j2+76j+31)( 3
4)(j)( 3
2)(j)
(j+1)(4j+1)( 11
8 )(j)( 15
8 )(j)
21π
2
PCF(15360n6 +121088n5 +
387904n4 + 645552n3 +
588500n2 + 279001n +
53940,−37748736n12 −
346030080n11 −
1354301440n10 −
2947039232n9 −
3879428096n8 −
3125897216n7 −
1452979712n6 −
302704640n5 +
15363632n4 +
10035756n3−4167378n2−
1802088n −175770)
58590π
−62+21π
1.39
71


--- Page 72 ---
Cluster
Formula
Value
Canonical form (CF)
CF value
Convergence rate
δ = −0.77
131
P∞
j=0
( 27
4 )
−j(368j3+400j2+118j+9)

( 1
4)(j)
2( 1
2)(j)

( 3
4)(j)
2
( 4
3)(j)( 5
3)(j)j!3
32
π
PCF(1460224n8 +
10254336n7 +
30198016n6 +
48411008n5 +
45785184n4 +
25791664n3 +
8263468n2 + 1327140n +
77175,−239628976128n16−
1359633973248n15 −
2762609786880n14 −
1761717780480n13 +
1754200080384n12 +
3409371168768n11 +
1472080920576n10 −
671023939584n9 −
863464676352n8 −
256765588992n7 +
24587248896n6 +
31003596672n5 +
6642741888n4 +
476340480n3)
257760
32−9π
1.91
δ = −0.77
132
P∞
j=1
( 256
27 )
−j(32976j5+67896j4+52844j3+19156j2+3167j+180)

( 1
6)(j)
2( 1
2)(j)

( 5
6)(j)
2j!
j( 7
8)(j)( 9
8)(j)( 4
3)(j)( 11
8 )(j)( 13
8 )(j)( 5
3)(j)
−149 + 60π
PCF(2687675904n11 +
56471427072n10 +
535315804416n9 +
3021521573952n8 +
11281513939616n7 +
29252467524640n6 +
53743687923752n5 +
69953516648740n4 +
63210207439520n3 +
37759710234253n2 +
13419573808347n +
2149364047698,−623425631475990528n22−
19087986092113133568n21−
275348137430420029440n20−
2488293166274605744128n19−
15800171388967065010176n18−
74944821953597729955840n17−
275584389035044674392064n16−
804682855975385924425728n15−
1895673749567702243880960n14−
3640715324669684509461504n13−
5736185376897136561716480n12−
7436162403767341956209280n11−
7931362314765912632102016n10−
6939790953137810855789760n9−
4951447084034730814786848n8−
2853248226731004784120704n7−
1309335440321591091369804n6−
468917015270723575079178n5−
127291005254093541357168n4−
25070604686415888998310n3−
3339540353061295760916n2−
264619352541786580800n−
9163515571913102400)
505690303783352688−203633679375846720π
4460671−1441440π
2.25
δ = −0.78
133
P∞
j=1
(−16)j(40j2−12j−1)(
2j
j )
j(2j−1)2(4j+1)(
4j
2j)
2
8 −4π
PCF(7680n6 + 70656n5 +
261696n4 + 498528n3 +
513624n2 + 270156n +
56295,26214400n12 +
259522560n11 +
1106640896n10 +
2656960512n9 +
3926888448n8 +
3637020672n7 +
1998611456n6 +
483591168n5 −
103859648n4 −
110540832n3 −
31619952n2 −3824280n −
145800)
−32400+16200π
16−5π
1.39
72


--- Page 73 ---
Cluster
Formula
Value
Canonical form (CF)
CF value
Convergence rate
δ = −0.80
134
P∞
k=0 (−1024)−k k3  400k2 −496k + 327
  2k
k
2 4k
2k

9
5π
PCF(38400n5 + 99584n4 +
25408n3 −156256n2 −
188394n −
68607,655360000n10 +
3945267200n9 +
8690139136n8 +
7602667520n7 +
1455075328n6 +
2245892096n5 +
6993980160n4 +
4109212800n3)
−12566400
128+385π
1.38
135
P∞
k=0 (−1024)−k  19840k2 + 39324k + 19481
   2k
k+1
2 4k
2k

−1000
π
PCF(1904640n6 +
22504064n5 +
106510496n4 +
256884424n3 +
330495838n2 +
213084771n +
53326350,1612290457600n12+
29769513041920n11 +
243609643319296n10 +
1163447016357888n9 +
3591108030627840n8 +
7484964318959616n7 +
10668120581775104n6 +
10265556721549952n5 +
6381908722722560n4 +
2314389737823744n3 +
371767948231680n2)
3816723456000
−102400+47187π
1.38
136
P∞
k=0
(−1024)−k(8k2−2k−1)(
2k
k )
2(
4k
2k)
(k+1)(2k−1)(4k−1)
−16
5π
PCF(96n3+464n2+634n+
261,4096n6 + 10240n5 +
6912n4 + 128n3 −640n2)
80
16−5π
1.39
137
P∞
k=0 (−1024)−k (20k + 3)
 2k
k
2 4k
2k

8
π
PCF(1920n4 + 6368n3 +
7288n2 + 3146n +
315,1638400n8 +
2949120n7 + 262144n6 −
1910784n5 −1054976n4 −
150144n3)
552
−8+3π
1.39
P∞
n=0 (−1)n 2−10n (20n + 3)
 2n
n
2 4n
2n
8
π
P∞
k=0
(−4)−k(20k+3)( 1
4)(k)( 1
2)(k)( 3
4)(k)
k!3
8
π
P∞
n=0
(−1)n4−n(20n+3)( 1
4)(n)( 1
2)(n)( 3
4)(n)
n!3
8
π
P∞
n=0
(−1)n2−2n(20n+3)( 1
4)(n)( 1
2)(n)( 3
4)(n)
n!3
8
π
P∞
n=0
(−1
4)
n(20n+3)( 1
4)(n)( 1
2)(n)( 3
4)(n)
n!3
8
π
138
P∞
k=0
(−1024)−k(40k2−2k−1)(
2k
k )
2(
4k
2k)
(2k−1)(4k−1)
−4
π
PCF(3840n5 + 13248n4 +
14608n3 + 4676n2 −
644n −165,6553600n10 −
3932160n9 −
13500416n8 + 7626752n7 +
6695936n6 −3568128n5 −
367360n4 + 194176n3)
148
−4+π
1.39
δ = −0.86
139
P∞
k=0 648−kk3  854k2 −3639k + 910
  2k
k
2 4k
2k

−243
14π
PCF(96502n5 +
166951n4 −357406n3 −
1238824n2 −1267179n −
461835,−1890387072n10 +
42057792n9 +
28244340360n8 +
34524320580n7 −
71756129178n6 −
143426873097n5 −
43072909110n4 +
22847151600n3)
677882520
−2187+8750π
0.92
140
P∞
k=0 648−k (7k + 1)
 2k
k
2 4k
2k

9
2π
PCF(791n4 + 2374n3 +
2482n2 + 1007n +
105,−127008n8 −
226800n7 −17334n6 +
149769n5 + 82134n4 +
11664n3)
216
9−2π
0.93
P∞
n=0
( 81
32)
−n(7n+1)( 1
4)(n)( 1
2)(n)( 3
4)(n)
n!3
9
2π
73


--- Page 74 ---
Cluster
Formula
Value
Canonical form (CF)
CF value
Convergence rate
δ = −0.86
(cont.)
141
P∞
k=0
648−k(122k2+3k−5)(
2k
k )
2(
4k
2k)
(2k−1)(4k−1)
−21
2π
PCF(13786n5 + 35841n4 +
29614n3+7104n2−965n−
285,−38579328n10 +
17392320n9 +
83657448n8 −
39260700n7 −
41524002n6 +
20115135n5 +
2277882n4 −1108080n3)
2520
21−10π
0.93
142
P∞
k=0
648−k(1903k2+114k+41)(
2k
k )
2(
4k
2k)
(k+1)(2k−1)(4k−1)
343
2π
PCF(215039n5 +
720798n4 + 810302n3 +
328875n2 + 34877n +
8700,−9386692128n10 −
5817973392n9 +
23052928050n8 +
11193948009n7 −
19783391157n6 −
6108011388n5 +
6029620560n4 +
339444756n3 −
305057340n2)
705894
343−82π
0.93
143
P∞
k=0 648−k  2107k2 + 4359k + 2249
   2k
k+1
2 4k
2k

567
π
PCF(238091n6 +
2907189n5 +14353943n4 +
36596679n3 +
50726276n2 +36214482n+
10426185,−11507051808n12−
214464248208n11 −
1771630180902n10 −
8542913475033n9 −
26632332249786n8 −
56090452945077n7 −
80827637149008n6 −
78693324310107n5 −
49539739902066n4 −
18209558822580n3 −
2967860914200n2)
11876722200
2916−415π
0.93
δ = −0.86
144
P∞
j=0
4−j(18j2+19j+6)

( 1
6)(j)
2j!
( 13
12)(j)( 19
12)(j)( 11
6 )(j)
35π
18
PCF(19440n5 +
103464n4 + 208296n3 +
197430n2 + 89543n +
16560,−60466176n10 −
298971648n9 −
527726016n8 −
341467488n7 +
40616640n6 +
115455024n5 +
1562292n4−29814726n3−
9904998n2 −1164570n −
45150)
9030π
−108+35π
1.39
74


--- Page 75 ---
Cluster
Formula
Value
Canonical form (CF)
CF value
Convergence rate
δ = −0.89
145
P∞
j=0
4−j(108j2+72j+5)

( 1
6)(j)
2
( 5
6)(j)
2
( 3
2)(j)j!3
18
π
PCF(699840n6 +
3545856n5 + 7069680n4 +
6990624n3 + 3499812n2 +
776232n +
43505,−78364164096n12 −
300395962368n11 −
325066162176n10 +
76429246464n9 +
351120365568n8 +
187384679424n7 −
7603808256n6 −
29844910080n5 −
7099617600n4 −
491508000n3)
83250
18−5π
1.39
146
P∞
n=0
2−8n3−6n(25−108n2)(
4n
2n)(
6n
3n)(
6n
4n)
(6n−5)2
3
5π
PCF(699840n6 +
2239488n5 + 2302992n4 +
557280n3 −385164n2 −
189000n −
12925,−78364164096n12 +
39182082048n11 +
301847150592n10 −
150923575296n9 −
352141572096n8 +
176070786048n7 +
157361356800n6 −
78680678400n5 −
22320360000n4 +
11160180000n3)
155625
3−5π
1.39
δ = −1.00
147
P∞
k=1 (−1)k+1 
1
6k−1 +
1
6k−5

π
3
PCF(72n2 + 144n +
62,5184n6 + 15552n5 +
13104n4 + 288n3 −
3428n2 −980n −75)
75π
18−5π
0.00
δ = −1.00
148
P∞
n=0
( 1
6)(n)( 5
6)(n)
(n+1)!2
648−180π
25π
PCF(72n2 + 180n +
149,−1296n4 −3888n3 −
4068n2 −1656n −180)
−3240+900π
−648+205π
0.00
δ = −1.00
149
P∞
n=1
1
n(2n−1)(4n−3)
π
3
PCF(16n3 + 52n2 + 66n +
31,−64n6 −224n5 −
308n4 −212n3 −77n2 −
14n −1)
π
−3+π
0.00
P∞
n=1
3
4n(4n−3)(4n−2)
π
8
P∞
n=0
1
(n+1)(2n+1)(4n+1)
π
3
75


--- Page 76 ---
NeurIPS Paper Checklist
1. Claims
Question: Do the main claims made in the abstract and introduction accurately reflect the
paper’s contributions and scope?
Answer: [Yes]
Justification: The abstract and introduction describe the absence and need of a framework
for symbolic and rigorous unification of mathematical formulas, and touch upon the focus of
this study: unification of π formulas as a proof-of-concept of the general scheme. Section 5
shows that most canonical forms are unified within our framework and that the methods
described generalize to additional constants.
Guidelines:
• The answer NA means that the abstract and introduction do not include the claims
made in the paper.
• The abstract and/or introduction should clearly state the claims made, including the
contributions made in the paper and important assumptions and limitations. A No or
NA answer to this question will not be perceived well by the reviewers.
• The claims made should match theoretical and experimental results, and reflect how
much the results can be expected to generalize to other settings.
• It is fine to include aspirational goals as motivation as long as it is clear that these goals
are not attained by the paper.
2. Limitations
Question: Does the paper discuss the limitations of the work performed by the authors?
Answer: [Yes]
Justification: Section 6 emphasizes the following limitation: Depending on the constant to
which the unification algorithm is tuned, the algorithm will need to be modified to support
the corresponding CMF. We also discuss the performance loss when changing the LLM
models.
Guidelines:
• The answer NA means that the paper has no limitation while the answer No means that
the paper has limitations, but those are not discussed in the paper.
• The authors are encouraged to create a separate "Limitations" section in their paper.
• The paper should point out any strong assumptions and how robust the results are to
violations of these assumptions (e.g., independence assumptions, noiseless settings,
model well-specification, asymptotic approximations only holding locally). The authors
should reflect on how these assumptions might be violated in practice and what the
implications would be.
• The authors should reflect on the scope of the claims made, e.g., if the approach was
only tested on a few datasets or with a few runs. In general, empirical results often
depend on implicit assumptions, which should be articulated.
• The authors should reflect on the factors that influence the performance of the approach.
For example, a facial recognition algorithm may perform poorly when image resolution
is low or images are taken in low lighting. Or a speech-to-text system might not be
used reliably to provide closed captions for online lectures because it fails to handle
technical jargon.
• The authors should discuss the computational efficiency of the proposed algorithms
and how they scale with dataset size.
• If applicable, the authors should discuss possible limitations of their approach to
address problems of privacy and fairness.
• While the authors might fear that complete honesty about limitations might be used by
reviewers as grounds for rejection, a worse outcome might be that reviewers discover
limitations that aren’t acknowledged in the paper. The authors should use their best
judgment and recognize that individual actions in favor of transparency play an impor-
tant role in developing norms that preserve the integrity of the community. Reviewers
will be specifically instructed to not penalize honesty concerning limitations.
76


--- Page 77 ---
3. Theory assumptions and proofs
Question: For each theoretical result, does the paper provide the full set of assumptions and
a complete (and correct) proof?
Answer: [Yes]
Justification: Lemma 1 and its generalization, which enable UMAPS, are proven in Ap-
pendix F.1. Corollary 1, which states the sufficiency of UMAPS given a bound on the
polynomial degrees of the coboundary matrix, is proven in Appendix C.3.
Guidelines:
• The answer NA means that the paper does not include theoretical results.
• All the theorems, formulas, and proofs in the paper should be numbered and cross-
referenced.
• All assumptions should be clearly stated or referenced in the statement of any theorems.
• The proofs can either appear in the main paper or the supplemental material, but if
they appear in the supplemental material, the authors are encouraged to provide a short
proof sketch to provide intuition.
• Inversely, any informal proof provided in the core of the paper should be complemented
by formal proofs provided in appendix or supplemental material.
• Theorems and Lemmas that the proof relies upon should be properly referenced.
4. Experimental result reproducibility
Question: Does the paper fully disclose all the information needed to reproduce the main ex-
perimental results of the paper to the extent that it affects the main claims and/or conclusions
of the paper (regardless of whether the code and data are provided or not)?
Answer: [Yes]
Justification:
All code, data, and results are available on the project repository:
https://github.com/RamanujanMachine/euler2ai, including the final coboundary graph,
which stores the transformations between equivalent formulas and directly leads to the
result statistics in Table 4. All LLM prompts are included also in Appendices I.6 and H.
Harvested formulas are included in Appendix J, and are included in the supplementary
material ZIP along with their arXiv sources. CMF-generated formulas are included in the
supplemental material ZIP. The UMAPS algorithm is available also on the online algorithm
demonstration [4].
Guidelines:
• The answer NA means that the paper does not include experiments.
• If the paper includes experiments, a No answer to this question will not be perceived
well by the reviewers: Making the paper reproducible is important, regardless of
whether the code and data are provided or not.
• If the contribution is a dataset and/or model, the authors should describe the steps taken
to make their results reproducible or verifiable.
• Depending on the contribution, reproducibility can be accomplished in various ways.
For example, if the contribution is a novel architecture, describing the architecture fully
might suffice, or if the contribution is a specific model and empirical evaluation, it may
be necessary to either make it possible for others to replicate the model with the same
dataset, or provide access to the model. In general. releasing code and data is often
one good way to accomplish this, but reproducibility can also be provided via detailed
instructions for how to replicate the results, access to a hosted model (e.g., in the case
of a large language model), releasing of a model checkpoint, or other means that are
appropriate to the research performed.
• While NeurIPS does not require releasing code, the conference does require all submis-
sions to provide some reasonable avenue for reproducibility, which may depend on the
nature of the contribution. For example
(a) If the contribution is primarily a new algorithm, the paper should make it clear how
to reproduce that algorithm.
(b) If the contribution is primarily a new model architecture, the paper should describe
the architecture clearly and fully.
77


--- Page 78 ---
(c) If the contribution is a new model (e.g., a large language model), then there should
either be a way to access this model for reproducing the results or a way to reproduce
the model (e.g., with an open-source dataset or instructions for how to construct
the dataset).
(d) We recognize that reproducibility may be tricky in some cases, in which case
authors are welcome to describe the particular way they provide for reproducibility.
In the case of closed-source models, it may be that access to the model is limited in
some way (e.g., to registered users), but it should be possible for other researchers
to have some path to reproducing or verifying the results.
5. Open access to data and code
Question: Does the paper provide open access to the data and code, with sufficient instruc-
tions to faithfully reproduce the main experimental results, as described in supplemental
material?
Answer: [Yes]
Justification: The raw data used in the experiments is openly available on arXiv. All
processed data and algorithms written by our group are provided in the project repository:
https://github.com/RamanujanMachine/euler2ai, through which the paper’s results can be
reproduced. The online algorithm demonstration [4] contains instructive examples for
running UMAPS.
Guidelines:
• The answer NA means that paper does not include experiments requiring code.
• Please see the NeurIPS code and data submission guidelines (https://nips.cc/
public/guides/CodeSubmissionPolicy) for more details.
• While we encourage the release of code and data, we understand that this might not be
possible, so “No” is an acceptable answer. Papers cannot be rejected simply for not
including code, unless this is central to the contribution (e.g., for a new open-source
benchmark).
• The instructions should contain the exact command and environment needed to run to
reproduce the results. See the NeurIPS code and data submission guidelines (https:
//nips.cc/public/guides/CodeSubmissionPolicy) for more details.
• The authors should provide instructions on data access and preparation, including how
to access the raw data, preprocessed data, intermediate data, and generated data, etc.
• The authors should provide scripts to reproduce all experimental results for the new
proposed method and baselines. If only a subset of experiments are reproducible, they
should state which ones are omitted from the script and why.
• At submission time, to preserve anonymity, the authors should release anonymized
versions (if applicable).
• Providing as much information as possible in supplemental material (appended to the
paper) is recommended, but including URLs to data and code is permitted.
6. Experimental setting/details
Question: Does the paper specify all the training and test details (e.g., data splits, hyper-
parameters, how they were chosen, type of optimizer, etc.) necessary to understand the
results?
Answer: [Yes]
Justification: Our unification algorithm groups formulas according to dynamical metrics,
which does not require training. Hyperparameters chosen are the granularity and similarity
threshold for δ, which are justified in the description of the coboundary graph algorithm
(Appendix C.1) and in the sensitivity study (Appendix D).
Guidelines:
• The answer NA means that the paper does not include experiments.
• The experimental setting should be presented in the core of the paper to a level of detail
that is necessary to appreciate the results and make sense of them.
• The full details can be provided either with the code, in appendix, or as supplemental
material.
78


--- Page 79 ---
7. Experiment statistical significance
Question: Does the paper report error bars suitably and correctly defined or other appropriate
information about the statistical significance of the experiments?
Answer: [Yes]
Justification: All statistical results, including benchmarks and other considerations regarding
significance and performance, are detailed in Section 4 and Section 5.
Guidelines:
• The answer NA means that the paper does not include experiments.
• The authors should answer "Yes" if the results are accompanied by error bars, confi-
dence intervals, or statistical significance tests, at least for the experiments that support
the main claims of the paper.
• The factors of variability that the error bars are capturing should be clearly stated (for
example, train/test split, initialization, random drawing of some parameter, or overall
run with given experimental conditions).
• The method for calculating the error bars should be explained (closed form formula,
call to a library function, bootstrap, etc.)
• The assumptions made should be given (e.g., Normally distributed errors).
• It should be clear whether the error bar is the standard deviation or the standard error
of the mean.
• It is OK to report 1-sigma error bars, but one should state it. The authors should
preferably report a 2-sigma error bar than state that they have a 96% CI, if the hypothesis
of Normality of errors is not verified.
• For asymmetric distributions, the authors should be careful not to show in tables or
figures symmetric error bars that would yield results that are out of range (e.g. negative
error rates).
• If error bars are reported in tables or plots, The authors should explain in the text how
they were calculated and reference the corresponding figures or tables in the text.
8. Experiments compute resources
Question: For each experiment, does the paper provide sufficient information on the com-
puter resources (type of compute workers, memory, time of execution) needed to reproduce
the experiments?
Answer: [Yes]
Justification: All LLM usage was done through the respective API of the provider, as is
declared in Appendix I.4. The matching algorithm (UMAPS, etc.) was run on a private
machine, as is declared in Appendix C. The sensitivity study was conducted on a university
cluster as mentioned in Appendix D.
Guidelines:
• The answer NA means that the paper does not include experiments.
• The paper should indicate the type of compute workers CPU or GPU, internal cluster,
or cloud provider, including relevant memory and storage.
• The paper should provide the amount of compute required for each of the individual
experimental runs as well as estimate the total compute.
• The paper should disclose whether the full research project required more compute
than the experiments reported in the paper (e.g., preliminary or failed experiments that
didn’t make it into the paper).
9. Code of ethics
Question: Does the research conducted in the paper conform, in every respect, with the
NeurIPS Code of Ethics https://neurips.cc/public/EthicsGuidelines?
Answer: [Yes]
Justification: This work adheres to the NeurIPS Code of Ethics. Specifically, with respect
to data concerns, this research utilizes metadata and content from arXiv.org, accessed in
accordance with arXiv’s API Terms of Use and individual paper licenses. All materials are
79


--- Page 80 ---
used solely for non-commercial, academic purposes, with proper attribution to the original
authors either in this paper, or in the supplementary material. Redistribution of full-text
content is avoided unless explicitly permitted by the respective licenses.
Guidelines:
• The answer NA means that the authors have not reviewed the NeurIPS Code of Ethics.
• If the authors answer No, they should explain the special circumstances that require a
deviation from the Code of Ethics.
• The authors should make sure to preserve anonymity (e.g., if there is a special consid-
eration due to laws or regulations in their jurisdiction).
10. Broader impacts
Question: Does the paper discuss both potential positive societal impacts and negative
societal impacts of the work performed?
Answer: [Yes]
Justification: The introduction in Section 1 includes discussion of the historical importance of
the challenges this work tackles. The societal significance of the unification of mathematical
knowledge is substantial, both for the wider math community and to help promote the
democratization of mathematics. No negative potential impacts could be ascertained.
Guidelines:
• The answer NA means that there is no societal impact of the work performed.
• If the authors answer NA or No, they should explain why their work has no societal
impact or why the paper does not address societal impact.
• Examples of negative societal impacts include potential malicious or unintended uses
(e.g., disinformation, generating fake profiles, surveillance), fairness considerations
(e.g., deployment of technologies that could make decisions that unfairly impact specific
groups), privacy considerations, and security considerations.
• The conference expects that many papers will be foundational research and not tied
to particular applications, let alone deployments. However, if there is a direct path to
any negative applications, the authors should point it out. For example, it is legitimate
to point out that an improvement in the quality of generative models could be used to
generate deepfakes for disinformation. On the other hand, it is not needed to point out
that a generic algorithm for optimizing neural networks could enable people to train
models that generate Deepfakes faster.
• The authors should consider possible harms that could arise when the technology is
being used as intended and functioning correctly, harms that could arise when the
technology is being used as intended but gives incorrect results, and harms following
from (intentional or unintentional) misuse of the technology.
• If there are negative societal impacts, the authors could also discuss possible mitigation
strategies (e.g., gated release of models, providing defenses in addition to attacks,
mechanisms for monitoring misuse, mechanisms to monitor how a system learns from
feedback over time, improving the efficiency and accessibility of ML).
11. Safeguards
Question: Does the paper describe safeguards that have been put in place for responsible
release of data or models that have a high risk for misuse (e.g., pretrained language models,
image generators, or scraped datasets)?
Answer: [NA]
Justification: No models are released in this paper, and the data sets used are openly available,
and used in accordance with the NeurIPS Code of Ethics. The algorithms and tools released
pose no risk for misuse.
Guidelines:
• The answer NA means that the paper poses no such risks.
• Released models that have a high risk for misuse or dual-use should be released with
necessary safeguards to allow for controlled use of the model, for example by requiring
that users adhere to usage guidelines or restrictions to access the model or implementing
safety filters.
80


--- Page 81 ---
• Datasets that have been scraped from the Internet could pose safety risks. The authors
should describe how they avoided releasing unsafe images.
• We recognize that providing effective safeguards is challenging, and many papers do
not require this, but we encourage authors to take this into account and make a best
faith effort.
12. Licenses for existing assets
Question: Are the creators or original owners of assets (e.g., code, data, models), used in
the paper, properly credited and are the license and terms of use explicitly mentioned and
properly respected?
Answer: [Yes]
Justification: We cite all the creators of the tools we use. We also list all the papers from
which our algorithm harvests formulas in Table 15, in addition to the regular citations list.
Guidelines:
• The answer NA means that the paper does not use existing assets.
• The authors should cite the original paper that produced the code package or dataset.
• The authors should state which version of the asset is used and, if possible, include a
URL.
• The name of the license (e.g., CC-BY 4.0) should be included for each asset.
• For scraped data from a particular source (e.g., website), the copyright and terms of
service of that source should be provided.
• If assets are released, the license, copyright information, and terms of use in the
package should be provided. For popular datasets, paperswithcode.com/datasets
has curated licenses for some datasets. Their licensing guide can help determine the
license of a dataset.
• For existing datasets that are re-packaged, both the original license and the license of
the derived asset (if it has changed) should be provided.
• If this information is not available online, the authors are encouraged to reach out to
the asset’s creators.
13. New assets
Question: Are new assets introduced in the paper well documented and is the documentation
provided alongside the assets?
Answer: [Yes]
Justification:
Yes,
a
well
documented
codebase
is
provided
with
the
pa-
per,
for
the
formula
unification
pipeline
and
the
UMAPS
algorithm:
https://github.com/RamanujanMachine/euler2ai.
The data harvested from the litera-
ture is also provided with the codebase.
Guidelines:
• The answer NA means that the paper does not release new assets.
• Researchers should communicate the details of the dataset/code/model as part of their
submissions via structured templates. This includes details about training, license,
limitations, etc.
• The paper should discuss whether and how consent was obtained from people whose
asset is used.
• At submission time, remember to anonymize your assets (if applicable). You can either
create an anonymized URL or include an anonymized zip file.
14. Crowdsourcing and research with human subjects
Question: For crowdsourcing experiments and research with human subjects, does the paper
include the full text of instructions given to participants and screenshots, if applicable, as
well as details about compensation (if any)?
Answer: [NA]
Justification: The paper does not involve crowdsourcing nor research with human subjects.
81


--- Page 82 ---
Guidelines:
• The answer NA means that the paper does not involve crowdsourcing nor research with
human subjects.
• Including this information in the supplemental material is fine, but if the main contribu-
tion of the paper involves human subjects, then as much detail as possible should be
included in the main paper.
• According to the NeurIPS Code of Ethics, workers involved in data collection, curation,
or other labor should be paid at least the minimum wage in the country of the data
collector.
15. Institutional review board (IRB) approvals or equivalent for research with human
subjects
Question: Does the paper describe potential risks incurred by study participants, whether
such risks were disclosed to the subjects, and whether Institutional Review Board (IRB)
approvals (or an equivalent approval/review based on the requirements of your country or
institution) were obtained?
Answer: [NA]
Justification: The paper does not involve crowdsourcing nor research with human subjects.
Guidelines:
• The answer NA means that the paper does not involve crowdsourcing nor research with
human subjects.
• Depending on the country in which research is conducted, IRB approval (or equivalent)
may be required for any human subjects research. If you obtained IRB approval, you
should clearly state this in the paper.
• We recognize that the procedures for this may vary significantly between institutions
and locations, and we expect authors to adhere to the NeurIPS Code of Ethics and the
guidelines for their institution.
• For initial submissions, do not include any information that would break anonymity (if
applicable), such as the institution conducting the review.
16. Declaration of LLM usage
Question: Does the paper describe the usage of LLMs if it is an important, original, or
non-standard component of the core methods in this research? Note that if the LLM is used
only for writing, editing, or formatting purposes and does not impact the core methodology,
scientific rigorousness, or originality of the research, declaration is not required.
Answer: [Yes]
Justification: LLMs are used in two different stages of our algorithm (classification and
extraction), and described openly and comprehensively. e.g, in Sections 3.1, 3.2 and 4
and Appendices H and I. The classification stage uses LLMs in a standard manner for
parsing mathematical language. The extraction stage uses an LLM-code feedback loop.
Guidelines:
• The answer NA means that the core method development in this research does not
involve LLMs as any important, original, or non-standard components.
• Please refer to our LLM policy (https://neurips.cc/Conferences/2025/LLM)
for what should or should not be described.
82
