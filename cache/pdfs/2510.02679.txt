--- Page 1 ---
IEEE TRANSACTIONS ON AUTOMATION SCIENCE AND ENGINEERING
1
Automated Constraint Specification for Job
Scheduling by Regulating Generative Model with
Domain-Specific Representation
Yu-Zhe Shi, Qiao Xu, Yanjia Li, Mingchen Liu, Huamin Qu,
Lecheng Ruan and Qining Wang, Senior Member, IEEE
Abstract—Advanced
Planning
and
Scheduling
(APS)
systems have become indispensable for modern manufacturing
operations,
enabling
optimized
resource
allocation
and
production efficiency in increasingly complex and dynamic
environments.
While
algorithms
for
solving
abstracted
scheduling problems have been extensively investigated, the
critical prerequisite of specifying manufacturing requirements
into formal constraints remains manual and labor-intensive.
Although recent advances of generative models, particularly
Large Language Models (LLMs), show promise in automating
constraint specification from heterogeneous raw manufacturing
data, their direct application faces challenges due to natural
language ambiguity,
non-deterministic outputs,
and limited
domain-specific knowledge. This paper presents a constraint-
centric architecture that regulates LLMs to perform reliable
automated constraint specification for production scheduling.
The
architecture
defines
a
hierarchical
structural
space
organized across three levels, implemented through domain-
specific
representation
to
ensure
precision
and
reliability
while
maintaining
flexibility.
Furthermore,
an
automated
production
scenario
adaptation
algorithm
is
designed
and
deployed to efficiently customize the architecture for specific
manufacturing configurations. Experimental results demonstrate
that the proposed approach successfully balances the generative
capabilities
of
LLMs
with
the
reliability
requirements
of
manufacturing systems, significantly outperforming pure LLM-
based approaches in constraint specification tasks.
Note to Practitioners—This paper presents a practical so-
lution for automating the conversion of raw manufacturing
information into job scheduling specifications, addressing a
common challenge in implementing APS systems. The proposed
architecture can process diverse manufacturing documentation
formats, from semi-structured route sheets to natural language
instructions, while ensuring reliability through domain-specific
representations. Manufacturing practitioners can use this system
to reduce the manual effort in specifying digitalized constraints
for production, particularly beneficial for facilities with frequent
requirement changes or small-batch, multi-variety production.
The system’s ability to automatically adapt to different manufac-
turing scenarios makes it accessible without requiring extensive
programming expertise, offering a practical balance between
automation and accuracy in production planning.
This work is partially supported by the National Natural Science Foundation
of China under Grants 52475001 and RGC GRF Grant 16210321. Yu-Zhe Shi
and Qiao Xu contributed equally. (Corresponding author: Lecheng Ruan)
Yu-Zhe Shi, Qiao Xu, Lecheng Ruan, and Qining Wang are with School of
Advanced Manufacturing and Robotics, Peking University, Beijing 100871,
China.
Yu-Zhe Shi, Yanjia Li, and Huamin Qu are with the Department of
Computer Science and Engineering, School of Engineering, The Hong Kong
University of Science and Technology, Hong Kong SAR.
Mingchen Liu is with the School of Computer Science and Technology,
Huazhong University of Science and Technology, Wuhan 430074, China.
Index Terms—Smart Manufacturing; Constraint Specification;
Domain-Specific Representation
I. INTRODUCTION
Smart manufacturing has become a cornerstone of industrial
development, promising enhanced productivity and adaptabil-
ity through digital transformation [1]. This manufacturing
paradigm represents a fundamental shift from traditional pro-
duction systems, incorporating advanced technologies to create
more intelligent and responsive operations [2], [3], [4]. As
manufacturers face increasing pressure to handle product vari-
ety and shorter delivery times, the conventional rigid produc-
tion models are giving way to Flexible Manufacturing System
(FMS) [5]. These systems must efficiently process multiple
jobs with different specifications, processing requirements, and
priorities—all while sharing limited manufacturing resources.
Accordingly, Advanced Planning and Scheduling (APS) sys-
tem [6] emerges as a crucial decision-making process in smart
manufacturing, as it determines how effectively manufacturing
resources are utilized to meet production objectives.
The implementation of an APS system comprehends two
major phases: (i) the specification of real-world manufacturing
constraints, such as procedural dependency for production
and availability of factory resource, into a mathematical Job
Scheduling Problem (JSP) formulation [7], [8]; and (ii) the so-
lution for the formulated JSP [9], [10]. In the previous research
paradigm, manufacturing constraints are typically abstracted
and standardized to emphasize the scheduling fundamentals
while deliberately excluding production-scenario-specific con-
text such as material characteristics, machine specifications,
and product requirements [11], [12]. Under this setting, diverse
JSP solvers have been successfully developed for specific
problem characteristics and instances [13], [14].
However, abstracted constraints for a JSP solver do not
emerge spontaneously from real-world manufacturing scenar-
ios; they require meticulous development and formalization by
experienced manufacturing experts [15]. This manual spec-
ification process was historically manageable in traditional
manufacturing settings with stable production scopes, as it was
essentially a one-time effort with long-term utility. However,
the emergence of smart manufacturing has fundamentally
transformed this landscape through several challenges. First,
the shift toward small-batch, multi-variety production demands
extensive constraint specifications to accommodate diverse
arXiv:2510.02679v1  [cs.AI]  3 Oct 2025


--- Page 2 ---
IEEE TRANSACTIONS ON AUTOMATION SCIENCE AND ENGINEERING
2
A
B
Natural Language
 Description
DSL Program Verification on
Dual Program Views
DSL Program Represention 
of Production Procedure
Constraint Generation 
in JSP Solver Format
DSL Program Representation 
of Production Plan
Semi-Structured 
Route Sheet
DSL Program for Resource 
and Precedence Constraints
Fully-Structured
Route Sheet
Schedule Resolved by 
JSP Solver
Product Flow with 
Concurrency Management
lathe
  slot  
  duration 
 
  machine  
  parameters 
carbide
  emit 
lathed_part
broaching
(
=
,
= 
,
=
,
= (
    
 = 
),
= 
);
(...)...
(...)...
metal_bar_0
Lathe_M
lathed_part_0
19 units
ADINTWS
jobs_data = [ 
    [..., 
     (1, 19, [0]), 
     (2, 21, [1]), 
     (3, 104, [2]), 
     (4, 161, [1]),...],
    ...
]
/*resource constraints*/
/*precedence constraints*/
exec lathe
exec drilling
dep lathe
broaching
dep broaching
drilling
dep lathe
milling
 
 
(
, 
) = 
;
(
, 
) = 
;

(
, 
) = 
;
(
, 
) = 
;
(
, 
) = 
;
Lathe_M
Drill_P
True
True
True
True
True
Optimal Schedule Length: 
...
Machine 0: job_0_task_1  
job_2_task_1  [0, 19]  
[20, 52]...          
Machine 1: job_4_task_3 
job_0_task_2  [0, 45]  
[46, 67]...
...          
lathe
  start_time 
  end_time 
  slot  
 
  machine  
broaching
  start_time 
  end_time 
 
  machine  
(
= ,
= 
,
=
,
=
,...)
(
= 
,
= 
,
= ...)
0
19
46
67
metal_bar_0
Lathe_M_#0
Mill the lathed part in 161 u time by 
3mm depth with 1000 RPM milling...
Drill the component in 104u time by 
a 10mm drill in 500 RPM spindle...
Broach the lathed into a component 
in 21u time with 5mm depth cut...
The vertical lathe turns a metal bar 
in 19u time with ADINTWS carbide...
No.
1
2
3
4
Operation
Lathe
Broaching
Drilling
Rough 
Milling
Operation Description
The vertical lathe turns a metal 
bar in 19u time with ADINTWS...
Broach the lathed into a 
component in 21u time with...
Drill the component in 104u time 
by a 10mm drill in 500 RPM...
Mill the lathed part in 161 u time 
by 3mm depth with 1000 RPM...
No.
1
2
3
4
Operation
Lathe
Broaching
Drilling
Rough 
Milling
Machine
Duration Material
Tooling
Vertical 
Lathe
19 units
Metal Bar
Carbide = 
ADINTWS
Broaching 
Machine
21 units
Lathed 
Part
Depth = 
5mm
Drill Press
104 units Broached 
Component
Depth = 
10mm
Vertical Milling 
Machine
161 units Lathed 
Part
Depth = 
3mm, ...
metal_bar | bandsawing
lathed_part | lathe
broached_c_0 | broaching
drilled_c_0 | drilling
Pushdown Automaton 
for Product Flow Traversal
drilled_c drilling
...
Lifecycles of the 
Intermediate Products
lathe     broaching
drilling
broached_c_0
lathed_part_1
lathed_part_0
metal_bar_0
milling
milling
Constraint Abstraction
Constraint Abstraction
Constraint Generation
Constraint Generation
JSP Solver
JSP Solver
Schedule Grounding
Schedule Grounding
Constraint Programming for 
Scheduling Optimization
P1 1
P1 3
P1 2
P1 4
P1 1
P1 1
P1 3
P1 3
P1 2
P1 2
P1 4
P1 4
P1 1
P1 3
P1 2
P1 4
P1 1
P1 3
P1 2
P1 4
P1 1
P1 1
P1 3
P1 3
P1 2
P1 2
P1 4
P1 4
S metal_bar_0 E
S lathed_part_0 E
S broached_c_0 E
S
...
E
S
...
E
S
...
E
S
...
E
S
...
E
S
...
E
S
...
E
S
lathed_part_1
E
Lathe
Broaching 
Machine
Drilling 
Press
Milling 
Machine
time 
Process Lock Mechanism for 
Program Reference
machine:
duration:
lathe
Lathe_M;
19 units;
device:
duration:
broaching
Broaching_M;
21 units;
device:
duration:
drilling
Drill_Press;
104 units;
component 
broached_c_0 / 
conveyer_belt
broached c.
component 
lathed_part_0 / 
conveyer_belt 
lathed part
lathe
lathe
19u
carbide
time
metal bar
broaching
broach
21u
depth
time
lathed part
lathe
slot 
duration 
machine 
parameters 
::=
  
  
::= 
  
::= 
  
::= 
::= ...
/*interface_0*/
MAT
INT
Lathe_M
  
metal_bar 
pred 
refname 
succ 
vol 
::=
  
::= 
  
::= 
  
::= 
::= 
Bandsawing
metal_bar_0
Operation
  
REAL MEAS
broach 
slot
duration
machine
parameters
::=
  
  
: 
  
: 
  
: 
 ::= ...
/*interface_2*/
PROD
INT
Broaching
  
lathed_part 
pred
refname
succ
::=
  
 ::= 
  
 ::= 
  
 ::= 
 
 
  ...
 
Lathe
“lathed_part_0”
Broaching
Milling
|
|
lathed part
metal bar
ADINTWS
5mm
lathe
broaching
drilling
broached c.
lathed part
lathe
broaching
drilling
broached c.
lathed part
lathe
broaching
drilling
broached c.
lathed part
Fig. 1. Illustration of the proposed constraint-centric architecture. (A) This panel presents a running example that illustrates the complete information
flow, transitioning from two formats of procedures to a grounded production plan (depicted in the top and bottom rows). It also outlines the three modules
involved: constraint abstraction, constraint generation, and schedule grounding, along with their corresponding core working mechanisms (shown in the
middle row). The DSL program specified for the manufacturing scenario is highlighted as the primary driving force of the architecture. (B) This panel provides
an intuitive visualization of the procedural transmission of information throughout the architecture’s process. Progressing from left to right, the sequence of
states includes the original procedures, fully-structured route sheet, generated constraint, JSP-solver-generated schedule, and ultimately, the production plan.
The information is color-coded according to its type, such as operation name, machine, duration, and unspecified information, to enhance understanding.
processing requirements [16]. Second, the inherently dynamic
nature of modern production necessitates constant updates
of constraints [17]. Third, manufacturing knowledge exists
in heterogeneous formats across different sources, ranging
from semi-structured route sheets to Natural Language (NL)
instructions [18], [19], creating significant barriers to efficient
constraint extraction. While researchers have made consid-
erable progress improving JSP solver efficiency, the manual
constraint specification process has emerged as the critical
bottleneck in APS implementation. Consequently, there is a
growing need to automate the constraint specification process,
and furthermore the entire workflow—from abstracting het-
erogeneous constraint rules to generating solver specifications
and ultimately grounding the resulting schedules back to
interpretable production plans.
With the rapid advancement of Generative Artificial In-
telligence (GenAI) techniques, leveraging Large Language
Models (LLMs) to automate constraint specification based
on heterogenous manufacturing data and knowledge appears
promising. Recent studies have demonstrated LLMs’ capabil-
ity to solve abstract optimization problems from mathematical
word problem-style NL descriptions [20], [21], suggesting
their potential applicability for specifying the constraints [22],
[23], [24], [25], [26]. However, despite LLMs’ strengths in
information extraction and NL understanding, their direct
application to manufacturing constraint specification faces sev-
eral fundamental challenges: (i) the intrinsic ambiguity of NL-
based raw manufacturing data such as route sheets [27]; (ii) the
non-deterministic nature of generative models like LLMs [28];
and (iii) the lack of fine-grained domain-specific knowledge
regarding the specific product categories and factories in the
training data of LLMs [29]. While such characteristics might
be acceptable or even beneficial in creative applications like
artwork composition, manufacturing systems demand abso-
lute precision, reliability, and detailed domain expertise [30].
Specifically, generated constraints must strictly align with
factory resources and product-specified production procedure,
while production plans must precisely define execution config-
urations. This fundamental mismatch between manufacturing’s
reliability requirements on constraints and the capabilities
of pure LLM-based solutions suggests the necessity of an
external architecture atop the LLM-based workflow to regulate
the LLM performance in the manufacturing scenarios.
To
address
these
challenges,
this
paper
proposes
a
constraint-centric architecture that regulates the LLM to per-
form automated reliable constraint specification from raw
manufacturing knowledge and data. The architecture defines a
hierarchical structural space that systematically organizes man-
ufacturing constraints across three distinct levels [31]. The top
level captures global operation dependencies and resource re-


--- Page 3 ---
IEEE TRANSACTIONS ON AUTOMATION SCIENCE AND ENGINEERING
3
lationships. The middle level handles the context-specific exe-
cution configurations, while the bottom level manages detailed
scheduling parameters and production specifications. This
hierarchical space is gradually constructed upon a domain-
specific representation, implemented through Domain-Specific
Languages (DSLs) [32] for their properties that naturally align
with manufacturing constraints [33], [34]—(i) the compact
domain-specific features to avoid redundancy of constraint
representation [35]; (ii) the support of flexible, syntactical
combination of constraints [36]; and (iii) the maintenance of
reliability by structural constraint representation [37]—serving
as an appropriate supplementary of LLMs [38]. To further
adapt the proposed architecture across different manufacturing
scenarios, such as varied factory configurations and diverse
production procedures [39], and avoid the labor-intensive,
case-specific, and costly DSL crafting [40], [41], [42], we
present an automated algorithm to efficiently adapt the ar-
chitecture according to specific manufacturing configurations.
Comprehensive experiments are conducted to verify our ad-
vantages over pure LLM-based approaches.
In this work, we address the automatic, entire-workflow
constraint specification for production scheduling, based on
a domain-specific representation to regulate LLM outputs, to
achieve a balance between the generative power of GenAI
and the guardrail of reliability. Our contributions are three-
fold: (i) we introduce and formulate the constraint-centric
architecture for reliable constraint specification (Sec. II); (ii)
we develop an automatic adapter for customizing the proposed
architecture across various production scenarios (Sec. III);
(iii) we integrate the architecture into the GenAI pipeline for
constraint specification, evaluate the pipeline on diverse man-
ufacturing scenarios (Sec. IV), and demonstrate the usability
and scalability of the proposed architecture (Sec. V).
II. THE CONSTRAINT-CENTRIC ARCHITECTURE
In this section, we introduce the constraint-centric architec-
ture for entire-life-cycle constraint specification (see Fig. 1).
Starting from an overview of the architecture (Sec. II-A), we
describe the three modules, including abstraction from the
route sheets (Sec. II-B), specification for JSP (Sec. II-C), and
instantiation for interpretable production plan (Sec. II-D).
A. Architecture Overview
The primary utility of the architecture lies in its ability to
take new-coming production procedures as input and generate
a corresponding scheduled production plan as output, tailored
to the specific context of a concrete factory within a manu-
facturing domain. The overall input to the architecture can be
classified into two types: (i) NL-based production documents,
which specify the target production procedure step-by-step
in textual form; or (ii) semi-structured manufacturing route
sheets, which contain extracted columns detailing the oper-
ation name and NL-based operation descriptions. According
to the Standard Operating Procedure (SOP) in manufacturing,
production procedure descriptions must be transformed into
fully-structured manufacturing route sheets, which serve as the
foundation for scheduling. These route sheets typically include
columns detailing machine names and operation durations.
Therefore, to accurately capture such information within the
production procedures, the first module compiles the unstruc-
tured or semi-structured descriptions into programs of the
corresponding DSL of the specific production scenario.
Subsequently, the second module works on the fine-grained
route sheet and specifies the constraints for JSP. This is
implemented as verification over the DSL programs, gener-
ating resource constraint programs and precedence constraint
programs. These programs are then transformed into a format
compatible with off-the-shelf JSP solvers.
Finally, the third module grounds the resulting schedule,
output by the JSP solvers, into production plans that are
ready for further interpretation and execution by the Computer
Numerical Control (CNC) systems within the factory envi-
ronment. This step completes the concrete semantics of the
operations and their corresponding execution configurations,
transforming the semanticless schedule produced by the JSP
solvers. This is achieved by referencing the DSL programs.
B. Constraint Abstraction from the Production Procedures
The first module takes the production procedures as input
and outputs a fully structured representation of the target pro-
duction procedures, specifically the complete manufacturing
route sheet. This desired route sheet must accurately capture
the operation name, required machine, standard duration, and
execution configurations for each step. Given the intrinsic
ambiguity of NL [27], achieving this objective necessitates
the precise parsing of NL-based descriptions and the fine-
grained representation of procedural knowledge. In precision-
demanding scenarios like manufacturing, any deviation from
the provided procedures or the factory’s conditions is inadmis-
sible. To ensure both preciseness and usability, we opt to uti-
lize domain-specific representation for production procedures,
implemented through DSLs.
The working mechanism of this module can be formally
expressed as CAP = (Υ | Γ, L), where Γ = {γ1, γ2, . . . , γ|Γ|}
represents the given set of production procedures, which
outline the steps for producing specific products γk; L de-
notes the DSL tailored to the manufacturing scenario and
the factory. The outcome Υ = {J , M} represents the set
of fully structured manufacturing route sheets, where J =
{J1, J2, . . . , J|J |} indicates the production procedures repre-
sented as DSL programs, and M = {M1, M2, . . . , M|M|}
denotes the factory, equipped with a concrete set of machines.
The corresponding DSL L = {Lo, Lp} is indicated by a pair
of dual program views: the operation-centric program view Lo
and the product-flow-centric program view Lp. This design
choice arises from the understanding that both operations and
product flows are critical elements in production procedures,
yet they cannot be tracked simultaneously because they are
intricately intertwined with each other. When focusing on
operations, the context becomes the input and output products;
conversely, when focusing on products, the context shifts to
the operations that yield and consume them, respectively. By
adopting a dual representation of these two views, we are able
to track the detailed execution of operations and the detailed


--- Page 4 ---
IEEE TRANSACTIONS ON AUTOMATION SCIENCE AND ENGINEERING
4
transition of product flows in parallel, resulting in a precise
and reliable model of the production procedure.
The operation-centric program view focuses on the ex-
ecution context of an operation. It captures the availabil-
ity of necessary materials as the precondition, the required
machines, and their corresponding execution configurations
as the program body, along with the expected output as
the postcondition. This view serves as an interface between
the semantic identifier and the grounded instances of the
operations, interpreting the purpose of the operation indicated
by the procedure in terms of a specific execution context. For
example, a milling operation can be performed on either a
vertical or a horizontal milling machine, depending on the
scale of the input material and the dimensions of the product.
In contrast, the product-flow-centric program view empha-
sizes the states of the product as it progresses through the
various operations, effectively modeling the product flow.
Each flow unit is produced by a predecessor operation and
consumed by a successor operation. A critical property of
the product flow is its spatial-temporal continuity, whereby
the transitions between the states of the product are largely
driven by specific operations. This view acts as a pipe [43],
passing products along the temporal dimension and tracking
the invariance of the entire procedure. For instance, to produce
a part incorporating two different types of metal materials, the
raw material input to the production line must consist of the
two required materials; these materials cannot appear from
nowhere but must be passed down the product flows.
The operation-centric program view, denoted as Lo
=
{So, Λo}, is characterized by the syntactic language feature
set So and the semantic language feature set λo. The syntax
So = (φ, ϕ, φprec, φpost, φexec) defines a structural space for
encapsulating the precondition φprec, postcondition φpost, and
execution φexec within the interface structure of the operation.
Utilizing this syntax, an operation with the semantic identifier
φ is referenced through an interface ϕ to a set of execution
contexts, represented as
⟨φ 7→ϕ 7→{(φprec, φpost, φexec)}⟩.
(1)
The operation φ can be grounded to a corresponding instance
in any compatible execution context, echoing the idea of mod-
ular design [44]. The semantics Λo = (Φ, Φprec, Φpost, Φexec)
specifies the permissible assignments of the fields and their
corresponding values within the structural space defined by So,
where φ ∈Φ, φprec ∈Φprec, φpost ∈Φpost, and φexec ∈Φexec.
Refer to Sec. III for the automated design of such DSLs.
The product-flow-centric program view, denoted as Lp =
{Sp, Λp}, is characterized by the syntactic language feature
set Sp and the semantic language feature set λp. The syntax
Sp = (ω, ωpred, ωsucc, ωprop, ψ⟨ωpred, ωsucc⟩) defines a structural
space for encapsulating a selected set of key properties of
the product ωprop, the predecessor ωpred, and the successor
ωsucc within the interface structure of the product, which is
inherited from the operation-centric program view. Using this
syntax, a product with the semantic identifier ω is represented
as ⟨ω 7→(ωpred, ωsucc, ωprop)⟩. Additionally, there is a special
syntactic feature ψ⟨ωpred
t
, ωsucc
t
⟩that captures the pipe structure
ψ⟨·, ·⟩of the product flow at the unit level ωt, indicating poten-
tial N-predecessors-to-M-successors relationships within the
product flow. If the product is transferred directly from the
predecessor to the successor, the pipe forms a linear structure.
In cases where two products are produced by two different
predecessors and consumed by one successor, the pipe forms
a “Y-shaped” structure. This syntax can express any “N-to-
M-intersection-shaped” relationships along the product flow,
i.e., N products produced by N different predecessors and
consumed by M different successors. Consequently, the pipe
structure syntax provides a guardrail for accurately mod-
eling product flows of varying complexity. The semantics
Λp = (Ω, Ωpred, Ωsucc, Ωprop, Ψ) specifies the permissible as-
signments of the fields and their corresponding values within
the structural space defined by Sp, where ω ∈Ω, ωpred ∈Ωpred,
ωsucc ∈Ωsucc, ωprop ∈Ωprop, and ψ ∈Ψ. Please refer to Sec. III
for the automated design of such DSLs.
We implement the translation from the original procedures Γ
to the fully structured route sheets Υ inspired by the practice
of Shi et al. [38], to guarantee the completeness of syntax,
the correctness of semantics, and the reliance of execution.
Given an original description of production procedure γk ∈Γ
for translation, we first parse the NL sentences by an off-
the-shelf tool and extract the actions accordingly [45]. Then,
the extracted actions are matched with the operation set Φ of
the DSL, according to both exact match score and semantic
similarity. Afterwards, we extract the arrays of entities related
to the extracted action E by an off-the-shelf LLM-based
tool [46], where we regard the output labels to the entities
and relations as pseudo-labels because they can possibly be
noisy. On this basis, we can formulate the objective of this
DSL program synthesis tasks as
arg min
∗L(Γ),E D(Γ ∥Υ)
s.t.
L = {So, Sp, Λo, Λp},
(2)
where ∗L(Γ) = {L(Γ) | Γ ⇒∗So, Γ ⇒∗Sp, L(Γ) ∈Λo∪Λp}
denotes the set of all possible DSL program patterns generated
by the procedures described by Γ. The divergence function
D(· ∥·) possesses three indicators: (i) the selected program
patterns should be as close as possible to the text span; (ii)
the selected program pattern should be as similar as possible
with the extracted subject-verb-object structure parsed from
NL description; and (iii) as many pseudo-labeled entities as
possible should be mapped to the semantics space.
C. Constraint Generation for JSP Formulation
The second module processes fully structured route sheets,
derived from the original set of production procedures, and
produces a specified set of constraints that formulates the
JSP. This specification is subsequently converted into a format
compatible with off-the-shelf JSP solvers, which are then
utilized to determine the optimal schedule for the production
procedures. The constraint generation mainly necessitates two
types of constraints: resource constraints and precedence con-
straints. Ensuring the accuracy of the constraint generation is
paramount to guaranteeing that the schedules generated by the
JSP solver are both meaningful and correct. This specification


--- Page 5 ---
IEEE TRANSACTIONS ON AUTOMATION SCIENCE AND ENGINEERING
5
is achieved through contextualized DSL program verification,
based on the DSL programs representing the route sheet.
The working mechanism of this module can be formally
expressed as CGP = (Con | Υ). Here we look into the
resulting route sheets Υ
=
{J , M} from the previous
module. These route sheets outline the production procedure
J = ⟨O1, O2, . . . , O|J|⟩for each target product, detailing
the execution sequence of involved operations. The complete
set of operations from all procedures, denoted as OJ
=
{O1, O2, . . . , O|OJ |}, forms a partially ordered set that in-
dicates the inter-dependency relationships among operations.
If the precondition of Oi, namely the availability of input ma-
terials required for Oi’s execution, includes the postcondition
of Oj, which is the output product following the execution
of Oj, then Oi is dependent on Oj, denoted as dep(Oi, Oj).
Furthermore, an operation Oi must be executed on a specific
machine Mj, represented by the relationship exec(Oi, Mj).
Using the aforementioned notations, we can represent the
underlying JSP for the production scenario with J , M, and
O. To solve the JSP, it is necessary to specify (i) the set
of resource constraints R = {(Oi, Mj) | Oi ∈O, Mj ∈
M, exec(Oi, Mj) = True}; and (ii) the set of precedence con-
straints P = {(Oi, Oj) | Oi, Oj ∈O, dep(Oi, Oj) = True}.
The objectives of the JSP may include maximizing throughput,
minimizing response time, or balancing resource utilization.
As the objective is independent of constraint specification and
thus falls outside the scope of this work, we exclude it from
the problem definition for succinctness. In summary, we define
the constraint generation problem as the task of specifying the
resource and precedence constraints Con = {R, P}, given the
description of procedures and the actual condition of factories.
We specify Con from Υ through DSL program verification,
adapted from the methodology of Shi et al. [38]. The DSL
programs are verified by associating operations with product
flows in a reciprocal manner. Product flow indicates the
transfer of product flow units among operations, reflecting
how one operation influences subsequent ones. The program
verifier traverses the DSL program in execution order, utilizing
the product locality revealed from the actual distribution of
operations and product flow units. This process determines the
reachability and life cycle of product flow units, in accordance
with the theory of compilation introduced by Aho and Ull-
man [47]. For the implementation of the verifier, a Pushdown
Automaton (PDA) with a random access memory is employed
to record reachable product flow units as an operation context,
defining (i.e., the product is produced by certain operations or
the raw material is purchased) and killing (i.e., the product
is consumed by certain operations) product flow units at each
operation point along the computation. During every transition
between operations, the killed products are removed from the
memory, and the defined products are added to it. After a
product flow unit is killed, the pair of operations that defined
it and killed it is added to the set of precedence constraints
P. At each operation point, the pair of the operation and the
machine specified in its execution configuration is added to the
set of resource constraints R. The accepting state of the PDA
is reached if the memory is empty at the end of execution,
meaning all products defined in operations are killed by other
operations. Alongside the deterministic PDA-based verifier,
We employ state-of-the-art LLMs to track and monitor the
two actions of the PDA, kill and define, through instruction-
following in-context learning [48], [49].
The specified constraints, along with the route sheets, are
converted into the input format for the JSP solver, specifically
using the widely adopted OR-Tools JSP solver1. Within the
JSP solver framework, the manufacturing scheduling problem
is modeled as a job shop environment comprising M machines
and N jobs. Each job consists of a series of operations that
may have inter-dependencies and require specific machine
types, as indicated by precedence and resource constraints,
respectively. Each operation must be assigned to a machine
and processed within a specified execution duration, so as to
fulfill the objective of optimizing the overall manufacturing
process [50], [51]. With these parameters, the JSP can be ef-
fectively solved using constraint programming techniques [52],
[53]. The resulting schedules specify the exact time-machine-
operation arrangements for production.
D. Schedule Grounding into Production Plans
The third module converts the schedules generated by
the JSP solver into interpretable production plans within the
factory environment. This module is essential for integrating
off-the-shelf JSP solvers into the entire architecture, as it
involves translating the physical meanings of route sheets and
constraints from their DSL representations into a format com-
patible with the solver’s input. Consequently, it is necessary
to recontextualize the schedules to their physical meanings
for practical application. The execution configurations in the
grounded production plans must match those in the route
sheets, and the execution timing must adhere precisely to the
generated schedules. To ensure reliability, this grounding is
achieved through symbolic DSL program referencing.
The working mechanism of this module can be formally
expressed as SGP = (Exe(J , M) | JSP(Con, Υ)), where
JSP(Con, Υ) denotes the output of the JSP solver. Meanwhile,
Exe(J , M) = ⟨(Oi, Mj, t1), . . . , (Ok, Ml, t|Exe(J ,M)|)⟩de-
notes the grounded production plans that meticulously arrange
operations and machines within the temporal dimension. The
incorporation of timing necessitates that the DSL program
representation comprises a concurrent mechanism [54]. Specif-
ically, an operation must wait to start until all operations
producing the intermediate products required by its precon-
dition have been completed. Given that our DSL, which
adopts the product-flow-centric view, possesses the syntactic
feature to model product-based transitive relationships among
operations, it seamlessly facilitates the interpretation of the
predecessor and successor of a product flow unit as process
locks, serving as a guardrail for the correctness of the produc-
tion plans. Furthermore, the DSL program verifier introduced
in Sec. II-C functions as an additional assurance of correctness.
It traverses the dependency graph to verify the absence of
breakpoints in the product flow along the temporal dimension.
With this dual-guardrail mechanism, we can directly reference
1The JSP solver is implemented using the OR-Tools library, with documen-
tation available at https://developers.google.com/optimization/scheduling.


--- Page 6 ---
IEEE TRANSACTIONS ON AUTOMATION SCIENCE AND ENGINEERING
6
the DSL programs using their semanticless identifiers within
the JSP solver, thereby benefiting from the determinism of
symbolic representations. Subsequently, we can verify the
correctness of the resulting production plans.
III. AUTOMATED ADAPTATION ALGORITHM
In this section, we present the automated production sce-
nario adaptation of the proposed constraint-centric architec-
ture. Initially, we explore the significance of such adaptation
within the manufacturing context (Sec. III-A). We then define
the problem of adapting the desired architecture by means of
DSL design (Sec. III-B; refer to Fig. 2A). Afterwards, we
introduce approaches for the automated design of the DSL
from the operation-centric program view (Sec. III-C; also
refer to Fig. 2A) and the product-flow-centric program view
(Sec. III-D; refer to Fig. 2B) respectively.
A. Why Automated Production Scenario Adaptation?
While it is theoretically possible to automate the entire
workflow described in Sec. II for generating grounded pro-
duction plans, a crucial challenge remains: full automation
is contingent upon the availability of predefined constraint-
centric architectures, i.e., the corresponding DSLs for con-
straint specification. However, the origin of these DSLs poses
a problem, as they are not readily available like off-the-
shelf General-Purpose Languages (GPLs). In current practices,
most DSLs are manually designed through the collaborative
efforts of computer scientists and manufacturing experts, a
process that is both time-consuming and labor-intensive. This
may be acceptable for specific applications requiring only
a single DSL library [55], [56], [57], as DSL design is a
once-and-for-all endeavor there. Unfortunately, from a broader
perspective of the holistic manufacturing community, DSLs for
constraint specification in manufacturing encompass multiple
categories of target products, diverse requirements of the
Original Equipment Manufacturers (OEMs), varied production
environments across factories, and an ever-expanding range
of overall application scenarios. This scenario specificity im-
plies that the distributions of operations, machines, materials,
intermediate products, execution configurations, and inter-
dependency relationships vary significantly among different
scenarios. Although it is conceivable that we could derive a
comprehensive set of language features covering all potential
manufacturing scenarios, namely the so-called one-size-fits-
all general architecture, such an endeavor would result in a
system of prohibitively complexity, rendering it intractable for
both machine and human end-users.
The highly varied and frequently evolving demands for
DSLs are difficult to meet through human effort alone. Even
if we manage to manually craft these DSLs, the advancement
in automated production planning and scheduling would be
compromised. This would merely shift human labor from
one part of the workflow to another, and even potentially
increase the overall labor required. Maintaining a joint cohort
of experienced manufacturing experts and computer scientists
for DSL design at a higher level than the current factory could
prove more costly than simply sustaining experts who work at
the existing factory level. Consequently, we find ourselves in a
dilemma: GPLs, which are easily accessible, are unsuitable for
constraint specification due to their overwhelming complexity,
whereas DSLs, which simplify specialized language features,
inherently lack generalizability across different manufacturing
scenarios. To address this dilemma, rather than waiting for
a universally applicable GPL to emerge, a more practical
solution might involve automating the design of DSLs for
constraint specification. Therefore, the automated production
scenario adaptation of our constraint-centered architecture is
an essential requirement to fully unleash its potential of
usability for the broader manufacturing community.
B. The Production Scenario Adaptation Problem
We conceptualize the problem of the automated adapta-
tion for the constraint-centric architecture within a speci-
fied manufacturing scenario as DAP = ({L∗
o, L∗
p} | Γ′).
The objective is to design a DSL with language features
accommodating both the operation-centric program view L∗
o
and the product-flow-centric program view L∗
p. The input Γ′
constitutes a generalized set of original procedures, which
may either be novel procedures from a recently established
manufacturing scenario or historical procedure data from a
long-standing manufacturing scenario. The prior knowledge
of operations and product flows, represented by p(φ) and
p(ω), includes the fundamental syntax of the field-value struc-
tures and the elementary taxonomies, derived according to
the general commonsense of manufacturing. Specifically, the
problem essentially seeks to fit the joint distribution models
p(φ, ϕ, φprec, φpost, φexec) and p(ω, ωpred, ωsucc, ωprop, ψ), using
Γ′ as the domain-specific corpus, and leveraging the prior
knowledge p(φ) and p(ω).
C. Automated Operation-Centric DSL Design
The key challenge in the automated design of the operation-
centric program view is to aggregate all possible execution
contexts for an operation, and then generalize the contexts to
the interface. If we keep each use case as one single instance
of the interface, which can be in hundreds regarding one
operation, the generalization is meaningless. Since there is no
prior knowledge about the interface in advance, we develop
the algorithm following the idea of non-parametric modeling,
i.e., Dirichlet Process Mixture Model (DPMM), resulting in
flexible identification of interface instances.
As we must handle information coming in different granu-
larities, from interface structures (i.e., the main body describ-
ing the execution of a specific operation within a production
procedure) to values of parameters (i.e., the configuration of
machines and consumption of materials within an operation),
we choose to model the operations in a hierarchical fashion.
Compared with the flattened spectral clustering approach de-
veloped by Shi et al. [40], which compresses all information
of an operation into an embedding vector, our modeling
is competent in considering information at different levels
comprehensively. We carefully adopt the prerequisite that the
interface is generated subject to the operation, preconditions,
postconditions, and execution configurations are generated


--- Page 7 ---
IEEE TRANSACTIONS ON AUTOMATION SCIENCE AND ENGINEERING
7
A
B
Semantic Feature of Operation
Semantic Feature of Product Flow
Syntax of Product Flow Structure
Prior of Product Flow Structure
Automated Design of Semantics
Automated Design of Syntax
 
 ::= Interface_0  
Interface_1
 Interface_0 ::= Precond(
: 
, 
: [
, ...])
Postcond(
: , 
: 
[
, ...])
Execution(
: 
, 
: 
)
Interface_1 ::= ...Execution(
: 
, ...)

rough_milling
SlotArgNum
SlotArg
EmitArgNum
EmitArg
Machine
Duration
Machine
|
1
1
161u
broached_c
machined_c
Vertical_Milling_M
Horizontal_Milling_M
lathed_part
FlowUnit
ComponentType
UnitArgType
Vol
Container
Cond
Iron_content
Temperature
Status
 ::= 
 <
> 
  
  
 
 
  ... 
FlowUnit(
: 
, 
: 
, 
: [
, 
, 
, 
, 
], 
: 
, <
>)
Cond(
: [
, 
], 
: range(
, 
), 
: 
)...

lathe
broaching
milling
rough_milling
refined_milling
Metal
conveyor_belt
parted
|
|
|
|
PROD
0.01m
0.05m
0.1m
0.5m
1m
50%
80%
80°C
150°C
Domain_#4
Pred_1
FlowUnit_1
Succ
Pred_2
FlowUnit_2
Succ
Pred
FlowUnit
Succ
Pred
FlowUnit_1
Succ_1
Pred
FlowUnit_2
Succ_2
 ::= ((
: 
, 
: (...), 
: 
), 
(
: 
, 
: (...),  
: 
)) 
(
: ..., 
: ..., 
: 
...)
 ((
: ..., 
: ..., 
: ...), (
: ..., 
: ..., 
: ...))
broaching
drilling
hobbing
drilling
| 
|
<
> ::= 
<
> <
> 
 <
> <
> <
> 
 <>

<
> ::= 
<
> <
> 
 <
> <
> <
> 
 <>
PredStructure
|
PredStructure
|
SuccStructure
|
SuccStructure
|
Pred
FlowUnit
Pred
FlowUnit
Succ
FlowUnit
Succ
FlowUnit
#1 
 Itfc1, Itfc2, ...
#2 
  Itfc1, Itfc2, ...
LATHE
MILLING
#1 
 Sample1, Sample2, ...
#2 
  Sample3, Sample4, ...
LATHE
MILLING
Spectrum of Interfaces
Non-parametric Modeling
Domain Ontology 
from the Orders
Samples with Semantic Identifiers 
#1 
 
LATHE
#2 
 
MILLING
Prior Syntax Model
E-Step (Bottom-Up)
M-Step (Top-Down)
...
...
#1 
 
LATHE #2 
 
MILLING
Fig. 2. Illustration of the algorithms for the automated production scenario adaptation of the architecture. (A) This diagram illustrates the framework
of non-parametric modeling for the automated design of semantic features within both operation-centric and product-flow-centric program view DSLs. (B)
This diagram depicts the framework of the EM algorithm for the automated design of syntactic features within product-flow-centric program view DSL.
subject to the interface, and the value of configuration pa-
rameters, denoted as φexec-v, are generated subject to their
corresponding fields. Thus, we have the model
p(φ, ϕ, φprec, φpost, φexec, φexec-v)
=p(φexec-v | φ, ϕ, φexec)p(φexec | φ, ϕ)p(φprec | φ, ϕ)
p(φpost | φ, ϕ)p(ϕ | φ)p(φ).
(3)
Within each iteration of the DPMM process, we sample the
variables level-by-level. Since the structures of preconditions,
postconditions, and the selection of devices and configuration
parameters are discrete, we sample them directly from the
Dirichlet Process (DP). As permissible values of parameters
can be discrete, e.g., an array of specific values, common
in temperature preparation; continuous, e.g., an interval with
minimum and maximum values, common in power setting; or
mixed, e.g., an array of specific values with random perturba-
tions around the mean, common in tooling accuracy control,
we conduct the sampling by integrating Gaussian Process (GP)
with DP, obtaining
φexec-v | φ, ϕ, φexec
∼DP(α, H(φexec), ϕ, φ) × GP(m, K),
(4)
where α, H, m, and K are corresponding hyperparameters.
While clustering similar interface instances aggregates tar-
get operations, there may remain redundant interfaces due to
minor discrepancies. These discrepancies often arise from dif-
ferences in parameter values or naming conventions that do not
fundamentally alter the operation’s functionality. To alleviate
such redundancies, we implement a unification process for
the interfaces. Specifically, interface instances associated with
the same operation are considered equivalent if they have the
same number of slots and emits, and share the same fields
in their execution configuration parameters. By abstracting
away differences in parameter values and names, we unify
these interfaces into a single, generalized interface, akin to
the algorithm proposed by Martelli et al. [58]. Unification
enhances the generality of the operation-centric program view
by consolidating functionally-identical interfaces, maintaining
a concise and representative set of operations.
D. Automated Product-Flow-Centric DSL Design
One of the primary challenges in the automated design of
the product-flow-centric program view lies in selecting proper
descriptive properties of a product flow unit component. There
exists false positive cases, where properties are attributed to
components with the same semantic identifier but in different
phases, e.g., we consider Aluminum Alloy with the property
dimensions when it comes in flake and with the property vol-
ume when it comes in powder. There also exists false negative
cases, where exact same components are regarded as different
ones due to different reference names, e.g., Aluminum Sheet,
6061 Alloy Plate, and Metal Sheet can refer to the same thing.
To alleviate false positive and false negative results, we discard
the design choice of the interface in the operation-centric view,
which tends to cover the possibly richest context, and thereby
have the non-parametric model
p(ω, ωpred, ωsucc, ωprop, ωprop-v)
=p(ωprop-v | ωprop, ω)p(ωprop | ω)
p(ωpred | ω)p(ωsucc | ω)p(ω),
(5)
where ωprop-v denotes the values of property parameters. The
challenges in building up this model and the corresponding
strategies are similar to those in Sec. III-C.
The other primary challenge in the automated design
of
the
product-flow-centric
program
view
is
construct-
ing the model of ψ. This model is not captured by
p(ω, ωpred, ωsucc, ωprop, ωprop-v), yet it remains crucial for com-
pleting the design of Sp. Leveraging existing knowledge on
programming language design, our method utilizes a bidirec-
tional optimization strategy to formulate the most appropriate
flow-structure-syntax ψ∗∈S∗
p of the target DSLs, ensuring
that it compactly satisfies the characteristics dictated by Γ′.


--- Page 8 ---
IEEE TRANSACTIONS ON AUTOMATION SCIENCE AND ENGINEERING
8
Inspired by the methodology introduced in Shi et al. [40], the
algorithm utilizes an Expectation-Maximization (EM) frame-
work, where the E-Step abstracts syntax from Γ′ and the M-
Step derives syntax from programming language principles.
The algorithm models latent syntactic constraint assign-
ments Z = {z1, . . . , z|Γ′|} for each procedure γ ∈Γ′. A
filter set Θ = {θ1, . . . , θ|Z|}, is designed to determine if a
segment of procedure description, i.e., a local set of product
flow units with predecessor and successor operations, aligns
with the N-predecessors-to-M-successors relationships within
the product flow, coming with the belief function p(Θ|ψ). The
observational likelihood is computed as
p(Γ′ | Z, Θ) =
Γ′
Y
i=1
p(γi | zi, θzi).
(6)
Hence, the overall joint distribution of the model is given by
p(Γ′, Z, Θ | ψ) = p(Γ′ | Z, Θ)p(Z | ψ)p(Θ | ψ).
(7)
Programming language designers leverage a general set of
syntactic production rules as the prior p(Z | ψ) for syntax
specification. Following this common practice, we initialize ψ
with the recursive grammar
PredS ::= ⟨ωpred⟩⟨ωprop⟩| ⟨ωpred⟩PredS ⟨ωprop⟩| ⟨⟩,
SuccS ::= ⟨ωsucc⟩⟨ωprop⟩| ⟨ωsucc⟩SuccS ⟨ωprop⟩| ⟨⟩, (8)
where ⟨ωpred⟩PredS ⟨ωprop⟩and ⟨ωsucc⟩SuccS ⟨ωprop⟩are
recursion bodies. This recursive grammar accommodates hy-
potheses involving arbitrary N-predecessors-to-M-successors
relationships, naturally beginning with the simplest linear
structure and progressively increasing in complexity. Addi-
tionally, we construct the prior belief function p(Θ | ψ) with
a series of sliding-window-based filters f : Γ′ 7→R. This
approach provides a relaxed lower bound for predicting the
existence of an atomic product-flow structure.
In each E-Step, we obtain the posterior of latent variables
p(Z | Γ′, Θ, ψ) applying Bayes’ theorem, which is imple-
mented by scanning the filters over all procedure descriptions
in Γ′. To note, as the spaces of prior and observation are not
intractably large, we simply employ the naive version of E-
Step without variational approximations.
In each M-Step, we first maximize the coverage of the
sampled atomic structure ψ by maximizing
Q(ˆΘ, Θ) = EZ|Γ′,Θ

log p(Γ′, Z, ˆΘ | ψ)

,
(9)
where ˆΘ is the updated Θ, resulting in the structural change
of ψ. These two steps alternate iteratively until convergence,
ensuring the syntactic features are aligned with the scenario.
IV. EXPERIMENTAL SETUPS
In this section, we describe the experimental setups of
this study. We first introduce the datasets for experimenta-
tion (Sec. IV-A) and the baseline approaches for evaluation
(Sec. IV-B). Afterwards, we describe the protocols for the
five experiments, including the complete pipeline experiment
(Sec. IV-C), three experiments validating the three modules of
our constraint-centric architecture (Secs. IV-D to IV-F), and
the production scenario adaptation experiment (Sec. IV-G).
A. Datasets for Experimentation
The scarcity of datasets that closely replicate real-world
manufacturing environments significantly hinders the evalu-
ation of our constraint-centric architecture. To bridge this gap,
we propose the augmentation of existing datasets with syn-
thetic data, ensuring the retention of realistic elements in the
process. This approach involves the utilization of ten classical
JSPs sourced from well-established Operations Research (OR)
literature [59], [60], [61], [62], [63], [64], [65], [66], [67],
[68]. These JSPs, originally comprising only machine IDs and
durations, serve as the foundation for our dataset enhancement.
To transform abstract JSP descriptions into comprehensive
datasets, we employ a cutting-edge LLM2, which extends
the sparse JSP data by generating detailed production pro-
cedure descriptions and semi-structured route sheets in NL.
This transformation aligns the synthetic data with the style
and complexity of realistic production procedures, thereby
enhancing the practical value of the augmented dataset.
The augmentation process begins with a dependency graph
traversal to ascertain the global dependency set across an array
of device types. This step is crucial for understanding the inter-
dependency relationships and operation sequences within the
manufacturing setup. Subsequently, a mapping arrangement is
established between the machine IDs and the corresponding
devices. Each JSP is treated as a distinct production scenario
requiring a DSL for accurate constraint specification. The
dependency set for each machine arrangement is meticulously
configured to be a superset of the JSP’s dependency set,
adhering to an initial assumption of ordered and linear job de-
pendencies. Non-monotonic dependencies (i.e., circular steps)
are identified and eliminated to prevent operational conflicts.
Following the establishment of device mappings and depen-
dency configurations, the generation of synthetic data begins.
This phase involves the specification of materials, products,
and the execution configurations of devices. Through this data
synthesis process, we obtain a dataset that not only reflects the
complexity of real-world manufacturing tasks but also serves
as a controllable probe for the three respective modules within
our architecture and its baseline counterparts. This supports
our experimental setups, enabling a thorough evaluation of our
system’s performance across various scenarios. It illustrates
that our approach effectively harnesses the advantages of both
GenAI techniques and DSL-based structural representation,
thereby achieving a balance between the capability of gen-
eration and the guardrail of reliability [69].
B. Baseline Approaches
To establish a robust evaluation framework, we imple-
ment two alternative approaches based on state-of-the-art
methods for formalizing NL-described optimization problems
with LLM prompt engineering techniques [23], [22]. These
approaches, termed MULTI-STAGE-LLM (MSL) and TWO-
STAGE-LLM (TSL), serve as baselines to benchmark the
utility of our proposed constraint-centric architecture (Ours).
2We use the OpenAI GPT-4o model for this purpose.


--- Page 9 ---
IEEE TRANSACTIONS ON AUTOMATION SCIENCE AND ENGINEERING
9
The MSL approach adopts a three-module-sequence that
mirrors the structural alignment of our constraint-centric archi-
tecture, facilitating a direct comparative analysis. Initially, the
workflow transforms NL-based descriptions or semi-structured
route sheets into fully structured route sheets. Subsequently,
the fully structured route sheets are converted into matrices,
in a format matchable for the JSP solver. The final module
integrates the schedules generated by the JSP solver with the
fully structured route sheet, and then grounds these schedules
into interpretable production plans. All of these three modules
are implemented by LLM prompt engineering. 3
In contrast to the MSL, the TSL approach simplifies the
workflow by reducing the number of transformation stages,
potentially increasing computational efficiency but at the risk
of reduced fidelity in the constraint translation process. The
first stage bypasses the separate structuring step of the route
sheet and directly converts the NL-based descriptions or semi-
structured route sheets into JSP solver formatted matrices.
The second stage involves the integration of the JSP-generated
schedules with the input procedures, and then grounds these
integrated schedules into finalized production plans. Both
modules are implemented by LLM prompt engineering.
C. Protocol for the Complete Pipeline Evaluation
The major objective of this experiment is to validate the
utility of our constraint-centric architecture within realis-
tic manufacturing scenarios. This experiment is critical in
demonstrating the practical utility of our approach as the
primary outcome of this study. The experimental protocol
involves a comparative analysis of Ours against two baseline
approaches, MSL and TSL. These methods are evaluated
across ten realistic manufacturing scenarios as detailed in
Sec. IV-A. To ensure a fair comparison, the base LLM model
for all three approaches is kept identical. The input to these
pipelines consists of procedures described either in NL or as
semi-structured route sheets. We keep the proportion of both
input forms identical throughout the experiment. The output
from each system is formatted into JSON-style scripts, which
align with the script formats used for CNC system execution,
allowing for a standardized method of comparison.
The evaluation of these scripts is conducted using the Exact
Match of Key-Value Pairs (EMKVP) and Bilingual Evaluation
Understudy (BLEU) metrics, which are well-established in the
literature for assessing the quality of procedural knowledge
representation and information retrieval [70], [71], against
the ground truth production plans derived from the synthetic
dataset under the supervision of manufacturing experts. Given
that direct comparisons using cosine similarity score across
entire sentences could lead to inaccuracies due to semantic
discrepancies in similar-looking instructions, we adopt a more
granular approach. By converting all results into a standardized
JSON-style format, comparisons are made between field-value
pairs rather than entire sentences using the EMKVP metric.
Meanwhile, procedure-level consistencies are assessed through
the BLEU metric. This hybrid method effectively alleviates
concerns related to the metrics by focusing either only on
3We implement these LLMs with the OpenAI GPT-4o model.
the precision and accuracy of specific data elements or only
on overall textual similarity. Furthermore, the results are
quantitatively analyzed using three specific variants of the
EMKVP metric: Precision, Recall, and F1 Score. EMKVP-
Precision measures the proportion of correct field-value pairs
among all specified pairs, providing insight into the accuracy
of the resulting production plans. EMKVP-Recall assesses
the proportion of correctly specified field-value pairs out
of all pairs that should have been specified, reflecting the
completeness of the information captured. Lastly, EMKVP-F1
Score combines both precision and recall to offer a balanced
view of overall performance.
D. Protocol for the Constraint Abstraction Evaluation
The primary objective of this experiment is to validate
the effectiveness of the constraint abstraction module (CAM)
within our constraint-centric architecture. This module is cru-
cial for ensuring that ambiguities in NL parsing are managed
effectively and that the precision required for fine-grained pro-
cedural knowledge representation is maintained. By isolating
this component, we aim to demonstrate the indispensable role
of DSLs as mechanisms that guide and regulate the behavior
of LLMs within our system. The experimental setup involves
using identical input data as employed in the complete pipeline
experiment. The outputs generated from this input are fully-
structured route sheets, which are subsequently transformed
into JSON format for consistency and ease of analysis. This
standardized format allows for direct comparison between
the outputs from the CAM of Ours (Ours-CAM) and those
from the first module of MSL (MSL-I). Similar to Sec. IV-C,
the evaluation metrics include BLEU, EMKVP-Precision,
EMKVP-Recall, and EMKVP-F1. These metrics are chosen
for their ability to quantitatively measure the consistency
between the resulting route sheets and the groundtruth fully-
structured route sheets derived from synthetic data under the
supervision of manufacturing experts.
E. Protocol for the Constraint Generation Evaluation
The primary objective of this experiment is to validate the
utility of the constraint generation module (CGM) within our
constraint-centric architecture. This module is significant for
ensuring the correctness of the constraints for JSP formulations
and for converting these constraints into a format compatible
with JSP solvers without any loss of information.
We have designed two versions of this experiment. The
first version assesses the CGM in Ours (Ours-CGM) and the
second module in MSL (MSL-II) to highlight the critical
role of DSL program verification over the dual-program-view
representation. This approach is instrumental in capturing the
relationships between operations and machines, as well as
among operations, in both Ours and MSL. The second version
tests the integration of the first two modules, CAM & CGM,
to explore the trade-offs involved in using two sequential
modules with accumulated error transmission between them
(i.e., Ours-CAM-CGM and MSL-I-II) versus employing a
single module without an explicit fully-structured route sheet
as an intermediate result to work with (i.e., TSL-I). For the


--- Page 10 ---
IEEE TRANSACTIONS ON AUTOMATION SCIENCE AND ENGINEERING
10
CGM-only version, we use the groundtruth fully-structured
route sheet as the input for both Ours-CGM and MSL-II to
eliminate accumulated errors and truly isolate the CGM. For
the CAM & CGM version, we use the same input as in the
complete pipeline experiment for Ours-CAM-CGM, MSL-I-II,
and TSL-I. The output for both versions is the set of constraint
generation matching the input format of the JSP solver.
Given that the scheduling optimization method used in the
JSP solver is deterministic, it is unnecessary to assess the
correctness of the schedules generated by the JSP solver.
Therefore, we adhere to established literature on benchmarking
the formalization of NL-described optimization [21], incor-
porating three evaluation metrics: constraint-level accuracy
(Constraint-Acc), compiler error rate (Compiler-ER), and run-
time error rate (Runtime-ER). Constraint-Acc is calculated
using the Intersection over Union (IoU) metric between the
specified constraints and the groundtruth constraints, encom-
passing both resource and precedence constraints. This metric
indicates the consistency between the intended procedures and
the interpretations by the pipelines. Both Compiler-ER and
Runtime-ER concern the interactions between the pipeline and
the JSP solver. The former captures the proportion of testing
procedures that fail to compile in the JSP solver, potentially
due to syntactic-level issues in the formatted set of constraints
provided as input. The latter measures the proportion of testing
procedures encountering errors during the execution of the
JSP solver, which are caused by semantic-level errors in the
formatted set of constraints, such as internal logic errors,
unsolvable models, or non-linear constraints.
F. Protocol for the Schedule Grounding Evaluation
The major objective of this experiment is to validate the
usefulness of the schedule grounding module (SGM) within
our constraint-centric architecture. This module is essential
for ensuring the accurate recovery of fine-grained procedure
knowledge from the semantically void schedules produced
by the JSP solver. By isolating this component, we aim
to demonstrate the pivotal role of the DSL dual program
view in managing the concurrent programming nature of the
grounded production plans. We input the groundtruth specified
set of constraints into the JSP solver to obtain the schedule.
This schedule, which remains consistent across different runs,
serves as the input for the SGM in Ours (Ours-SGM), the third
module of MSL (MSL-III), and the second module of TSL
(TSL-II). The outputs generated from this input are grounded
production plans, which are subsequently converted into JSON
format for consistency and ease of analysis. This standardized
format facilitates direct comparison across the three pipelines.
Consistent with Sec. IV-C, the evaluation metrics include
BLEU, EMKVP-Precision, EMKVP-Recall, and EMKVP-F1.
These metrics are selected for quantitatively assessing the
consistency between the resulting production plans and the
same ground truth used in the complete pipeline experiment.
G. Protocol for the Automated Adaptation Evaluation
The primary objective of this meta-study experiment, build-
ing upon the previous experiments, is to evaluate the scalability
of our constraint-centric architecture across various manufac-
turing scenarios. This characteristic is central to the broader
impact of our architecture on the entire manufacturing commu-
nity, as it results from a trade-off between compromised gen-
erality and enhanced domain-specificity—the generalizability
is thus alternatively amortized by the automated production
scenario adaptation capability, as discussed in Sec. III-A.
This meta-study comprises two components. The first in-
volves observing the convergence of our algorithms for auto-
mated adaptation across the ten selected production scenarios.
Each of the ten testing groups is initialized without any
external prior knowledge, except for what is already integrated
into the algorithms, such as the syntactic prior of recursion.
The algorithms in these ten groups are expected to perform
uniformly well, without case-specific bias. With these auto-
matically designed DSLs tailored for each scenario, the second
component involves validating the utility of the scenario-
adapted architecture driven by the corresponding DSL for each
scenario. This includes all previous experiments, such as the
complete pipeline experiment and the three experiments on the
individual modules of our architecture. It is expected that these
experiments will not exhibit significant differences across the
various scenarios. In addition, we utilize the Variance-to-Mean
Ratio (VMR) metric, which is suitable for one-approach-
multiple-domain evaluation [72], to evaluate the quantitative
results of Ours, MSL, and TSL across the ten scenarios. This
metric, where higher values are more desirable, reflects the
simultaneous achievement of both outstanding and consistent
performance across the different scenarios.
V. RESULTS AND DISCUSSIONS
In this section, we analyze the results of the five experiments
described in Sec. IV and discuss the insights revealed by them,
including the complete pipeline experiment (Sec. V-A), three
experiments validating the utilities of the three modules of
our constraint-centric architecture (Secs. V-B to V-D), and the
production scenario adaptation experiment (Sec. V-E).
A. The Complete Pipeline Evaluation
Through paired samples t-test, we find that Ours signifi-
cantly outperforms the alternative approaches MSL and TSL
across the four evaluation metrics (Ours outperforms MSL,
measured by BLEU: t(18) = 47.448, µd < 0, p < .0001;
measured by EMKVP-Precision: t(18) = 39.143, µd < 0, p <
.0001; measured by EMKVP-Recall: t(18) = 39.528, µd <
0, p < .0001; measured by EMKVP-F1: t(18) = 46.215, µd <
0, p < .0001; Ours outperforms TSL, measured by BLEU:
t(18) = 60.806, µd < 0, p < .0001; measured by EMKVP-
Precision: t(18) = 15.003, µd < 0, p < .0001; measured by
EMKVP-Recall: t(18) = 7.071, µd < 0, p < .0001; measured
by EMKVP-F1: t(18) = 9.891, µd < 0, p < .0001; see
Fig. 3A). These comparisons demonstrate the suitability of
our architecture for constraint specification. In addition, we
find that the baseline approach equipped with an explicit fully-
structured route sheet as an intermediate workspace (i.e., MSL)
outperforms its counterpart without such workspace (i.e., TSL)
(measured by BLEU: t(18) = 13.612, µd < 0, p < .0001;


--- Page 11 ---
IEEE TRANSACTIONS ON AUTOMATION SCIENCE AND ENGINEERING
11
B
****
0.0
0.5
1.0
Ours
MSL
TSL
EMKVP−Precision
****
****
0.0
0.5
1.0
Ours
MSL
TSL
BLEU
****
0.0
0.5
1.0
Ours
MSL
TSL
EMKVP−Recall
****
****
0.0
0.5
1.0
Ours
MSL
TSL
EMKVP−F1
****
****
0.0
0.5
1.0
Ours
MSL
TSL
EMKVP−Recall
A
****
Fig. 3. Results of the complete pipeline evaluation. (A) Comparison of Ours with MSL and TSL across four evaluation metrics over ten scenarios. (B)
Showcases of the grounded production plans generated by Ours, MSL, and TSL, respectively.
***
0.0
0.5
1.0
Ours−CAM
MSL−I
BLEU
****
0.0
0.5
1.0
Ours−CAM
MSL−I
EMKVP−F1
***
0.0
0.5
1.0
Ours−CAM
MSL−I
EMKVP−Recall
*
0.0
0.5
1.0
Ours−CAM
MSL−I
EMKVP−Precision
A
B
Fig. 4. Results of the constraint abstraction evaluation. (A) Comparison of Ours-CAM with MSL-I across four evaluation metrics over ten scenarios. (B)
Showcases of the fully-structured route sheets generated by Ours-CAM and MSL-I, and TSL, respectively.
measured by EMKVP-Precision: t(18) = 5.873, µd < 0, p <
.0001; see Fig. 3A). Looking into the resulting production
plans, we find that Ours effectively captures fine-grained exe-
cution configurations, such as the “feed rate” and “tool type”.
In contrast, MSL partially fails to capture this information, and
TSL fails entirely. Among the three approaches, only Ours
accurately maintains the consistency between start time, end
time, and duration. The pure LLM-based counterparts even
make errors in this aspect, and TSL generates production plans
that are irrelevant. These observations are illustrated by the
examples presented in Fig. 3B.
B. The Constraint Abstraction Evaluation
Through paired samples t-test, we find that Ours-CAM sig-
nificantly outperforms the alternative approach MSL-I across
the four evaluation metrics (measured by BLEU: t(18) =
6.487, µd < 0, p < .0001; measured by EMKVP-Precision:
t(18) = 2.481, µd < 0, p < .05; measured by EMKVP-Recall:
t(18) = 7.342, µd < 0, p < .0001; measured by EMKVP-F1:
t(18) = 28.851, µd < 0, p < .0001; see Fig. 4A). Notably,
the EMKVP-Precision of MSL-I may be distorted to a certain
extent due to its correspondingly low recall—many fields


--- Page 12 ---
IEEE TRANSACTIONS ON AUTOMATION SCIENCE AND ENGINEERING
12
****
0.0
0.5
1.0
Ours−CGM
MSL−II
Constraint−Acc
0.0
0.5
1.0
Ours−CGM
MSL−II
Runtime−ER
0.0
0.5
1.0
Ours−C.C.
MSL−I−II
TSL−I
Constraint−Acc
0.0
0.5
1.0
Ours−C.C.
MSL−I−II
TSL−I
Runtime−ER
A
B
C
D
Fig. 5.
Results of the constraint generation evaluation. (A) Comparison of Ours-CGM with MSL-II across the evaluation metrics Constraint-Acc and
Runtime-ER over ten scenarios, within the isolated version of the experiment. Results for Compiler-ER are not visualized because the error cases are minor
and consistent across the baseline approaches. Consequently, we have omitted the corresponding plots for the sake of brevity. This design choice aligns with
the discussion by Xiao et al. [23]. (B) Comparison of Ours-CAM-CGM with MSL-I-II and TSL-I across two evaluation metrics over ten scenarios, within the
incorporated version of the experiment. (C) Gantt chart visualizations of the JSP-solver-generated schedules, derived from the specified constraints, as generated
by Ours-CGM and MSL-II, respectively. The Gantt chart visualization effectively illustrates the differences in modeling fidelity of the JSP specification across
three approaches. The y-axis represents the various machine types involved in production, revealing that schedules derived from the baseline approaches utilize
fewer machines, primarily due to the absence of resource constraints. The x-axis depicts the total production duration, showing that the baseline approaches
generate shorter time horizons, likely resulting from omissions in the specification of steps, operations, or machines—a consequence of lacking both resource
and precedence constraints. The occupied area within the chart indicates the total machine occupation time. Notably, our approach’s schedule contains more
unoccupied areas, demonstrating that more machines must remain idle due to procedural requirements—this clearly illustrates that precedence constraints are
modeled with greater precision in Ours compared to the baselines. (D) Gantt chart visualizations of the JSP-solver-generated schedules, derived from the
specified constraints, as generated by Ours-CAM-CGM, MSL-I-II, and TSL-I, respectively. Applying the same criteria as (C), the JSP specification modeled by
the two baseline approaches demonstrates reduced fidelity, primarily attributable to their failure to incorporate resource constraints and precedence constraints.
remain unspecified, thus significantly limiting the set of field-
value pairs available for evaluation and excluding a substantial
number of false negative samples from consideration. These
comparisons demonstrate the capability of Ours-CAM for NL
parsing and fine-grained procedural knowledge representation.
Upon examining the resulting route sheets, we observe that
Ours-CAM effectively captures fine-grained execution config-
urations, surpassing MSL-I in this regard. This achievement
lays a robust foundation for subsequent processing. These
observations are exemplified by the cases presented in Fig. 4B.
C. The Constraint Generation Evaluation
In the isolated version of the experiment, through paired
samples t-test, we find that Ours-CGM significantly out-
performs MSL-II on the Constraint-Acc metric (t(18) =
11.072, µd < 0, p < .0001; see Fig. 5A). These results
support that Ours-CGM excels constraint generation through
DSL program verification over the dual program views.
In the incorporated version of the experiment, through
paired samples t-test, we find that Ours-CAM-CGM sig-
nificantly outperforms the alternative approaches MSL-I-II
and TSL-I across the three evaluation metrics (Ours-CAM-
CGM outperforms MSL-I-II, measured by Constraint-Acc:
t(18) = 30.201, µd < 0, p < .0001; measured by Runtime-
ER: t(18) = −19.562, µd < 0, p < .0001; Ours-CAM-CGM
outperforms TSL-I, measured by Constraint-Acc: t(18) =
30.201, µd
<
0, p
<
.0001; measured by Runtime-ER:
t(18)
=
−19.562, µd
<
0, p
<
.0001; see Fig. 5B).
These comparisons suggest that, despite the accumulated
errors transmitted between the sequential modules of Ours-
CAM-CGM, the benefits conferred by the explicit, structural
intermediate workspace architecture outweigh the drawbacks
of the cumulative errors, which are mitigated by TSL-I. An
examination of the schedules produced by the JSP solvers
reveals that the baseline approaches fail to accurately specify
neither resource nor precedence constraints. This inadequacy
results in schedules characterized by a high rate of task loss
and unreliable dependency relationships, as depicted in the
Gantt charts displaying decreased thread rows and job blocks
(see Fig. 5C for Ours-CGM vs. MSL-II; see Fig. 5D for Ours-
CAM-CGM vs. MSL-I-II vs. TSL-I). The higher Runtime-
ER observed in the baseline models corroborates this issue,
as evidenced by the substantial presence of “undefined” and
“null” values in their formatted constraints. These findings
substantiate the rationale underpinning the design of our DSL-
based constraint-centric architecture against pure LLMs.


--- Page 13 ---
IEEE TRANSACTIONS ON AUTOMATION SCIENCE AND ENGINEERING
13
****
****
0.0
0.5
1.0
Ours−SGM
MSL−III
TSL−II
BLEU
****
***
0.0
0.5
1.0
Ours−SGM
MSL−III
TSL−II
EMKVP−F1
****
****
0.0
0.5
1.0
Ours−SGM
MSL−III
TSL−II
EMKVP−Precision
****
**
0.0
0.5
1.0
Ours−SGM
MSL−III
TSL−II
EMKVP−Recall
Fig. 6. Results of the schedule grounding evaluation. This figure presents the comparison of Ours-SGM with MSL-III and TSL-II across four evaluation
metrics over ten scenarios.
−3
−2
−1
0
1
10
100
Iteration
Log Likelihood
Domain ta71
Domain ta72
Domain ta73
Domain ta74
Domain ta75
Domain ta76
Domain ta77
Domain ta78
Domain ta79
Domain ta80
Operation DSL Semantics
0.0
0.1
0.2
0.3
0
25
50
75
100
Iteration
Probability Update
Domain ta71
Domain ta72
Domain ta73
Domain ta74
Domain ta75
Domain ta76
Domain ta77
Domain ta78
Domain ta79
Domain ta80
Product−flow DSL Syntax
C
A
0.3
0.4
0.5
0.6
Domain ta71
Domain ta72
Domain ta73
Domain ta74
Domain ta75
Domain ta76
Domain ta77
Domain ta78
Domain ta79
Domain ta80
Complete Pipeline Evaluation across Domains
B
Fig. 7.
Results of the production scenario adaptation evaluation. (A) Convergence curve of the non-parametric model for the automated design of
semantic features within operation-centric program view DSLs. (B) Convergence curve of the EM algorithm for the automated design of syntactic features in
product-flow-centric program view DSL. (C) Comparison of Ours with MSL and TSL on ten scenarios respectively integrating the four evaluation metrics.
D. The Schedule Grounding Evaluation
Through paired samples t-test, we find that Ours-SGM
significantly outperforms the alternative approaches MSL-
III and TSL-II across the four evaluation metrics (Ours-
SGM outperforms MSL-III, measured by BLEU: t(18) =
58.332, µd < 0, p < .0001; measured by EMKVP-Precision:
t(18) = 42.726, µd < 0, p < .0001; measured by EMKVP-
Recall: t(18) = 36.001, µd < 0, p < .0001; measured by
EMKVP-F1: t(18) = 43.236, µd < 0, p < .0001; Ours-
SGM outperforms TSL-II, measured by BLEU: t(18) =
79.089, µd < 0, p < .0001; measured by EMKVP-Precision:
t(18) = 8.705, µd < 0, p < .0001; measured by EMKVP-
Recall: t(18) = 3.422, µd < 0, p < .01; measured by
EMKVP-F1: t(18) = 5.273, µd < 0, p < .0001; see Fig. 6A).
These comparisons highlight the effectiveness of Ours-SGM
in schedule grounding, particularly through the dual program
view of the DSL in managing the concurrent programming
nature of grounded production plans. In contrast, even when
provided with groundtruth schedules, the baseline approaches
perform poorly in maintaining consistency among start time,
end time, and duration, let alone their effectiveness on address-
ing the issue of occupation caused by product transitions.
E. The Automated Adaptation Evaluation
In the first component of this meta-study, we present the
trends observed from the behaviors of the automated design
algorithms. The automated design algorithm of both operation-
centric and product-flow-centric program view DSL semantics
converges on ten scenarios respectively, as illustrated by the
likelihood curve yielded by the non-parametric model in
Fig. 7A. The automated design algorithm of product-flow-
centric program view DSL syntax converges on ten scenarios
respectively, as illustrated by the likelihood curve generated by
the EM in Fig. 7B. Given the case-specificity, the automated
design algorithms effectively tailor the resulting DSLs to align
closely with the characteristics of their respective scenarios.
These algorithms adeptly capture the unique language features
inherent to each scenarios, preserve the common ones, and
prune out those deemed unnecessary.
In the second component of this meta-study, the null hypoth-
esis posits that the performance of Ours in uncorrelated with
the choice of scenario. Utilizing the Kruskal-Wallis H-Test, we
determine that the null hypothesis should be accepted based on
the complete pipeline experiment (H(9) = 2.605, p = .978;
see Fig. 7C). This indicates a lack of evidence supporting a
correlation between performance and scenario. Furthermore,
we observe that the results from Ours demonstrate a high
mean and low variance, resulting in a trend where the VMR
of Ours significantly surpasses that of TSL but does not
significantly exceed that of MSL. This is because a substantial
portion of MSL’s results exhibit both low mean and low
variance, whereas TSL’s results display both low mean and
high variance, indicating a greater degree of uncertainty. This
difference of uncertainty aligns with the insights derived from
the route sheet as an intermediate workspace. These results
suggest that our constraint-centric architecture delivers both
exceptional and consistent performance across various scenar-
ios, thereby meeting the requirements of the manufacturing
community. The findings further reveal the potential of our
architecture to democratize the automatic, entire-workflow
constraint specification for production planning and scheduling
for all manufacturing practitioners, ranging from OEMs to
Small and Medium-sized Enterprises (SMEs).
VI. CONCLUSION
This paper addresses the critical challenge of automat-
ing constraint specification from heterogeneous raw data in
smart manufacturing by introducing a constraint-centric ar-
chitecture that effectively regulates LLMs through domain-
specific representations. Our three-level hierarchical structure


--- Page 14 ---
IEEE TRANSACTIONS ON AUTOMATION SCIENCE AND ENGINEERING
14
successfully balances the generative capabilities of LLMs
with manufacturing reliability requirements. The automated
adaptation algorithm enables efficient customization across
different production scenarios, making the architecture broadly
applicable for various manufacturing practices. Experimental
results demonstrate the architecture’s superiority over pure
LLM-based approaches in maintaining precision while re-
ducing reliance on human expert intervention. This work
advances the practical implementation of smart manufacturing
by providing a robust framework for automated constraint
specification that meets the demands of modern production
environments. Future research could explore the architecture’s
adaptation boundary to more complex manufacturing scenarios
and its integration with other smart manufacturing systems.
ACKNOWLEDGMENT
Q. Xu is a visiting student at Peking University from
University of Science and Technology of China. The authors
would like to thank Jiawen Liu for the assistance in figure
drawing and the reviewers for insightful suggestions.
REFERENCES
[1] A. Kusiak, “Smart manufacturing,” International Journal of Production
Research, vol. 56, no. 1-2, pp. 508–517, 2018.
[2] C. J. Conti, A. S. Varde, and W. Wang, “Human-robot collaboration
with commonsense reasoning in smart manufacturing contexts,” IEEE
Transactions on Automation Science and Engineering, vol. 19, no. 3,
pp. 1784–1797, 2022.
[3] E. C. Balta, M. Pease, J. Moyne, K. Barton, and D. M. Tilbury,
“Digital twin-based cyber-attack detection framework for cyber-physical
manufacturing systems,” IEEE Transactions on Automation Science and
Engineering, vol. 21, no. 2, pp. 1695–1712, 2023.
[4] L. Chen, Z. Lu, A. Xiao, Q. Duan, J. Wu, and P. C. Hung, “A resource
recommendation model for heterogeneous workloads in fog-based smart
factory environment,” IEEE Transactions on Automation Science and
Engineering, vol. 19, no. 3, pp. 1731–1743, 2022.
[5] J. J. Browne, D. Dubois, K. Rathmill, S. Sethi, and K. Stecke, “Classi-
fication of flexible manufacturing systems,” The FMS magazine, vol. 2,
no. 2, pp. 114–117, 1984.
[6] H.-H. Hvolby and K. Steger-Jensen, “Technical and industrial issues
of Advanced Planning and Scheduling (APS) systems,” Computers in
Industry, vol. 61, no. 9, pp. 845–851, 2010.
[7] S. Dauzère-Pérès, J. Ding, L. Shen, and K. Tamssaouet, “The flexible job
shop scheduling problem: A review,” European Journal of Operational
Research, vol. 314, no. 2, pp. 409–432, 2024.
[8] H. Xiong, S. Shi, D. Ren, and J. Hu, “A survey of job shop scheduling
problem: The types and models,” Computers & Operations Research,
vol. 142, p. 105731, 2022.
[9] K. Gao, Z. Cao, L. Zhang, Z. Chen, Y. Han, and Q. Pan, “A review on
swarm intelligence and evolutionary algorithms for solving flexible job
shop scheduling problems,” IEEE/CAA Journal of Automatica Sinica,
vol. 6, no. 4, pp. 904–916, 2019.
[10] B. Cunha, A. M. Madureira, B. Fonseca, and D. Coelho, “Deep
reinforcement learning as a job shop scheduling solver: A literature
review,” in Hybrid Intelligent Systems: 18th International Conference
on Hybrid Intelligent Systems, pp. 350–359, Springer, 2020.
[11] Y.-J. Yao, Q.-H. Liu, X.-Y. Li, and L. Gao, “A novel milp model for job
shop scheduling problem with mobile robots,” Robotics and Computer-
Integrated Manufacturing, vol. 81, p. 102506, 2023.
[12] D. B. Fontes, S. M. Homayouni, and J. C. Fernandes, “Energy-efficient
job shop scheduling problem with transport resources considering speed
adjustable resources,” International Journal of Production Research,
vol. 62, no. 3, pp. 867–890, 2024.
[13] D. B. Fontes, S. M. Homayouni, and J. F. Gonçalves, “A hybrid particle
swarm optimization and simulated annealing algorithm for the job shop
scheduling problem with transport resources,” European Journal of
Operational Research, vol. 306, no. 3, pp. 1140–1157, 2023.
[14] F. Zhang, Y. Mei, S. Nguyen, and M. Zhang, “Survey on genetic
programming and machine learning techniques for heuristic design in
job shop scheduling,” IEEE Transactions on Evolutionary Computation,
vol. 28, no. 1, pp. 147–167, 2023.
[15] J. Li, X. Li, L. Gao, and Q. Liu, “A flexible job shop scheduling problem
considering on-site machining fixtures: A case study from customized
manufacturing enterprise,” IEEE Transactions on Automation Science
and Engineering, 2024.
[16] Z. Tian, X. Jiang, W. Liu, and Z. Li, “Dynamic energy-efficient
scheduling of multi-variety and small batch flexible job-shop: A case
study for the aerospace industry,” Computers & Industrial Engineering,
vol. 178, p. 109111, 2023.
[17] L. Zhao, J. Fan, C. Zhang, W. Shen, and J. Zhuang, “A drl-based reactive
scheduling policy for flexible job shops with random job arrivals,” IEEE
Transactions on Automation Science and Engineering, 2023.
[18] T. Wang, J. Zhao, Q. Xu, W. Pedrycz, and W. Wang, “A dynamic
scheduling framework for byproduct gas system combining expert
knowledge and production plan,” IEEE Transactions on Automation
Science and Engineering, vol. 20, no. 1, pp. 541–552, 2022.
[19] H. Zhang and U. Roy, “A semantics-based dispatching rule selection
approach for job shop scheduling,” Journal of Intelligent Manufacturing,
vol. 30, no. 7, pp. 2759–2779, 2019.
[20] R. Ramamonjison, H. Li, T. Yu, S. He, V. Rengan, A. Banitalebi-
Dehkordi, Z. Zhou, and Y. Zhang, “Augmenting operations research with
auto-formulation of optimization models from problem descriptions,”
in Annual Conference on Empirical Methods in Natural Language
Processing, 2022.
[21] R. Ramamonjison, T. Yu, R. Li, H. Li, G. Carenini, B. Ghaddar, S. He,
M. Mostajabdaveh, A. Banitalebi-Dehkordi, Z. Zhou, et al., “Nl4opt
competition: Formulating optimization problems based on their natural
language descriptions,” in NeurIPS 2022 Competition Track, 2023.
[22] A. Ahmaditeshnizi, W. Gao, and M. Udell, “Optimus: Scalable opti-
mization modeling with (mi) lp solvers and large language models,” in
International Conference on Machine Learning, 2024.
[23] Z. Xiao, D. Zhang, Y. Wu, L. Xu, Y. J. Wang, X. Han, X. Fu, T. Zhong,
J. Zeng, M. Song, et al., “Chain-of-experts: When llms meet complex
operations research problems,” in International Conference on Learning
Representations, 2023.
[24] C. Huang, Z. Tang, D. Ge, S. Hu, R. Jiang, B. Wang, Z. Wang, and
X. Zheng, “Orlm: A customizable framework in training large models
for automated optimization modeling,” Operations Research, 2025.
[25] C. Jiang, X. Shu, H. Qian, X. Lu, J. Zhou, A. Zhou, and Y. Yu,
“Llmopt: Learning to define and solve general optimization problems
from scratch,” in International Conference on Learning Representations,
2025.
[26] Y. Zhang, Q. Kang, W. Y. Yu, H. Gong, X. Fu, X. Han, T. Zhong,
and C. Ma, “Decision information meets large language models: The
future of explainable operations research,” in International Conference
on Learning Representations, 2025.
[27] B. Russell, “Vagueness,” The Australasian Journal of Psychology and
Philosophy, vol. 1, no. 2, pp. 84–92, 1923.
[28] S. Ouyang, J. M. Zhang, M. Harman, and M. Wang, “An empirical
study of the non-determinism of chatgpt in code generation,” ACM
Transactions on Software Engineering and Methodology, 2024.
[29] V. G. Cannas, M. P. Ciano, M. Saltalamacchia, and R. Secchi, “Artificial
intelligence in supply chain and operations management: a multiple case
study research,” International Journal of Production Research, vol. 62,
no. 9, pp. 3333–3360, 2024.
[30] Y.-Z. Shi, M. Xu, J. E. Hopcroft, K. He, J. B. Tenenbaum, S.-C. Zhu,
Y. N. Wu, W. Han, and Y. Zhu, “On the complexity of Bayesian
generalization,” in International Conference on Machine Learning, 2023.
[31] Y.-Z. Shi, Q. Xu, F. Meng, L. Ruan, and Q. Wang, “Abstract Hardware
Grounding towards the Automated Design of Automation Systems,” in
International Conference on Intelligent Robotics and Applications, 2024.
[32] M. Fowler, Domain-specific languages. Pearson Education, 2010.
[33] A. Tarski, Introduction to Logic and to the Methodology of Deductive
Sciences. Dover Publications, 1946.
[34] S. J. Russell and P. Norvig, Artificial intelligence a modern approach.
Prentice Hall Press, 2010.
[35] G. Karsai, H. Krahn, C. Pinkernell, B. Rumpe, M. Schindler, and
S. Völkel, “Design guidelines for domain specific languages,” in OOP-
SLA Workshop on Domain-Specific Modeling (DSM’ 09), 2009.
[36] N. Chomsky, Syntactic Structures. Mouton de Gruyter, 1957.
[37] J. E. Hopcroft, R. Motwani, and J. D. Ullman, Introduction to Automata
Theory, Languages, and Computation. Addison-Wesley Longman Pub-
lishing Co., Inc., 1996.


--- Page 15 ---
IEEE TRANSACTIONS ON AUTOMATION SCIENCE AND ENGINEERING
15
[38] Y.-Z. Shi, F. Meng, H. Hou, Z. Bi, Q. Xu, L. Ruan, and Q. Wang,
“Expert-level protocol translation for self-driving labs,” in Advances in
Neural Information Processing Systems, 2024.
[39] M. Mernik, J. Heering, and A. M. Sloane, “When and how to develop
domain-specific languages,” ACM Computing Surveys (CSUR), vol. 37,
no. 4, pp. 316–344, 2005.
[40] Y.-Z. Shi, H. Hou, Z. Bi, F. Meng, X. Wei, L. Ruan, and Q. Wang,
“AutoDSL: Automated domain-specific language design for structural
representation of procedures with constraints,” in Annual Meeting of the
Association for Computational Linguistics, 2024.
[41] Y.-Z. Shi, M. Liu, F. Meng, Q. Xu, Z. Bi, K. He, L. Ruan, and
Q. Wang, “Hierarchically Encapsulated Representation for Protocol
Design in Self-Driving Labs,” in International Conference on Learning
Representations, 2025.
[42] Y.-Z. Shi, M. Liu, H. Ma, Q. Xu, H. Qu, K. He, L. Ruan, and Q. Wang,
“Targeted control of fast prototyping through domain-specific interface,”
in International Conference on Machine Learning, 2025.
[43] M. Gabbrielli, S. Martini, and S. Giallorenzo, Programming languages:
principles and paradigms. Springer, 2010.
[44] H. Abelson and G. J. Sussman, Structure and interpretation of computer
programs. The MIT Press, 1996.
[45] M. Honnibal and M. Johnson, “An improved non-monotonic transition
system for dependency parsing,” in Annual Conference on Empirical
Methods in Natural Language Processing, 2015.
[46] T. Xie, Q. Li, Y. Zhang, Z. Liu, and H. Wang, “Self-improving for
zero-shot named entity recognition with large language models,” in
Proceedings of the 2024 Conference of the North American Chapter
of the Association for Computational Linguistics, 2024.
[47] A. V. Aho and J. D. Ullman, The theory of parsing, translation, and
compiling. Prentice-Hall Englewood Cliffs, NJ, 1972.
[48] T. Brown, B. Mann, N. Ryder, M. Subbiah, J. D. Kaplan, P. Dhariwal,
A. Neelakantan, P. Shyam, G. Sastry, A. Askell, et al., “Language
models are few-shot learners,” in Advances in Neural Information
Processing Systems, 2020.
[49] J. Wei, M. Bosma, V. Zhao, K. Guu, A. W. Yu, B. Lester, N. Du, A. M.
Dai, and Q. V. Le, “Finetuned language models are zero-shot learners,”
in International Conference on Learning Representations, 2022.
[50] R. L. Graham, “Bounds for certain multiprocessing anomalies,” Bell
System Technical Journal, vol. 45, no. 9, pp. 1563–1581, 1966.
[51] R. L. Graham, E. L. Lawler, J. K. Lenstra, and A. R. Kan, “Optimiza-
tion and approximation in deterministic sequencing and scheduling: a
survey,” in Annals of discrete mathematics, Elsevier, 1979.
[52] P. Baptiste, C. Le Pape, and W. Nuijten, Constraint-based scheduling:
applying constraint programming to scheduling problems.
Springer
Science & Business Media, 2001.
[53] P. Baptiste, P. Laborie, C. Le Pape, and W. Nuijten, “Constraint-based
scheduling and planning,” in Foundations of artificial intelligence, vol. 2,
pp. 761–799, Elsevier, 2006.
[54] K. M. Chandy, “Parallel program design,” in Opportunities and Con-
straints of Parallel Computing, Springer, 1989.
[55] M. Voelter and E. Visser, “Product line engineering using domain-
specific languages,” in 2011 15th IEEE International Software Product
Line Conference, 2011.
[56] K. Meixner, F. Rinker, H. Marcher, J. Decker, and S. Biffl, “A domain-
specific language for product-process-resource modeling,” in 2021 26th
IEEE International Conference on Emerging Technologies and Factory
Automation (ETFA), 2021.
[57] M. Hofmann, L. Albaugh, T. Wang, J. Mankoff, and S. E. Hudson,
“Knitscript: A domain-specific scripting language for advanced machine
knitting,” in Proceedings of the 36th Annual ACM Symposium on User
Interface Software and Technology, 2023.
[58] A. Martelli and U. Montanari, “An efficient unification algorithm,”
ACM Transactions on Programming Languages and Systems (TOPLAS),
vol. 4, no. 2, pp. 258–282, 1982.
[59] E. Taillard, “Benchmarks for basic scheduling problems,” European
Journal of Operational Research, vol. 64, no. 2, pp. 278–285, 1993.
[60] J. Adams, E. Balas, and D. Zawack, “The shifting bottleneck procedure
for job shop scheduling,” Management Science, vol. 34, no. 3, pp. 391–
401, 1988.
[61] D. Applegate and W. Cook, “A computational study of the job-shop
scheduling problem,” ORSA Journal on Computing, vol. 3, no. 2,
pp. 149–156, 1991.
[62] C. Bierwirth, “A generalized permutation approach to job shop schedul-
ing with genetic algorithms,” Operations Research Spektrum, vol. 17,
no. 2, pp. 87–92, 1995.
[63] E. Balas and A. Vazacopoulos, “Guided local search with shifting
bottleneck for job shop scheduling,” Management Science, vol. 44, no. 2,
pp. 262–275, 1998.
[64] J. Carlier and É. Pinson, “An algorithm for solving the job-shop
problem,” Management Science, vol. 35, no. 2, pp. 164–176, 1989.
[65] A. S. Jain and S. Meeran, “Deterministic job-shop scheduling: Past,
present and future,” European Journal of Operational Research,
vol. 113, no. 2, pp. 390–434, 1999.
[66] E. Nowicki and C. Smutnicki, “A fast taboo search algorithm for the
job shop problem,” Management Science, vol. 42, no. 6, pp. 797–813,
1996.
[67] I. Sabuncuoglu and M. Bayiz, “Job shop scheduling with beam search,”
European Journal of Operational Research, vol. 118, no. 2, pp. 390–412,
1999.
[68] R. H. Storer, S. D. Wu, and R. Vaccari, “New search spaces for sequenc-
ing problems with application to job shop scheduling,” Management
Science, vol. 38, no. 10, pp. 1495–1509, 1992.
[69] Y.-Z. Shi, H. Li, L. Ruan, and H. Qu, “Constraint representation
towards precise data-driven storytelling,” in IEEE Visualization and
Visual Analytics Gen4DS Workshop, 2024.
[70] H. Schütze, C. D. Manning, and P. Raghavan, Introduction to informa-
tion retrieval. Cambridge University Press Cambridge, 2008.
[71] K. Papineni, S. Roukos, T. Ward, and W.-J. Zhu, “Bleu: a method for
automatic evaluation of machine translation,” in Annual Meeting of the
Association for Computational Linguistics, 2002.
[72] Y.-Z. Shi, S. Li, X. Niu, Q. Xu, J. Liu, Y. Xu, S. Gu, B. He, X. Li,
X. Zhao, et al., “PersLEARN: Research Training through the Lens
of Perspective Cultivation,” in Annual Meeting of the Association for
Computational Linguistics, 2023.
Yu-Zhe Shi is presently a graduate student in the
Department of Computer Science and Engineering
at the Hong Kong University of Science and Tech-
nology. He is also affiliated with the Laboratory
of Human-Robot Systems at Peking University. His
research primarily focuses on the automatic design,
translation, synthesis, and deployment of domain-
specific representations, aiming to facilitate inter-
action, collaboration, coordination, and communica-
tion between humans and machines.
Qiao Xu received the B.Eco. degree in Finance
from Huazhong University of Science and Tech-
nology (HUST) in 2024. He is currently pursuing
the M.Eng. degree in the School of Software En-
gineering at University of Science and Technology
of China (USTC). His research interests include
AI4Science and spatiotemporal data mining.
Yanjia Li received the B.Sc. degree (First Class
Honors) in Computer Science and Data Science
and Technology from the Hong Kong University of
Science and Technology (HKUST) in 2021. She is
currently pursuing the M.Phil. degree in Computer
Science at HKUST. Her research interests include
assortment optimization, supply chain management,
and production scheduling.


--- Page 16 ---
IEEE TRANSACTIONS ON AUTOMATION SCIENCE AND ENGINEERING
16
Mingchen Liu received the B.Eng. degree from
the School of Software, Huazhong University of
Science and Technology (HUST) in 2024. He is
currently pursuing the M.Eng. degree in the School
of Computer Science and Technology at HUST. His
research interests include AI4Science and Computa-
tional Cognitive Science.
Huamin Qu is a chair professor in the Department
of Computer Science and Engineering (CSE) at the
Hong Kong University of Science and Technology
(HKUST) and also the Dean of the Academy of
Interdisciplinary Studies (AIS) of HKUST. He ob-
tained a BS in Mathematics from Xi’an Jiaotong
University, China, an MS and a PhD in Computer
Science from the Stony Brook University. His main
research interests are in visualization and human-
computer interaction, with focuses on urban in-
formatics, social network analysis, E-learning, text
visualization, and explainable artificial intelligence (XAI). For more informa-
tion, please visit http://huamin.org/.
Lecheng Ruan received the B.S. honor degree from
the School of Mechatronic Engineering, Harbin In-
stitute of Technology in 2015, and the Ph.D. degree
from the Department of Mechanical and Aerospace
Engineering, University of California, Los Angeles
in 2020. He is now directing the Center of Intelli-
gence in the Laboratory of Human-Robot Systems,
Peking University. His research interests include
perception, control and knowledge representation of
robotic systems.
Qining Wang (Senior Member, IEEE) received
his Ph.D. degree from Peking University, Beijing,
China, in 2009, where he is currently a Full Pro-
fessor in the College of Engineering. He serves as
the Vice-Dean of the College of Engineering, Peking
University, China. He has authored/co-authored over
200 scientific papers in international journals and
refereed conference proceedings. His research inter-
ests include wearable robotics and human-machine
interfaces.
