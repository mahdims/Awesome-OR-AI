--- Page 1 ---
arXiv:2408.05136v1  [cs.LG]  9 Aug 2024
Cycle-Conﬁguration: A Novel Graph-theoretic Descriptor Set
for Molecular Inference∗
Bowen Song
Jianshen Zhu
Naveed Ahmed Azam
Kazuya Haraguchi
Liang Zhao
Tatsuya Akutsu
Abstract
In this paper, we propose a novel family of descriptors of chemical graphs, named
cycle-conﬁguration (CC), that can be used in the standard “two-layered (2L) model”
of mol-infer, a molecular inference framework based on mixed integer linear program-
ming (MILP) and machine learning (ML). Proposed descriptors capture the notion
of ortho/meta/para patterns that appear in aromatic rings, which has been impos-
sible in the framework so far. Computational experiments show that, when the new
descriptors are supplied, we can construct prediction functions of similar or better
performance for all of the 27 tested chemical properties. We also provide an MILP
formulation that asks for a chemical graph with desired properties under the 2L model
with CC descriptors (2L+CC model). We show that a chemical graph with up to 50
non-hydrogen vertices can be inferred in a practical time.
1
Introduction
Among key issues in cheminformatics and bioinformatics is the problem of inferring mole-
cules that are expected to attain desired activities/properties.
This problem is also
known as inverse QSAR/QSPR modeling [13, 23].
We focus our attention on inverse
QSAR/QSPR modeling of low molecular weight organic compounds, which has applica-
tions in drug discovery [17, 28] and material science [19]. With recent rapid progress of
machine learning (ML), there have been developed a lot of inverse QSAR/QSPR mod-
els, most of which are based on neural networks (NNs); e.g., variational autoencoders [8],
generative adversarial networks [7, 21], and invertible ﬂow models [16, 24]. The weakness
of NN based methods is the lack of optimality and exactness [30], where we mean by
optimality the preciseness of a solution to attain the desired activities/properties; and by
exactness the guarantee of a solution as a valid molecule. Besides, it is hard to exploit
domain knowledge in NN based methods.
Our research group has developed a new framework of molecular inference that is
based on mixed integer linear programming (MILP) and ML. This framework, which
we call mol-infer, achieves optimality and exactness, and enables practitioners to exploit
domain knowledge to some extent. Let G denote the set of all possible chemical graphs.
The process of mol-infer is summarized as follows.
Stage 1: Determine the target chemical property π and collect a data set Dπ ⊆G of
chemical graphs such that the observed value a(C) for the chemical property π is
available for all chemical graphs C ∈Dπ.
∗The work is partially supported by JSPS KAKENHI Grant Numbers JP22H00532 and JP22KJ1979.
1


--- Page 2 ---
Stage 2: Design a set of descriptors to obtain a feature function f : G →RK that converts
a chemical graph C ∈Dπ into a K-dimensional real feature vector f(C) ∈RK, where
K is the number of descriptors.
Stage 3: Construct a prediction function η : RK →R from the data set f(Dπ) ≜{f(C) |
C ∈Dπ} of feature vectors, where η(C) is used to estimate the property value a(C)
of a chemical graph C.
Stage 4: Determine two real numbers y∗, y∗(y∗≤y∗) as lower/upper bounds on the
target value and a set σ of rules (called a speciﬁcation) on chemical graphs. Let
Gσ ⊆G denote the set of all chemical graphs that satisfy σ. Formulate the problem
of constructing a chemical graph C† as MILP whose constraints include C1 and C2
to ensure (C1) y∗≤η(f(C†)) ≤y∗and (C2) C† ∈Gσ. Solve the MILP to obtain C†.
If the MILP is infeasible, then it is indicated that no such C† exist.
Stage 5: Generate isomers of C† somehow.
Regarded as a method of inverse QSAR/QSPR, the highlight of mol-infer is Stage 4 that
solves the inverse problem by MILP, which is the original contribution of this framework.
For C1, the process of computing the feature vector f(C) for a chemical graph C and
the process of computing the prediction value η(x) of a feature vector x = f(C) must
be represented by linear inequalities of real and/or integer variables. It is shown that
artiﬁcial neural network [1], linear regression [31] and decision tree [26] can be used as η.
We will discuss how to design f for this purpose in the next paragraph. For C2, in our
early studies, we could deal with only limited classes of chemical graphs; e.g., trees [4, 29],
rank-1 graphs [14] and rank-2 graphs [33]. Shi et al.’s two-layered (2L) model [25] admits
us to infer any chemical graph, where users are required to design an abstract structure
of C† as a part of the speciﬁcation σ. Stage 5 is not within the scope of this paper. For
this stage, a dynamic programming algorithm [32] and a grid neighborhood approach [3]
are developed. Furthermore, mol-infer is applied to the inference of polymers [12].
Let us describe how we design the feature function f in Stage 2. The descriptors should
be informative since they have a great inﬂuence on prediction performance in Stage 3 and
thus on the quality of chemical graphs that we ﬁnally obtain as a result of Stages 4 and 5;
if the prediction function η is not accurate enough, then we could not expect the inferred
graphs to have desired property. On the other hand, as mentioned above, the process of
computing descriptor values should be represented by a set of linear inequalities. It is hard
to include descriptors of complicated concepts. There is a trade-oﬀbetween informativity
and simplicity in the design of descriptors.
Due to these reasons, mol-infer employs graph-theoretic descriptors that capture local
information of chemical graphs and that are somewhat similar to typical ﬁngerprints. Let
f2L be a feature function in the 2L model, the standard model in mol-infer.
The 2L
model has a weak point such that there are distinct chemical graphs C1, C2 for which
f2L(C1) = f2L(C2) holds although a(C1) and a(C2) are much diﬀerent. An example of
such C1 and C2 is shown in Figure 1, where the details are explained in Section 3.1.
This issue comes from that the descriptors of the 2L model cannot capture how edges are
connected to cycles. For example, although the descriptors can distinguish ortho patterns
of an aromatic ring (e.g., C0 in Figure 1) from meta/para patterns (e.g., C1 and C2 in
Figure 1, respectively), they fail to distinguish meta and para patterns.
In this paper, aiming at overcoming the above weak point in the 2L model, we propose
a novel set of descriptors, named cycle-conﬁgurations (CC). CC can specify how exterior
2


--- Page 3 ---
H
C
C
C
C
C
O
H
H
H
C
H
O
H
H
C
C
C
C
C
O
O
H
H
H
H
H
C
(a)
(b)
H
C
C
C
C
C
O
H
H
H
C
H
O
H
C
C
H
O
H
ψ1
ψ2
(c)
(d)
Figure 1: (a) the chemical graph C0 for catechol; (b) the chemical graph C1 for resorcinol;
(c) the chemical graph C2 for hydroquinone; and (d) two fringe-trees ψ1 and ψ2 that
appearing in all of C0, C1 and C2.
In (b), the edge-conﬁguration of the interior-edge
indicated by a dotted rectangle is (C2, C3, 2). Although f2L(C1) = f2L(C2), a(C1) = 0 ̸=
1 = a(C2) holds in the data set of AhR property from Tox21 collection.
3


--- Page 4 ---
parts (called “fringe-trees”) are attached to a cycle, by which meta/para patterns in an
aromatic ring are distinguishable. Let us denote by fCC a feature function that consists
of CC descriptors.
We call the 2L model with CC descriptors the 2L+CC model. In the 2L+CC model,
we use the feature function f : G →RK such that f(C) := (f2L(C), fCC(C)) for a chemical
graph C (i.e., concatenation of two feature vectors f2L(C) and fCC(C)).
Computational experiments show that, by using the 2L+CC model, we can construct
prediction functions of similar or better performance for all of the 27 tested chemical
properties, in comparison with the 2L model. We also provide an MILP formulation for
the 2L+CC model that asks for a chemical graph with desired properties. We show that a
chemical graph with up to 50 non-hydrogen vertices can be inferred in a couple of minutes.
The paper is organized as follows. We make preparations and review the 2L model
in Section 2. In Section 3, we describe further background of CC and provide its formal
deﬁnition. In Section 4, we describe the idea of the MILP for the 2L+CC model. We
present computational results in Section 5 and conclude the paper in Section 6. Some
details are explained in Appendix.
2
Preliminaries
2.1
Notations and Terminologies
Let R, R+, Z and Z+ denote the sets of reals, non-negative reals, integers, and non-negative
integers, respectively. For p, q ∈Z, let us denote [p, q] := {p, p + 1, . . . , q}. For a vector
(or a sequence) x ∈Rp and j ∈[1, p], we denote by x(j) the j-th entry of x. We denote
|x| := p.
Let A be a ﬁnite set. To encode elements in A by integers, we may assume a bijection
σ : A →[1, |A|] implicitly. For a ∈A, we represent the coded integer σ(a) by [a]A or
simply [a] if A is clear from the context.
For an undirected graph G, we denote by V (G) and E(G) the sets of vertices and
edges, respectively.
For V ′ ⊆V (G) (resp., E′ ⊆E(G)), we denote by G −V ′ (resp.,
G −E′) the subgraph of G that is obtained by removing the vertices in V ′ along with the
incident edges (resp., removing the edges in E′). When V ′ = {v} (resp., E′ = {e}), we
write G −{v} as G −v (resp., G −{e} as G −e).
A cycle C in a graph G is a subgraph of G such that V (C) = {u1, u2, . . . , uℓ} and
E(C) = {u1u2, . . . , uℓ−1uℓ, uℓu1}. We call C chordless if there is no edge in E(G) \ E(C)
that joins vertices in V (C). The length of a cycle C is denoted by len(C) (i.e., len(C) =
|V (C)| = |E(C)| = ℓ). When the length is ℓ, we call C an ℓ-cycle.
A graph is rooted if it has a designated vertex, called a root. For a graph G possibly
with a root, a leaf-vertex is a non-root vertex with degree 1. We call the edge that is
incident to a leaf-vertex a leaf-edge. We denote by Vleaf(G) and Eleaf(G) the sets of leaf-
vertices and leaf-edges in G, respectively. For i ∈Z+, we deﬁne the graph Gi to be the
subgraph of G that is obtained by deleting the set of leaf-vertices i times, that is, G0 := G;
and Gi+1 := Gi −Vleaf(Gi). We deﬁne the height ht(v) of a vertex v ∈Vleaf(Gi) to be i.
Note that the height is not deﬁned for all vertices.
2.2
Modeling of Chemical Compounds
We employ the modeling of chemical compounds that was introduced by Zhu et al. [31].
4


--- Page 5 ---
Let us represent chemical elements by H (hydrogen), C (carbon), O (oxygen), N (ni-
trogen) and so on.
To distinguish a chemical element a with multiple valences such
as S (sulfur), we denote a with a valence i by a(i), where we omit the suﬃx (i) for
a chemical element with a unique valence.
Let Λ be a set of chemical elements; e.g.,
Λ = {H, C, O, N, P, S(2), S(4), S(6)}. We represent the valence of a ∈Λ by a function val : Λ →
[1, 6]; e.g., val(H) = 1, val(C) = 4, val(O) = 2, val(P) = 5, val(S(2)) = 2 and val(S(6)) = 6.
We denote the mass of a ∈Λ by mass∗(a).
We represent a chemical compound by a chemical graph that is deﬁned to be C =
(H, α, β) consisting of a simple, connected undirected graph H and functions α : V (H) →
Λ and β : E(H) →[1, 3].
The set of atoms and the set of bonds in the compound
correspond to the vertex set V (H) and the edge set E(H), respectively. The chemical
element assigned to v ∈V (H) is represented by α(v) and the bond-multiplicity between
two adjacent vertices u, v ∈V (H) is represented by β(e) of the edge e = uv ∈E(H). We
denote the mass of H by mass∗(H) := P
v∈V (H) mass∗(α(v)).
Let C = (H, α, β) be a chemical graph. For a vertex u ∈V (H), we denote by βC(u) the
sum of bond-multiplicities of edges incident to u; i.e., βC(u) :=
X
uv∈E(H)
β(uv). We denote
by degC(u) the number of vertices adjacent to u in C. For a ∈Λ, we denote by Va(C) the
set of vertices in v ∈V (H) such that α(v) = a in C. We deﬁne the hydrogen-suppressed
chemical graph of C, denoted by ⟨C⟩, to be the graph that is obtained by removing all
vertices in VH(C) from H.
Two chemical graphs Ci = (Hi, αi, βi), i = 1, 2 are called isomorphic if they ad-
mit an isomorphism, i.e., a bijection φ : V (H1) →V (H2) such that “uv ∈E(H1),
α1(u) = a, α1(v) = b, β1(uv) = m” ⇔“φ(u)φ(v) ∈E(H2), α2(φ(u)) = a, α2(φ(v)) = b,
β2(φ(u)φ(v)) = m”. Furthermore, when Hi is a rooted graph such that ri ∈V (Hi) is the
root, i = 1, 2, C1 and C2 are called rooted-isomorphic if they admit an isomorphism such
that φ(r1) = (r2).
2.3
Two-Layered (2L) Model
We review the 2L model that was introduced by Shi et al. [25].
2.3.1
Interior and Exterior
Let C = (H, α, β) be a chemical graph and ρ ≥1 be an integer, which we call a branch-
parameter, where we use ρ = 2 as the standard value. In the 2L model, the hydrogen-
suppressed chemical graph ⟨C⟩is partitioned into “interior” and “exterior” parts as follows.
We call a vertex v ∈V (⟨C⟩) an exterior-vertex if ht(v) < ρ, and an edge e ∈E(⟨C⟩) an
exterior-edge if e is incident to an exterior-vertex. Let V ex(C) and Eex(C) denote the sets
of exterior-vertices and exterior-edges, respectively. Deﬁne V int(C) := V (⟨C⟩) \ V ex(C)
and Eint(C) := E(⟨C⟩) \ Eex(C). We call a vertex in V int(C) an interior-vertex and an
edge in Eint(C) an interior-edge. We deﬁne the interior Cint of C to be the subgraph
(V int(C), Eint(C)).
The set Eex(C) of exterior-edges forms a collection of connected graphs such that each
is a tree T rooted at an interior vertex v ∈V (T) Let T ex(⟨C⟩) denote the family of
such chemical rooted trees in ⟨C⟩. For each interior-vertex u ∈V int(C), let Tu ∈T ex(⟨C⟩)
denote the chemical tree rooted at u, where Tu may consist only of the vertex u. We deﬁne
the fringe-tree of u, denoted by C[u], to be the chemical rooted tree that is obtained by
putting back hydrogens to Tu that are originally attached in C.
5


--- Page 6 ---
2.3.2
Feature Function
For a feature function f2L in the 2L model (Stage 2), there are two types of descriptors:
static ones and enumerative ones. There are 14 static descriptors such as the number
of non-hydrogen atoms and the number of interior vertices. The enumerative descriptors
mainly consist of the frequency of local patterns that appear in a chemical graph C =
(H, α, β).
Examples of such local patterns include “fringe-conﬁgurations”, “adjacency-
conﬁgurations” and “edge-conﬁgurations”.
We collect enumerative descriptors from a
given data set Dπ.
Let u ∈V int(C) be an interior-vertex. The fringe-conﬁguration of u is the chemical
tree C[u] that is rooted at u. Let us denote by F(Dπ) the set of all fringe trees that appear
in the data set Dπ. For each ψ ∈F(Dπ), we introduce a descriptor that evaluates the
number of interior-vertices u ∈V int(C) such that C[u] is rooted-isomorphic to ψ.
For an interior-edge e = uv ∈Eint(C), let α(u) = a, deg⟨C⟩(u) = d, α(v) = b,
deg⟨C⟩(v) = d′ and β(e) = m. The adjacency-conﬁguration of e (resp., edge-conﬁguration of
e) is deﬁned to be the tuple (a, b, m) (resp., (ad, bd′, m)). Let us denote by Γac(Dπ) (resp.,
Γec(Dπ)) the set of all adjacency-conﬁgurations (resp., edge-conﬁgurations) in the data set
Dπ. For each tuple γac ∈Γac(Dπ) (resp., γec ∈Γec(Dπ)), we introduce a descriptor that
evaluates the number of interior-edges e ∈Eint(C) such that the adjacency-conﬁguration
(resp., edge-conﬁguration) is equal to γac (resp., γec).
See Appendix A for a full description of descriptors in the 2L model.
2.3.3
Speciﬁcation for MILP
In the 2L model, the speciﬁcation σ for MILP (Stage 4) consists of the following three
rules:
• a seed graph GC as an abstract form of a target chemical graph C†;
• a set F of fringe trees as candidates for a tree C†[u] rooted at each interior-vertex
in C†; and
• lower/upper bounds on the number of various parameters in C†; e.g., chemical ele-
ments, double/triple bonds, and fringe/edge/adjacency-conﬁgurations.
The MILP formulates the process of constructing a chemical graph C† as follows. First,
we decide the interior of C† by “expanding” the seed graph GC; e.g., subdividing an edge
and attaching a new path to a vertex. Second, regarding all vertices in the expanded seed
graph as the interior-vertices of C†, we assign a fringe tree in F to every vertex to make
the exterior of C†. Finally, we assign bond-multiplicities to the interior-edges so that all
constraints in σ are satisﬁed. We can regard Gσ in Section 1 as the set of all chemical
graphs that can be constructed in this way. See the preprint of [31] for details of MILP in
the 2L model.
3
Cycle-Conﬁgurations
In this section, we propose a new type of descriptors for the 2L model, named cycle-
conﬁgurations (CC).
6


--- Page 7 ---
3.1
Motivation
Let us point out a weak point of the 2L model again; there are chemical graphs that
are not isomorphic to each other but are converted into an identical feature vector. See
Figure 1 for an example. Three chemical graphs C0 (catechol), C1 (resorcinol) and C2
(hydroquinone) are shown, where C0 is the ortho-isomer, C1 is the meta-isomer and C2 is
the para-isomer.
We can conﬁrm that f2L(C1) = f2L(C2) holds by observing the descriptors one by
one. For fringe-conﬁguration, both chemical graphs contain four ψ1 and two ψ2 as fringe-
trees in common. For edge-conﬁguration, they contain one (C2, C2, 1); one (C2, C2, 2); two
(C2, C3, 1) and two (C2, C3, 2) in common. In this way, one sees that the two chemical
graphs take the same values for the other descriptors (see Appendix A). We also see
that f2L(C0) ̸= f2L(C1) and f2L(C0) ̸= f2L(C2) hold since C0 contains one (C2, C2, 1); two
(C2, C2, 2); two (C2, C3, 1) and one (C3, C3, 2) for its edge-conﬁgurations, which are diﬀerent
from those of C1 and C2.
Although the two chemical graphs C1 and C2 are converted into an identical feature
vector, they may have diﬀerent properties from each other.
For example, Tox21 is a
collection of data sets for binary classiﬁcation (i.e., a(C) ∈{0, 1} for C ∈Dπ). In AhR
data set, the two chemical graphs C1 and C2 in Figure 1 satisfy f2L(C1) = f2L(C2) although
a(C1) = 0 and a(C2) = 1 hold. It is desirable to convert as many such pairs into distinct
feature vectors as possible.
3.2
Deﬁnitions
We deﬁne a new descriptor, cycle-conﬁguration, in order to convert chemical graphs like
C1 and C2 in Figure 1 into distinct feature vectors. Let R = {a1, a2, . . . , ak} be a set of
distinct real numbers. For a ∈R, we deﬁne rankR(a) := i if a is the i-th smallest in R.
For example, when R = {3, 2, 5, 9}, we have rankR(3) = 2, rankR(2) = 1, rankR(5) = 3,
and rankR(9) = 4.
Suppose that a chemical graph C is given. Let C be a chordless cycle in C such that
V (C) = {u1, u2, . . . , uℓ} and E(C) = {u1u2, u2u3, . . . , uℓ−1uℓ, uℓu1}. For ui ∈V (C), we
deﬁne µi := mass∗(C[ui]).
Let R denote the set of distinct numbers in µ1, µ2, . . . , µℓ.
We deﬁne ξ(C) to be the smallest sequence (rankR(µ1), rankR(µ2), . . . , rankR(µℓ)) with
respect to the lexicographic order among all possible cyclic permutations (including re-
versal) of (u1, u2, . . . , uℓ), where there are 2ℓpermutations possible. We deﬁne the cycle-
conﬁguration of C to be ξ(C).
Let us see Figure 1 for example. Suppose mass∗(H) = 1, mass∗(C) = 12 and mass∗(O) =
16. For the two fringe-trees ψ1 and ψ2 in the ﬁgure, we have mass∗(ψ1) = 12 + 1 = 13
and mass∗(ψ2) = 12 + 16 + 1 = 29. Let us denote the unique (chordless) 6-cycle in Ci
by Ci, i = 1, 2. The set of distinct numbers that appear as the mass of a fringe-tree is
R = {13, 29} for both chordless cycles, where rankR(13) = 1 and rankR(29) = 2. One
readily sees that ξ(C1) = ξ1 := (1, 1, 1, 2, 1, 2) and ξ(C2) = ξ2 := (1, 1, 2, 1, 1, 2).
CCs are enumerative descriptors, and we collect ones that are included in the feature
function from a given data set Dπ. We denote by Ξ(Dπ) the set of all cycle-conﬁgurations ξ
that appear in Dπ. Let KCC := |Ξ(Dπ)|. For a chemical graph C ∈Dπ, we deﬁne fCC(C)
to be a KCC-dimensional feature vector fCC(C) = (dcp◦
1(C), dcp◦
2(C), . . . , dcp◦
KCC(C)),
where
dcp◦
i (C), i = [ξ∗], ξ∗∈Ξ(Dπ): the number of chordless cycles C in C such that
ξ(C) = ξ∗.
7


--- Page 8 ---
Table 1: The numbers of chemical compounds in conventional databases. The 2nd to 5th
columns represent the number of all registered chemical compounds; the number of feasible
chemical graphs in the 2L-model (e.g., connected, at least four carbon atoms exist); the
number of chemical graphs that are either acyclic or ℓ(C) ∈[4, 6] for all chordless cycles
C; the number of chemical graphs that contain none of (i) or (ii), respectively.
The
percentages indicate the ratio of the number over the left number.
Database
All
2L-model
Acyclic or ℓ(C) ∈[4, 6]
No substructures
feasible
for all chordless cycles C
(i) or (ii) in Section 4
PubChem
97,092,888
92,509,596
83,520,760
80,842,345
(as of 2019)
(95%)
(90%)
(96%)
QM9
130,786
130,786
71,520
60,352
(100%)
(54%)
(84%)
Tox21
8,014
7,769
7,273
7,080
(96%)
(93%)
(97%)
See Figure 1 again. Suppose Ξ(Dπ) = {ξ1, ξ2, ξ3, ξ4} for ξ3 := (1, 1, 2, 3) and ξ4 :=
(1, 1, 1, 1, 2). Then fCC(C1) = (1, 0, 0, 0) and fCC(C2) = (0, 1, 0, 0) hold, by which we have
f(C1) = (f2L(C1), fCC(C1)) ̸= (f2L(C2), fCC(C2)) = f(C2).
In our implementation, as Dπ may contain too many CC descriptors, we use only CC
descriptors whose lengths are in the range [cmin, cmax], where cmin and cmax are positive
constants (cmin ≤cmax). We will set cmin := 4 and cmax := 6 since, in most of chemical
compounds in conventional databases, the chemical graph is acyclic or contain only chord-
less cycles whose lengths are within [4, 6]. See Table 1. For example, in PubChem, among
92,509,596 molecules that are feasible in the 2L-model, 83,520,760 molecules (90%) satisfy
this condition.
4
MILP Formulation for 2L+CC Model
Let us consider an MILP formulation for inferring a chemical graph in the 2L+CC model.
Similarly to the 2L model, the constraints of the MILP consist of (C1) y∗≤η(f(C†)) ≤y∗
and (C2) C† ∈Gσ, where C† denotes a chemical graph to be inferred and is represented
by real/integer variables. We can use any prediction function η in C1 if its computational
process can be represented by a set of linear inequalities. For example, artiﬁcial neural
network [1], linear regression [31] and decision tree [26] can be used to construct η. In
this section, we overview how we formulate C2 as MILP. See Appendix B for the precise
formulation of the MILP that includes how we represent the computational process of the
feature function f by a set of linear inequalities.
The basic idea of C2 is similar to the 2L model (see Section 2.3.3); we represent by
C2 the computational process of expanding an abstract form of the chemical graph to a
concrete chemical graph. We introduce a new type of abstract form, which we call a “seed
tree”, since it is hard to deal with CC descriptors by a seed graph of the 2L model.
A seed tree is a tuple T = (T; V ◦, E◦) of an unrooted tree T, V ◦⊆V (T) and E◦⊆
{uv ∈E(T) | u, v ∈V ◦}. We call a node in V ◦a ring node and an edge in E◦a ring edge,
whereas a node in V (T) \ V ◦is a non-ring node, and an edge in E(T) \ E◦is a non-ring
edge. For a node u ∈V (T), we denote by E◦(u) and ¯E◦(u) the sets of all ring edges and
of all non-ring edges incident to u, respectively. See Figure 2(a) for an example.
We formulate by C2 the following process of constructing a chemical graph C† := CT =
(GT , α, β).
8


--- Page 9 ---
u1
u2
u3
u4
u5
1
C
2
C
3
C
4
C
5
C
CH3
N
N
O
N
N
N
N
N
O
H3C
N
O
CH3
O
CH3
N
O
CH3
O
OH
O
CH3
(a)
(b)
(c)
Figure 2: Construction of a chemical graph. (a) A seed tree. Thick squares/lines indicate
ring nodes/edges, while thin circles/lines indicate non-ring nodes/edges. (b) Ring nodes
are expanded to chordless 6-cycles. (c) Fringe-trees are assigned to every vertex and bond-
multiplicities are assigned to every edge. Fringe-trees of non-zero heights are indicated by
shade. The PubChem CID of the compound is 156839899, and the molecular formula is
C35H51N9O8.
(I) Each ring node u ∈V ◦is assigned a cycle-conﬁguration, by which u is “expanded” to
a chordless cycle in GT .
• If two ring nodes are joined by a ring edge, then the corresponding two chordless
cycles in GT share an edge in common.
• Each non-ring node in V (T) \ V ◦appears as a single vertex in GT .
• Each non-ring edge in E(T) \ E◦appears as a single edge in GT .
(II) The expanded graph is used as the interior of GT .
For the exterior, fringe-trees
are assigned to all nodes in the expanded graph, and to the interior-edges, bond-
multiplicities are assigned.
For the seed tree T = (T; V ◦, E◦) in Figure 2(a), we have V ◦= {u1, u2, . . . , u5}.
Suppose that we are given Ξu = {ξ1, ξ2, . . . , ξ6} for all ring nodes u ∈V ◦, where
ξ1 = (1, 1, 2, 3),
ξ2 = (1, 1, 1, 1, 2),
ξ3 = (1, 1, 1, 1, 1, 2),
ξ4 = (1, 1, 1, 1, 2, 3),
ξ5 = (1, 1, 1, 2, 1, 2),
ξ6 = (1, 2, 2, 4, 3, 2).
In this example, u1 is assigned ξ3; u2 and u3 are assigned ξ5; u4 is assigned ξ4; and u5 is
assigned ξ6, where ξ1 and ξ2 are assigned to no ring nodes. As shown in Figure 2(b), all ring
nodes are expanded to chordless 6-cycles, C1 to C5, where 6 = |ξ3| = |ξ4| = |ξ5| = |ξ6|.
We can conﬁrm that the CCs of the ﬁve corresponding chordless cycles in Figure 2(c)
are precisely ones that are assigned above. For example, in C4, there are four distinct
fringe-trees whose molecular formulas are N, CH2, CO, CH3N, where we denote them
by ψ1, ψ2, ψ3, ψ4, respectively.
We have mass∗(ψ1) = 14, mass∗(ψ2) = 12 + 2 = 14,
9


--- Page 10 ---
Table 2:
A description of speciﬁcation σ in the 2L+CC model (AC: adjacency-
conﬁguration; CC: cycle-conﬁguration; EC: edge-conﬁguration; FC: fringe-conﬁguration)
Symbol
Deﬁnition
T = (T; V ◦, E◦)
A seed tree
(A set of available chemical elements/conﬁgurations in GT )
Λ
Chemical elements
Ξu
CCs for u ∈V ◦, where ξ ∈Ξu satisﬁes cmin ≤|ξ| ≤cmax
Fu
FCs for u ∈V (T)
Γint
ac
ACs on interior-edges
Γlf
ac
ACs on leaf-edges
Γint
ec
ECs on interior-edges
(Lower/upper bounds on the numbers in GT )
nLB, nUB
The number of non-hydrogen atoms
naint
LB(a), naint
UB(a)
The number of chemical elements a ∈Λ in the interior
naex
LB(a), naex
UB(a)
The number of chemical elements a ∈Λ in the exterior
naLB(a), naUB(a)
The number of chemical elements a ∈Λ in GT
fcLB(ψ), fcUB(ψ)
The number of FCs ψ ∈FT := S
u∈V (T) Fu
acint
LB(γ), acint
UB(γ)
The number of ACs γ ∈Γint
ac in interior-edges
aclf
LB(γ), aclf
UB(γ)
The number of ACs γ ∈Γlf
ac in leaf-edges
ecint
LB(γ), ecint
UB(γ)
The number of ECs γ ∈Γint
ec in interior-edges
mass∗(ψ3) = 12 + 16 = 28 and mass∗(ψ4) = 12 + 3 + 14 = 29, where mass∗(ψ1) =
mass∗(ψ2) = 14, and hence ξ(C4) = (1, 1, 1, 1, 2, 3) = ξ4 holds.
As we observed in Section 3, CC descriptors can distinct how exteriors are attached
to a chordless cycle in a chemical graph (e.g., meta/para-isomers of an aromatic ring),
which is impossible by the original descriptors in the 2L model. Ring nodes are, however,
not necessarily universal; there is a set of chordless cycles that cannot be represented by
expanding ring nodes. For example:
(i) A pair of two chordless cycles that share exactly one point v.
(ii) A set of more than two chordless cycles that share one vertex or edge in common.
To infer C† that contains at least one of the above structures, one needs to make use of
non-ring nodes/edges appropriately in the design of a seed tree. We note that, however,
such chemical compounds are rather minor in conventional databases. See Table 1 again.
For example, in PubChem, among 83,520,760 molecules that are acyclic or contain only
chordless cycles whose lengths are within [4, 6], 80,842,345 molecules (96%) contain neither
(i) nor (ii).
Table 2 shows a description of the speciﬁcation σ in the 2L+CC model.
Besides
the seed tree, the speciﬁcation includes availability of chemical elements/conﬁgurations,
lower/upper bounds on their numbers.
5
Computational Experiments
In this section, we describe experimental results on Stages 3 (ML) and 4 (MILP) in mol-
infer. All experiments are conducted on a PC that carries Apple Silicon M1 CPU (3.2GHz)
and 8GB main memory. All source codes are written in Python with a machine learning
10


--- Page 11 ---
library scikit-learn of version 1.5.0.
The source codes and results are available at
https://github.com/ku-dml/mol-infer/tree/master/2LCC.
5.1
Experimental Setup (Stages 1 and 2)
We collected data sets for 27 chemical properties that are shown in Table 3. In these data
sets, the property value a(C) of a chemical graph C is a real number, and hence the ML
task in Stage 3 is regression. QM9 properties taken from [18] (i.e., Alpha, Cv, Gap,
Homo, Lumo, mu and U0) share the same data set in common. This original data set
contains more than 1.3 × 105 molecules and we use a subset of 103 molecules that are
randomly selected.
From the original data set, we exclude molecules that are not feasible in the 2L model
(e.g., the chemical graph is not connected). Furthermore, we decide the set Λ of available
chemical elements for each property π, by which chemical graphs that contain rare chemical
elements are eliminated.
Details of columns in Table 3 are described as follows.
• Λ \ {H}: the set of available chemical elements except hydrogen, where
Λ1 = {C(2), C(3), C(4), C(5), O, N(1), N(2), N(3), F}; Λ2 = {C, O, N, S(2), S(6), Cl}; Λ3 = {C, O};
Λ4 = {C, O, N}; Λ5 = {C(2), C(3), C(4), O, N(2), N(3), S(2), S(4)S(6), Cl}; Λ6 = {C, O, N, S(2),
S(4), S(6), Cl}; and Λ7 = {C, O, Si}.
• n and n: the minimum and maximum values of the number of non-hydrogen atoms
in C ∈Dπ.
• |Dπ|: the number of chemical graphs in the data set.
• K2L and KCC: the number of 2L and CC descriptors extracted from Dπ, respectively.
5.2
ML Experiments (Stage 3)
For each property π, we convert the data set Dπ into the set f(Dπ) of numerical vectors
by using a feature function f : G →RK. For f, we use f = f2L and f = f2L+CC, where
f2L+CC is a feature function such that f2L+CC(C) = (f2L(C), fCC(C)). The purpose of the
comparison is to show that CC descriptors can extract useful information for ML. The
number KCC of CC descriptors is at most 70% of the number K2L of 2L descriptors for
all data sets, as shown in Table 3.
For π, let D ⊆Dπ be a subset of the data set. To evaluate a prediction function
η : RK →R on D, we employ the determination of coeﬃcient (R2), which is deﬁned to be
R2(η, D) ≜1 −
P
C∈D(a(C) −η(f(C)))2
P
C∈D(a(C) −˜a)2
for ˜a =
1
|D|
X
C∈D
a(C).
We construct prediction functions based on Lasso linear regression (LLR) [27], decision
tree (DT) [22] and random forest (RF) [6]. We evaluate the performance of each learning
model by means of 10 repetitions of 5-fold cross validation. Speciﬁcally, for each property
π, we divide the data set Dπ into 5 subsets randomly, say Dπ,1, . . . , Dπ,5, so that |Dπ,i| −
|Dπ,j| ≤1 holds for i, j = 1, 2, . . . , 5. For each i = 1, 2, . . . , 5, we construct a prediction
function η from a subset Dπ \ Dπ,i as the training set and evaluate R2(η, Dπ,i) on the
remaining subset Dπ,i as the test set. We take as the evaluation criterion the median of
5 × 10 = 50 values of R2 observed over 10 repetitions of 5-fold cross validation.
11


--- Page 12 ---
Table 3: Summary of data sets
π (Description)
Ref.
Λ \ {H}
n, n
|Dπ|
K2L
KCC
Alpha (Isotropic polarizability)
[18]
Λ1
6,9
977
297
184
At (Autoignition temperature)
[2]
Λ2
4,85
448
255
65
Bhl (Biological half life)
[2]
Λ2
5,36
514
166
94
Bp (Boiling point)
[2]
Λ2
4,67
444
230
70
Cv (Heat Capacity at 298.15K)
[18]
Λ1
6,9
977
297
184
Dc (Dissociation constants)
[2]
Λ2
5,44
161
130
63
EDPA (Electron density on the most positive atom)
[15]
Λ3
11,16
52
64
6
Fp (Flash point in closed cup)
[2]
Λ2
4,67
424
229
70
Gap (Gap between Homo and Lumo)
[18]
Λ1
6,9
977
297
184
Hc (Heat of combustion)
[2]
Λ2
4,63
282
177
49
Homo (Energy of highest occupied molecular orbital)
[18]
Λ1
6,9
977
297
184
Hv (Heat of vaporization)
[2]
Λ4
4,16
95
105
16
IhcLiq (Isobaric heat capacities; liquid)
[20]
Λ4
4,78
770
256
74
IhcSol (Isobaric heat capacities; solid)
[20]
Λ5
5,70
668
228
118
KovRI (Kovats retention index)
[15]
Λ3
11,16
52
64
6
Kow (Octanol/water partition coeﬃcient)
[2]
Λ4
4,58
684
223
117
Lp (Lipophilicity)
[18]
Λ6
6,74
936
231
178
Lumo (Energy of lowest occupied molecular orbital)
[18]
Λ1
6,9
977
297
184
Mp (Melting point)
[2]
Λ6
4,122
577
255
108
mu (Electric dipole moment)
[18]
Λ1
6,9
977
297
184
OptR (Optical rotation)
[2]
Λ4
5,44
147
107
55
Sl (Solubility)
[18]
Λ6
4,55
915
300
175
SurfT (Surface tension)
[9]
Λ7
5,33
247
128
22
U0 (Internal energy at 0K)
[18]
Λ1
6,9
977
297
184
Vd (Vapor density)
[2]
Λ4
4,30
474
214
53
Visc (Viscosity)
[10]
Λ7
5,36
282
126
22
Vp (Vapor pressure)
[2]
Λ2
4,5
482
238
96
We show the results in Table 4. We may say that we can construct a good prediction
function for many data sets; in 19 (resp., 11) out of the 27 data sets, R2 over 0.8 (resp.,
0.9) is achieved. We observe that, for some data sets, there is a learning model that is
not suitable. For example, LLR attains poor performance for Vp, regardless of feature
functions, whereas DT and RF are relatively good.
Let us compare two feature functions, f2L and f2L+CC.
For each property π, an
underlined value indicates the maximum over the 6 values (= 2 feature functions by 3
learning models). The maximum is achieved for only 5 properties when f = f2L, whereas
it is up to 25 properties when f = f2L+CC. A bold-face (resp., *) indicates an R2 value
that is larger at least by 0.02 (resp., 0.05) than the R2 value achieved by the other feature
function and the same learning model. For example, for At, the R2 value 0.401 for f2L+CC
and RF is bold since it is larger than 0.379 for f2L and RF by 0.401−0.379 = 0.022 > 0.02.
A bold value (resp., *) appears only twice (resp., nowhere) when f = f2L, whereas it
appears 31 (resp., 16) times when f = f2L+CC.
We conclude that, in the 2L model, the learning performance of a prediction function
can be improved by introducing CC descriptors.
5.3
Inference Experiments (Stage 4)
For a property, deciding two reals y∗, y∗∈R and a speciﬁcation σ, we solve the MILP for
inferring a chemical graph C†. Recall that the MILP consists of two families of constraints,
that is (C1) y∗≤η(x) ≤y∗and x = f(C†); and (C2) C ∈Gσ. In this experiment, we
employ a hyperplane that is learned by LLR for the prediction function η. A hyperplane
is a prediction function that is represented by a pair (w, b) ∈RK × R and predicts the
property value of a feature vector x ∈RK by w(1)x(1) + · · · + w(K)x(K) + b. Hence, the
12


--- Page 13 ---
Table 4: ML results: medians of 50 values of R2
π
2L model (f = f2L)
2L+CC model (f = f2L+CC)
LLR
DT
RF
LLR
DT
RF
Alpha
.961
.769
.856
.961
.784
.875
At
.388
.368
.380
.405
.379
.401
Bhl
.483
.401
.555
.515
*.505
.555
Bp
.663
.729
.805
.701
.728
.824
Cv
.970
.805
.911
.979
.854
.911
Dc
.574
.408
.624
.607
*.476
.629
EDPA
.999
.999
.999
.999
.999
.999
Fp
.570
.572
.748
.564
*.645
.752
Gap
.783
.668
.733
.776
.712
*.786
Hc
.951
.826
.894
.924
.857
.894
Homo
.707
.391
.556
.703
.434
*.630
Hv
−13.744
.128
-0.058
*.817
*.554
*−0.001
IhcLiq
.986
.941
.961
.986
.948
.963
IhcSol
.981
.903
.952
.983
.908
.954
KovRI
.676
.352
.688
*.735
*.644
.688
Kow
.952
.854
.911
.960
.871
.923
Lp
.840
.598
.756
.855
.616
.796
Lumo
.841
.734
.796
.836
.759
.842
Mp
.785
.687
.805
*.836
.709
.839
mu
.365
.351
.433
.368
.400
.457
OptR
.822
.846
.891
*.933
.861
.871
Sl
.808
.783
.858
.817
.791
.873
SurfT
.803
.645
.840
.809
*.714
.840
U0
.999
.847
.932
.999
*.910
.932
Vd
.927
.924
.933
.927
.934
.934
Visc
.893
.860
.909
.894
.866
.910
Vp
−0.013
.771
.857
*.115
*.845
.861
constraint y∗≤η(x) ≤y∗in C1 is represented by
y∗≤
K
X
j=1
w(j)x(j) + b ≤y∗,
where use of a hyperplane in mol-infer was proposed in [31]. For the other constraints, see
Appendix B.
We take up two properties Kow and OptR, for which LLR achieves R2 over 0.9. We
consider 10 speciﬁcations that have seed trees non-isomorphic to each other, where 9 out
of the 10 seed trees are shown in Figure 3. These seed trees are introduced to observe
how computation time changes with respect to the number of nodes; the number of ring
edges; and the tree structure. The last seed tree is the one in Figure 2(a). We denote this
seed tree by T5∗. In each of the 10 speciﬁcations, we set other parameters (see Table 2)
than the seed tree suﬃciently large to the extent of the data set Dπ. For example, we set
Fu := F(Dπ) for every u ∈T, that is, all fringe trees that appear in Dπ are available to
u.
We solve the MILP by utilizing CPLEX [11] version 22.1.1.0. We summarize statistics
in Tables 5 and 6. The meanings of columns in the tables are described as follows.
• #V and #C: the number of variables and constraints in MILP, respectively.
• IP time: the computation time taken to solve the MILP.
• n(G†): the number of non-hydrogen atoms in the inferred chemical graph G†.
• η(f(G†)): an estimated property value of G† given by the prediction function η and
the feature vector f(G†), where f = f2L+CC.
13


--- Page 14 ---
T4a
T4b,0
T4b,1
T4b,2
T4b,3
T6a
T6b
T6b
T6d
Figure 3: Seed trees for the inference experiments: All nodes are ring nodes. A ring edge
(resp., a non-ring edge) is depicted by a thick (resp., thin) line.
Table 5: Statistics of MILPs for Kow: y∗and y∗are set to −7.53 and 15.60, respectively.
Seed tree
#V
#C
IP time (s)
n(G†)
η(f(G†))
T4a
15139
18145
5.2
18
3.30
T4b,0
15139
18145
4.6
18
3.64
T4b,1
14921
13843
4.1
18
3.64
T4b,2
14703
9541
38.4
25
−5.38
T4b,3
14485
5239
7.0
44
0.19
T6a
21743
27843
7.8
26
4.42
T6b
21743
27843
11.1
26
4.76
T6c
21743
27843
9.4
26
4.76
T6d
21743
27843
7.9
26
5.09
T5∗
19923
10329
59.0
46
−2.81
As shown in Tables 5 and 6, we can ﬁnd chemical graphs with up to 50 non-hydrogen
atoms in a practical time; the computation time is at most two minutes.
There is a
tendency such that computation time is longer when there are more #V/#C (i.e., the
numbers of variables/constraints in MILP) with some exceptions. For example, for Kow,
the case of T4b,2 takes 38.4 seconds, which is much more than the cases where there are
six ring nodes. Concerning #V/#C, the more the ring nodes, the more they become. The
#V/#C are equal between seed trees if they have the same numbers of ring nodes/edges;
e.g., #V/#C are equal between T4a and T4b,0.
We also show some of the inferred chemical graphs in Figure 4. As expected, ring nodes
in the seed trees are expanded to cycles in the chemical graphs. Some graphs contain 4-
cycles or ionized elements. We can prevent MILP from using such structures by setting
speciﬁcations appropriately.
6
Concluding Remarks
In this paper, we proposed a new family of descriptors, cycle-conﬁgurations, that can be
used in the standard 2L model of mol-infer. We introduced the deﬁnition in Section 3
and described how we deal with them in the MILP in Section 4. Then in Section 5, we
demonstrated that the performance of a prediction function is improved in many cases
when we introduce CC descriptors. We also showed that a chemical graph with up to 50
non-hydrogen atoms can be inferred in a practical time.
14


--- Page 15 ---
Table 6: Statistics of MILPs for OptR: y∗and y∗are set to −117.0 and 165.0, respectively.
Seed tree
#V
#C
IP time (s)
n(G†)
η(f(G†))
T4a
8229
11853
12.1
21
−53.06
T4b,0
8229
11853
13.0
25
−102.25
T4b,1
8122
9327
8.2
28
−48.79
T4b,2
8015
6801
28.8
30
45.47
T4b,3
7908
4275
13.1
25
26.16
T6a
11587
17875
13.7
34
−54.39
T6b
11587
17875
27.7
34
134.51
T6c
11587
17875
15.9
21
−92.59
T6d
11587
17875
117.8
37
−110.17
T5∗
10652
7527
48.7
36
−103.90
The 2L+CC model can be extended further in the similar way as the 2L model. Specif-
ically, we can enumerate isomers of the inferred graph by dynamic programming [32] or
generate “close” compounds in the sense of property values by a grid neighborhood ap-
proach [3].
Note that the constraint C1 of the MILP can contain multiple prediction
functions for multiple properties, as is done in [31], where we have included a single prop-
erty in this paper for simplicity. Besides, we may apply the 2L+CC model to inference of
polymers. These are left for future work.
15


--- Page 16 ---
O
_
O
O
_
O
+
N
_
O
O
O
O
O
_
O
_
O
T4a (Kow)
T4b,0 (Kow)
T4b,1 (Kow)
T4b,2 (Kow)
CH3
CH3
N
_
O
_
O
N
O
O
H3C
O
N
O
H3C
H2C
+
N
_
O
O
O
HO
_
O
O
O
OH
H3C
+
N
H
CH3
H3C
H3C
CH3
T4b,3 (Kow)
T5∗(OptR)
Figure 4: Inferred chemical graphs
16


--- Page 17 ---
References
[1] T. Akutsu and H. Nagamochi.
A mixed integer linear programming formulation
to artiﬁcial neural networks.
Technical Report 2019-001, Department of Applied
Mathematics and Physics, Graduate School of Informatics, Kyoto University, 2019.
[2] Annotations from HSDB (on PubChem).
https://pubchem.ncbi.nlm.nih.gov/,
accessed on July 1st, 2024.
[3] N. Azam, J. Zhu, K. Haraguchi, L. Zhao, H. Nagamochi, and T. Akutsu. Molecular
design based on artiﬁcial neural networks, integer programming and grid neighbor
search. In 2021 IEEE International Conference on Bioinformatics and Biomedicine
(BIBM), pages 360–363. IEEE Computer Society, 2021.
[4] N. A. Azam, R. Chiewvanichakorn, F. Zhang, A. Shurbevski, H. Nagamochi, and
T. Akutsu. A method for the inverse QSAR/QSPR based on artiﬁcial neural net-
works and mixed integer linear programming. In Proceedings of the 13th International
Joint Conference on Biomedical Engineering Systems and Technologies – Volume 3:
BIOINFORMATICS, pages 101–108, 2020.
[5] N. A. Azam, J. Zhu, Y. Sun, Y. Shi, A. Shurbevski, L. Zhao, H. Nagamochi, and
T. Akutsu. A novel method for inference of acyclic chemical compounds with bounded
branch-height based on artiﬁcial neural networks and integer programming. Algo-
rithms for Molecular Biology, 16:1–39, 2021.
[6] L. Breiman. Random forests. Machine Learning, 45:5–32, 2001.
[7] N. De Cao and T. Kipf. MolGAN: An implicit generative model for small molecular
graphs. arXiv preprint arXiv:1805.11973, 2018.
[8] R. G´omez-Bombarelli, J. N. Wei, D. Duvenaud, J. M. Hern´andez-Lobato, B. S´anchez-
Lengeling, D. Sheberla, J. Aguilera-Iparraguirre, T. D. Hirzel, R. P. Adams, and
A. Aspuru-Guzik. Automatic chemical design using a data-driven continuous repre-
sentation of molecules. ACS Central Science, 4:268–276, 2018.
[9] V. Goussard, F. Duprat, V. Gerbaud, J.-L. Ploix, G. Dreyfus, V. Nardello-Rataj, and
J.-M. Aubry. Predicting the surface tension of liquids: Comparison of four modeling
approaches and application to cosmetic oils. Journal of Chemical Information and
Modeling, 57(12):2986–2995, 2017.
[10] V. Goussard, F. Duprat, J.-L. Ploix, G. Dreyfus, V. Nardello-Rataj, and J.-M. Aubry.
A new machine-learning tool for fast estimation of liquid viscosity. application to
cosmetic oils. Journal of Chemical Information and Modeling, 60(4):2012–2023, 2020.
[11] IBM ILOG CPLEX Optimization Studio. https://www.ibm.com/products/ilog-cplex-optimization
accessed on July 1st, 2024.
[12] R. Ido, S. Cao, J. Zhu, N. A. Azam, K. Haraguchi, L. Zhao, H. Nagamochi, and
T. Akutsu. A method for inferring polymers based on linear regression and integer
programming. arXiv preprint arXiv:2109.02628, 2021. Presented at The 20th Asia
Paciﬁc Bioinformatics Conference (APBC2022) April 26-28, 2022.
17


--- Page 18 ---
[13] H. Ikebata, K. Hongo, T. Isomura, R. Maezono, and R. Yoshida. Bayesian molecular
design with a chemical language model. Journal of Computer-aided Molecular Design,
31:379–391, 2017.
[14] R. Ito, N. A. Azam, C. Wang, A. Shurbevski, H. Nagamochi, and T. Akutsu. A novel
method for the inverse QSAR/QSPR to monocyclic chemical compounds based on
artiﬁcial neural networks and integer programming. In Advances in Computer Vision
and Computational Biology: Proceedings from IPCV’20, HIMS’20, BIOCOMP’20,
and BIOENG’20, pages 641–655. Springer, 2021.
[15] M. Jalali-Heravi and M. Fatemi. Artiﬁcial neural network modeling of kov´ats reten-
tion indices for noncyclic and monocyclic terpenes. Journal of Chromatography A,
915(1):177–183, 2001.
[16] K. Madhawa, K. Ishiguro, K. Nakago, and M. Abe. GraphNVP: an invertible ﬂow
model for generating molecular graphs. arXiv preprint arXiv:1905.11600, 2019.
[17] T. Miyao, H. Kaneko, and K. Funatsu. Inverse QSPR/QSAR analysis for chemical
structure generation (from y to x). Journal of Chemical Information and Modeling,
56:286–299, 2016.
[18] MoleculeNet. http://moleculenet.org, accessed on July 1st, 2024.
[19] D. Morgan and R. Jacobs.
Opportunities and challenges for machine learning in
materials science. Annual Review of Materials Research, 50:71–103, 2020.
[20] R. Naef. Calculation of the isobaric heat capacities of the liquid and solid phase of
organic compounds at and a round 298.15 k based on their ”True” molecular volume.
Molecules, 24(8), 2019.
[21] O. Prykhodko, S. V. Johansson, P.-C. Kotsias, J. Ar´us-Pous, E. J. Bjerrum, O. En-
gkvist, and H. Chen. A de novo molecular generation method using latent vector
based generative adversarial network. Journal of Cheminformatics, 11:1–13, 2019.
[22] J. R. Quinlan. Induction of decision trees. Machine Learning, 1:81–106, 1986.
[23] C. Rupakheti, A. Virshup, W. Yang, and D. N. Beratan. Strategy to discover di-
verse optimal molecules in the small molecule universe. Journal of Cheminformatics,
55:529–537, 2015.
[24] C. Shi, M. Xu, Z. Zhu, W. Zhang, M. Zhang, and J. Tang. GraphAF: a ﬂow-based au-
toregressive model for molecular graph generation. arXiv preprint arXiv:2001.09382,
2020.
[25] Y. Shi, J. Zhu, N. A. Azam, K. Haraguchi, L. Zhao, H. Nagamochi, and T. Akutsu.
An inverse QSAR method based on a two-layered model and integer programming.
International Journal of Molecular Sciences, 22:2847, 2021.
[26] K. Tanaka, J. Zhu, N. A. Azam, K. Haraguchi, L. Zhao, H. Nagamochi, and
T. Akutsu. An inverse QSAR method based on decision tree and integer program-
ming. In Proceedings of The 17th International Conference on Intelligent Computing,
Lecture Notes in Computer Science, vol. 12837, pages 628–644, August in Shenzhen,
China, 2021.
18


--- Page 19 ---
[27] R. Tibshirani. Regression shrinkage and selection via the lasso. Journal of the Royal
Statistical Society: Series B (Methodological), 58:267–288, 1996.
[28] B. Zdrazil, E. Felix, F. Hunter, E. J. Manners, J. Blackshaw, S. Corbett, M. de Veij,
H. Ioannidis, D. M. Lopez, J. Mosquera, M. Magarinos, N. Bosc, R. Arcila,
T. Kizil¨oren, A. Gaulton, A. Bento, M. Adasme, P. Monecke, G. Landrum, and
A. Leach. The ChEMBL Database in 2023: a drug discovery platform spanning mul-
tiple bioactivity data types and time periods. Nucleic Acids Research, 52(D1):D1180–
D1192, 2023.
[29] F. Zhang, J. Zhu, R. Chiewvanichakorn, A. Shurbevski, H. Nagamochi, and
T. Akutsu. A new approach to the design of acyclic chemical compounds using skele-
ton trees and integer linear programming. Applied Intelligence, 52(15):17058–17072,
2022.
[30] J. Zhu. Novel Methods for Chemical Compound Inference Based on Machine Learning
and Mixed Integer Linear Programming. PhD thesis, Kyoto University, Sep 2023.
[31] J. Zhu, N. A. Azam, K. Haraguchi, L. Zhao, H. Nagamochi, and T. Akutsu. An
inverse QSAR method based on linear regression and integer programming. Frontiers
in Bioscience-Landmark, 27(6):188, 2022. The preprint appears as arXiv:2107.02381.
[32] J. Zhu, N. A. Azam, F. Zhang, A. Shurbevski, K. Haraguchi, L. Zhao, H. Nagamochi,
and T. Akutsu. A novel method for inferring chemical compounds with prescribed
topological substructures based on integer programming. IEEE/ACM Transactions
on Computational Biology and Bioinformatics, 19(6):3233–3245, 2021.
[33] J. Zhu, C. Wang, A. Shurbevski, H. Nagamochi, and T. Akutsu. A novel method for
inference of chemical compounds of cycle index two with desired properties based on
artiﬁcial neural networks and integer programming. Algorithms, 13:124, 2020.
19


--- Page 20 ---
Appendix
A
A Full Description of Descriptors in the 2L Model
Associated with the two functions α and β in a chemical graph C = (H, α, β), we introduce
functions ac : V (E) →(Λ \ {H}) × (Λ \ {H}) × [1, 3], cs : V (E) →(Λ \ {H}) × [1, 4] and
ec : V (E) →((Λ \ {H}) × [1, 4]) × ((Λ \ {H}) × [1, 4]) × [1, 3] in the following.
To represent a feature of the exterior of C, a chemical rooted tree in T (C) is called a
fringe-conﬁguration of C.
We also represent leaf-edges in the exterior of C.
For a leaf-edge uv ∈E(⟨C⟩)
with deg⟨C⟩(u) = 1, we deﬁne the adjacency-conﬁguration of e to be an ordered tuple
(α(u), α(v), β(uv)). Deﬁne
Γlf
ac ≜{(a, b, m) | a, b ∈Λ, m ∈[1, min{val(a), val(b)}]}
as a set of possible adjacency-conﬁgurations for leaf-edges.
To represent a feature of an interior-vertex v ∈V int(C) such that α(v) = a and
deg⟨C⟩(v) = d (i.e., the number of non-hydrogen atoms adjacent to v is d) in a chemical
graph C = (H, α, β), we use a pair (a, d) ∈(Λ \ {H}) × [1, 4], which we call the chemical
symbol cs(v) of the vertex v. We treat (a, d) as a single symbol ad, and deﬁne Λdg to be
the set of all chemical symbols µ = ad ∈(Λ \ {H}) × [1, 4].
We deﬁne a method for featuring interior-edges as follows.
Let e = uv ∈Eint(C)
be an interior-edge e = uv ∈Eint(C) such that α(u) = a, α(v) = b and β(e) = m
in a chemical graph C = (H, α, β). To feature this edge e, we use a tuple (a, b, m) ∈
(Λ \ {H}) × (Λ \ {H}) × [1, 3], which we call the adjacency-conﬁguration ac(e) of the edge e.
We introduce a total order < over the elements in Λ to distinguish between (a, b, m) and
(b, a, m) (a ̸= b) notationally. For a tuple ν = (a, b, m), let ν denote the tuple (b, a, m).
Let e = uv ∈Eint(C) be an interior-edge e = uv ∈Eint(C) such that cs(u) = µ,
cs(v) = µ′ and β(e) = m in a chemical graph C = (H, α, β). To feature this edge e, we
use a tuple (µ, µ′, m) ∈Λdg × Λdg × [1, 3], which we call the edge-conﬁguration ec(e) of
the edge e. We introduce a total order < over the elements in Λdg to distinguish between
(µ, µ′, m) and (µ′, µ, m) (µ ̸= µ′) notationally. For a tuple γ = (µ, µ′, m), let γ denote the
tuple (µ′, µ, m).
Let π be a chemical property for which we will construct a prediction function η from
a feature vector f(C) of a chemical graph C to a predicted value y ∈R for the chemical
property of C.
We ﬁrst choose a set Λ of chemical elements and then collect a data set Dπ of chem-
ical compounds C whose chemical elements belong to Λ, where we regard Dπ as a set
of chemical graphs C that represent the chemical compounds C in Dπ. To deﬁne the
interior/exterior of chemical graphs C ∈Dπ, we next choose a branch-parameter ρ, where
we recommend ρ = 2.
Let Λint(Dπ) ⊆Λ (resp., Λex(Dπ) ⊆Λ) denote the set of chemical elements used in
the set V int(C) of interior-vertices (resp., the set V ex(C) of exterior-vertices) of C over all
chemical graphs C ∈Dπ, and Γint(Dπ) denote the set of edge-conﬁgurations used in the
set Eint(C) of interior-edges in C over all chemical graphs C ∈Dπ. Let F(Dπ) denote
the set of chemical rooted trees ψ r-isomorphic to a chemical rooted tree in T (C) over all
chemical graphs C ∈Dπ, where possibly a chemical rooted tree ψ ∈F(Dπ) consists of a
single chemical element a ∈Λ \ {H}.
We deﬁne an integer encoding of a ﬁnite set A of elements to be a bijection π : A →
[1, |A|], where we denote by [A] the set [1, |A|] of integers. Introduce an integer coding of
20


--- Page 21 ---
each of the sets Λint(Dπ), Λex(Dπ), Γint(Dπ) and F(Dπ). Let [a]int (resp., [a]ex) denote
the coded integer of an element a ∈Λint(Dπ) (resp., a ∈Λex(Dπ)), [γ] denote the coded
integer of an element γ in Γint(Dπ) and [ψ] denote an element ψ in F(Dπ).
Over 99% of chemical compounds C with up to 100 non-hydrogen atoms in PubChem
have degree at most 4 in the hydrogen-suppressed graph ⟨C⟩[5].
We assume that a
chemical graph C treated in this paper satisﬁes deg⟨C⟩(v) ≤4 in the hydrogen-suppressed
graph ⟨C⟩.
In our model, we use an integer mass∗(a) = ⌊10 · mass(a)⌋, for each a ∈Λ.
For a chemical property π, we deﬁne a set D(1)
π
of descriptors of a chemical graph
C = (H, α, β) ∈Dπ to be the following non-negative values dcpi(C), i ∈[1, K2L], where
K2L = 14 + |Λint(Dπ)| + |Λex(Dπ)| + |Γint(Dπ)| + |F(Dπ)| + |Γlf
ac|.
1. dcp1(C): the number |V (H)| −|VH| of non-hydrogen atoms in C.
2. dcp2(C): the rank of C (i.e., the minimum number of edges to be removed to make
the graph acyclic).
3. dcp3(C): the number |V int(C)| of interior-vertices in C.
4. dcp4(C): the average ms(C) of mass∗over all atoms in C;
i.e., ms(C) ≜
1
|V (H)|
P
v∈V (H) mass∗(α(v)).
5. dcpi(C), i = 4 + d, d ∈[1, 4]: the number dgH
d(C) of non-hydrogen vertices v ∈
V (H) \ VH of degree deg⟨C⟩(v) = d in the hydrogen-suppressed chemical graph ⟨C⟩.
6. dcpi(C), i = 8 + d, d ∈[1, 4]: the number dgint
d (C) of interior-vertices of interior-
degree degCint(v) = d in the interior Cint = (V int(C), Eint(C)) of C.
7. dcpi(C), i = 12 + m, m ∈[2, 3]: the number bdint
m (C) of interior-edges with bond
multiplicity m in C; i.e., bdint
m (C) ≜|{e ∈Eint(C) | β(e) = m}|.
8. dcpi(C), i = 14 + [a]int, a ∈Λint(Dπ): the frequency naint
a (C) = |Va(C) ∩V int(C)| of
chemical element a in the set V int(C) of interior-vertices in C.
9. dcpi(C), i = 14 + |Λint(Dπ)| + [a]ex, a ∈Λex(Dπ): the frequency naex
a (C) = |Va(C) ∩
V ex(C)| of chemical element a in the set V ex(C) of exterior-vertices in C.
10. dcpi(C), i = 14 + |Λint(Dπ)| + |Λex(Dπ)| + [γ], γ ∈Γint(Dπ): the frequency ecγ(C)
of edge-conﬁguration γ in the set Eint(C) of interior-edges in C.
11. dcpi(C), i = 14+|Λint(Dπ)|+|Λex(Dπ)|+|Γint(Dπ)|+[ψ], ψ ∈F(Dπ): the frequency
fcψ(C) of fringe-conﬁguration ψ in the set of ρ-fringe-trees in C.
12. dcpi(C), i = 14 + |Λint(Dπ)| + |Λex(Dπ)| + |Γint(Dπ)| + |F(Dπ)| + [ν], ν ∈Γlf
ac: the
frequency aclf
ν (C) of adjacency-conﬁguration ν in the set of leaf-edges in ⟨C⟩.
B
MILP Formulation for the 2L+CC Model
Let T = (T; V ◦, E◦) denote a seed tree. Each ring node u ∈V ◦is expanded to a cycle
whose length is between cmin and cmax.
This expansion is done by assigning ξ ∈Ξ
to u, where Ξu is the set of cycle-conﬁgurations available to u such that every ξ ∈Ξ
satisﬁes cmin ≤|ξ| ≤cmax. Strictly speaking, a ring node u ∈V ◦is assigned a graph Cu
21


--- Page 22 ---
such that V (Cu) = {u1, u2, . . . , ucmax} and E(Cu) = {eu
1, eu
2, . . . , eu
2cmax−cmin}, where, for
i ∈[1, 2cmax −cmin],
eu
i =
 uiui+1
if i ≤cmax,
u1ui−cmax+cmin−1
otherwise,
and we regard ucmax+1 = u1 for convenience. The vertices and edges that form the cycle
are chosen according to |ξ|, where ξ is the cycle-conﬁguration assigned to u. Speciﬁcally,
vertices u1, u2, . . . , u|ξ| and edges u1u2, . . . , u|ξ|−1u|ξ|, u|ξ|u1 are chosen.
For a cycle-conﬁguration ξ and r ∈[1, cmax], let us deﬁne
ˆξ+(r) ≜{(µ, µ0) | µ, µ0 ∈{u1, . . . , u|ξ|}, ξ(µ −µ0 + 1) = r};
ˆξ−(r) ≜{(µ, µ0) | µ, µ0 ∈{u1, . . . , u|ξ|}, ξ(µ0 −µ + 1) = r},
and for µ ∈V (Cu) and δ ∈{+, −}, we let
ˆξδ(r, µ) := {µ0 ∈V (Cu) | (µ, µ0) ∈ˆξδ(r)}.
B.1
Assigning Cycle-Conﬁgurations to Ring Nodes
Constants.
• A seed tree T = (T; V ◦, E◦);
• the set Ξu of available cycle-conﬁgurations for each u ∈V ◦, ΞT := S
u∈V ◦Ξu;
• a positive constant ε1 ∈R+ that represents a suﬃciently small number;
• a positive constant M1 ∈R+ that represents a suﬃciently large number.
Variables.
• Real variables yu
[µ], u ∈V ◦, µ ∈V (Cu) that store the mass sum in the fringe-tree
attached to vertex µ ∈V (Cu);
• real variables zu
r , u ∈V ◦, r ∈[1, cmax] that represent the r-th smallest mass sum of
a fringe-tree in Cu;
• binary variables xu
[ξ],[µ0],δ, u ∈V ◦, ξ ∈Ξu, µ0 ∈{u1, . . . , u|ξ|} and δ ∈{+, −},
indicating whether ξ is assigned to the starting point µ0 in the direction δ;
• binary variables xu
[ξ], u ∈V ◦, ξ ∈Ξu, indicating whether ξ is assigned to Cu;
• integer variables cc([ξ]), ξ ∈ΞT , cycle-conﬁgurations.
Constraints.
22


--- Page 23 ---
For each u ∈V ◦:
0 ≤zu
1 , . . . , zu
cmax ≤M1,
(1)
zu
r + ε1 ≤zu
r+1,
r ∈[1, cmax −1];
(2)
xu
[ξ] =
X
µ0∈{u1,...,u|ξ|}
X
δ∈{+,−}
xu
[ξ],[µ0],δ,
ξ ∈Ξu;
(3)
X
ξ∈Ξu
xu
[ξ] = 1;
(4)
yu
[µ] ≤zu
r + M1
 1 −
X
ξ∈Ξu
X
δ∈{+,−}
X
µ0∈ˆξδ(r,µ)
xu
[ξ],[µ0],δ

,
r ∈[1, cmax], µ ∈V (Cu);
(5)
yu
[µ] ≥zu
r −M1
 1 −
X
ξ∈Ξu
X
δ∈{+,−}
X
µ0∈ˆξδ(r,µ)
xu
[ξ],[µ0],δ

,
r ∈[1, cmax], µ ∈V (Cu).
(6)
For each ξ ∈ΞT :
cc([ξ]) =
X
u∈V ◦,ξ∈Ξu
xu
[ξ],
(7)
B.2
Associating Ring Nodes with Ring Edges
Variables.
• Binary variables eu
i , u ∈V ◦, i ∈[1, 2cmax −cmin], indicating whether the edge ei in
Cu is used;
• binary variables xedge,u
[e],[ν] , u ∈V ◦, e ∈E◦(u), ν ∈E(Cu);
• binary variables xnode,u
[e′],[µ] , u ∈V ◦, e′ ∈¯E◦(u), µ ∈V (Cu);
Constraints.
For each u ∈V ◦:
X
ν∈E(Cu)
xedge,u
[e],[ν] = 1,
e ∈E◦(u);
(8)
X
µ∈V (Cu)
xnode,u
[e′],[µ] = 1,
e′ ∈¯E◦(u);
(9)
X
e∈E◦(u)
X
ν∈(E(Cu))(µ)
xedge,u
[e],[ν] ≤1,
µ ∈V (Cu);
(10)
X
e∈E◦(u)
xedge,u
[e],[ν] ≤1,
ν ∈E(Cu);
(11)
23


--- Page 24 ---
For each u ∈V ◦:
eu
i = 1,
i ∈[1, cmin −1];
eu
i =
X
ξ∈Ξu,|ξ|>i
xu
[ξ],
i ∈[cmin, cmax −2];
eu
i =
X
ξ∈Ξu,|ξ|=cmax
xu
[ξ],
i ∈{cmax −1, cmax};
eu
i =
X
ξ∈Ξu,|ξ|=i−cmax+cmin−1
xu
[ξ],
i ∈[cmax + 1, 2cmax −cmin];
(12)
xedge,u
[e],i
≤eu
i ,
e ∈E◦(u), i ∈[1, 2cmax −cmin];
(13)
xnode,u
[e′],i
≤
X
ξ∈Ξu,|ξ|≥i
xu
[ξ],
e′ ∈¯E◦(u), i ∈[cmin + 1, cmax];
(14)
B.3
Constraints for Including Fringe-Trees
For a leaf-edge uv ∈E(GT ) with degGT (u) = 1, we deﬁne the adjacency-conﬁguration of
uv to be an ordered tuple (α(u), α(v), β(uv)).
Constants.
• The set Fu of the available fringe-trees for each u ∈V (T), FT := S
u∈V (T) Fu;
• the set Γlf
ac of available adjacency-conﬁguration on the set of leaf-edges;
• functions msF(ψ), htF(ψ), nH(ψ), aclf
γ (ψ) denoting the mass, height, number of non-
hydrogen non-root atoms, number of leaf-edge adjacency-conﬁgurations γ of the
fringe-tree ψ, respectively;
• integers nLB, nUB, that represent the lower and upper bounds on the number of
non-hydrogen atoms in GT , respectively;
• integers nint
LB, nint
UB, that represent the lower and upper bounds on the number of
non-hydrogen atoms in the interior part of GT , respectively;
• integers fcLB(ψ), fcUB(ψ) ∈[0, nUB], ψ ∈FT , that represent the lower and upper
bounds on the fringe-conﬁgurations, respectively;
• integers aclf
LB(γ), aclf
UB(γ) ∈[0, nUB], γ ∈Γlf
ac, that represent the lower and upper
bounds on the adjacency-conﬁgurations of leaf-edges, respectively;
Variables.
• Binary variables δF(u, [µ]; [ψ]), u ∈V ◦, µ ∈V (Cu), ψ ∈Fu, indicating whether the
fringe-tree ψ is attached to vertex µ ∈V (Cu);
• binary variables δF(v; [ψ]), v ∈V (T)\V ◦, ψ ∈Fv, indicating whether the fringe-tree
ψ is attached to node v ∈V (T) \ V ◦;
• integer variables fc([e]; [ψ]) ∈[0, 2], e ∈E◦, ψ ∈FT , that stores the number of the
fringe-tree ψ is used in the ring edge e ∈E◦;
24


--- Page 25 ---
• integer variable rank that represents the rank of GT ;
• integer variables nG ∈[nLB, nUB], nint ∈[nint
LB, nint
UB] that represents the number of
non-hydrogen atoms in GT and the interior part of GT , respectively;
• integer variables fc([ψ]) ∈[fcLB(ψ), fcUB(ψ)], ψ ∈FT that stores the fringe-conﬁgurations;
• integer variables aclf([γ]) ∈[aclf
LB(γ), aclf
UB(γ)], γ ∈Γlf
ac, that stores the adjacency-
conﬁgurations of leaf-edges;
Constraints.
For each u ∈V ◦, µ ∈V (Cu):
X
ψ∈Fu
δF(u, [µ]; [ψ]) =
X
ξ∈Ξu,|ξ|≥[µ]
xu
[ξ];
(15)
X
ψ∈Fu
msF(ψ) · δF(u, [µ]; [ψ]) = yu
[µ];
(16)
For each v ∈V (T) \ V ◦:
X
ψ∈Fv
δF(v; [ψ]) = 1,
X
ψ∈Fv,htF(ψ)=ρ
δF(v; [ψ]) = 1,
v is a leaf of T;
(17)
For each e = uu′ ∈E◦such that [u] < [u′]:
X
ψ∈Fu
[ψ] · δF(u, i1; [ψ]) −
X
ψ∈Fu′
[ψ] · δF(u′, j2; [ψ]) ≤|FT |(2 −xedge,u
[e],[ν] −xedge,u′
[e],[ν′] ),
X
ψ∈Fu
[ψ] · δF(u, i1; [ψ]) −
X
ψ∈Fu′
[ψ] · δF(u′, j2; [ψ]) ≥|FT |(xedge,u
[e],[ν] + xedge,u′
[e],[ν′] −2),
X
ψ∈Fu
[ψ] · δF(u, i2; [ψ]) −
X
ψ∈Fu′
[ψ] · δF(u′, j1; [ψ]) ≤|FT |(2 −xedge,u
[e],[ν] −xedge,u′
[e],[ν′] ),
X
ψ∈Fu
[ψ] · δF(u, i2; [ψ]) −
X
ψ∈Fu′
[ψ] · δF(u′, j1; [ψ]) ≥|FT |(xedge,u
[e],[ν] + xedge,u′
[e],[ν′] −2),
ν = ui1ui2 ∈E(Cu), ν′ = u′
j1u′
j2 ∈E(Cu′)
such that i1 < i2, j1 < j2;
(18)
fc([e]; [ψ]) −δF(u, i1; [ψ]) −δF(u, i2; [ψ]) ≤2(1 −xedge,u
[e],[ν] ),
fc([e]; [ψ]) −δF(u, i1; [ψ]) −δF(u, i2; [ψ]) ≥2(xedge,u
[e],[ν] −1),ν = ui1ui2 ∈E(Cu), ψ ∈FT ;
(19)
For each ψ ∈FT :
fc([ψ]) =
X
u∈V ◦
X
µ∈V (Cu)
δF(u, [µ]; [ψ]) +
X
v∈V (T)\V ◦
δF(v; [ψ]) −
X
e∈E◦
fc([e]; [ψ]);
(20)
25


--- Page 26 ---
For each γ ∈Γlf
ac:
aclf([γ]) =
X
ψ∈FT
aclf
γ (ψ)fc([ψ]);
(21)
rank = |V ◦|;
(22)
nint =
X
u∈V ◦
X
ξ∈Ξu
|ξ| · xu
[ξ] + |V (T) \ V ◦| −2|E◦|;
(23)
nG = nint +
X
ψ∈FT
nH(ψ)fc([ψ]);
(24)
B.4
Descriptors for the Number of Speciﬁed Degree
Constants.
• Function degH(ψ) denoting the degree of the root of the fringe tree ψ;
Variables.
• Binary variables δdeg(u, [µ]; d), u ∈V ◦, µ ∈V (Cu), d ∈[1, 4], indicating the degree
of µ in GT ;
• binary variables δdeg(v; d), v ∈V (T)\V ◦, d ∈[1, 4], indicating the degree of v in GT ;
• binary variables δint
deg(u, [µ]; d), u ∈V ◦, µ ∈V (Cu), d ∈[1, 4], indicating the interior
degree of µ in GT ;
• binary variables δint
deg(v; d), v ∈V (T) \ V ◦, d ∈[1, 4], indicating the interior degree of
v in GT ;
• integer variables dg(d), d ∈[1, 4], that stores the number of vertices with degree d in
GT ;
• integer variables degint(d), d ∈[1, 4], that stores the number of vertices with interior
degree d in GT ;
• integer variables dg([e]; d) ∈[0, 2], e ∈E◦, d ∈[1, 4], that stores the number of
vertices with degree d in the ring edge e;
• integer variables degint([e]; d) ∈[0, 2], e ∈E◦, d ∈[1, 4], that stores the number of
vertices with interior degree d in the ring edge e;
• integer variables dgedge,u
[e],[µ],+, u ∈V ◦, µ ∈V (Cu), e ∈E◦(u), indicating the degree other
than that of the ring edge e at µ in Cu;
• integer variables dgedge,u
[e],[µ],−, u ∈V ◦, µ ∈V (Cu), e ∈E◦(u), indicating the augmented
degree for µ because of the ring edge e;
Constraints.
26


--- Page 27 ---
For each u ∈V ◦, µ ∈V (Cu):
0 ≤dgedge,u
[e],[µ],+ ≤4
X
ν∈(E(Cu))(µ)
xedge,u
[e],[ν]
e ∈E◦(u);
0 ≤dgedge,u
[e],[µ],−≤4
X
ν∈(E(Cu))(µ)
xedge,u
[e],[ν]
e ∈E◦(u);
(25)
4(xedge,u
[e],[ν] −1) ≤dgedge,u
[e],[µ],+ −1 −
X
e′∈¯E◦(u)
xnode,u
[e′],[µ] ≤4(1 −xedge,u
[e],[ν] ),
e ∈E◦(u), ν ∈(E(Cu))(µ);
(26)
For each e = uu′ ∈E◦such that [u] < [u′]:
3(xedge,u
[e],[ν] + xedge,u′
[e],[ν′] −2) ≤dgedge,u
[e],i1,−−dgedge,u′
[e],j2,+ ≤3(2 −xedge,u
[e],[ν] −xedge,u′
[e],[ν′] ),
3(xedge,u
[e],[ν] + xedge,u′
[e],[ν′] −2) ≤dgedge,u
[e],i2,−−dgedge,u′
[e],j1,+ ≤3(2 −xedge,u
[e],[ν] −xedge,u′
[e],[ν′] ),
3(xedge,u
[e],[ν] + xedge,u′
[e],[ν′] −2) ≤dgedge,u′
[e],j2,−−dgedge,u
[e],i1,+ ≤3(2 −xedge,u
[e],[ν] −xedge,u′
[e],[ν′] ),
3(xedge,u
[e],[ν] + xedge,u′
[e],[ν′] −2) ≤dgedge,u′
[e],j1,−−dgedge,u
[e],i2,+ ≤3(2 −xedge,u
[e],[ν] −xedge,u′
[e],[ν′] ),
ν = ui1ui2 ∈E(Cu), ν′ = u′
j1u′
j2 ∈E(Cu′)
such that i1 < i2, j1 < j2;
(27)
For each u ∈V ◦, µ ∈V (Cu):
X
d∈[1,4]
δdeg(u, [µ]; d) =
X
ξ∈Ξu,|ξ|≥[µ]
xu
[ξ];
(28)
2(
X
ξ∈Ξu,|ξ|≥[µ]
xu
[ξ] −1) ≤
X
d∈[1,4]
d · δdeg(u, [µ]; d)−
(2 +
X
ψ∈Fu
degH(ψ)δF(u, [µ]; [ψ]) +
X
e′∈¯E◦(u)
xnode,u
[e′],[µ] +
X
e∈E◦(u)
dgedge,u
[e],[µ],−);
X
d∈[1,4]
d · δdeg(u, [µ]; d) ≤2 +
X
ψ∈Fu
degH(ψ)δF(u, [µ]; [ψ])
+
X
e′∈¯E◦(u)
xnode,u
[e′],[µ] +
X
e∈E◦(u)
dgedge,u
[e],[µ],−);
(29)
X
d∈[1,4]
δint
deg(u, [µ]; d) =
X
ξ∈Ξu,|ξ|≥[µ]
xu
[ξ];
(30)
2(
X
ξ∈Ξu,|ξ|≥[µ]
xu
[ξ] −1) ≤
X
d∈[1,4]
d · δint
deg(u, [µ]; d) −(2 +
X
e′∈¯E◦(u)
xnode,u
[e′],[µ] +
X
e∈E◦(u)
dgedge,u
[e],[µ],−);
X
d∈[1,4]
d · δint
deg(u, [µ]; d) ≤2 +
X
e′∈¯E◦(u)
xnode,u
[e′],[µ] +
X
e∈E◦(u)
dgedge,u
[e],[µ],−);
(31)
27


--- Page 28 ---
For each v ∈V (T) \ V ◦:
X
d∈[1,4]
δdeg(v; d) = 1;
(32)
X
d∈[1,4]
d · δdeg(v; d) = |NT (v)| +
X
ψ∈Fv
degH(ψ)δF(v; [ψ]);
(33)
X
d∈[1,4]
δint
deg(v; d) = 1;
(34)
X
d∈[1,4]
d · δint
deg(v; d) = |NT (v)|;
(35)
For each e = uu′ ∈E◦such that [u] < [u′]:
dg([e]; d) −δdeg(u, i1; d) −δdeg(u, i2; d) ≤2(1 −xedge,u
[e],[ν] ),
dg([e]; d) −δdeg(u, i1; d) −δdeg(u, i2; d) ≥2(xedge,u
[e],[ν] −1),ν = ui1ui2 ∈E(Cu), d ∈[1, 4]
(36)
degint([e]; d) −δint
deg(u, i1; d) −δint
deg(u, i2; d) ≤2(1 −xedge,u
[e],[ν] ),
degint([e]; d) −δint
deg(u, i1; d) −δint
deg(u, i2; d) ≥2(xedge,u
[e],[ν] −1),ν = ui1ui2 ∈E(Cu), d ∈[1, 4]
(37)
For each d ∈[1, 4]:
dg(d) =
X
u∈V ◦
X
µ∈V (Cu)
δdeg(u, [µ]; d) +
X
v∈V (T)\V ◦
δdeg(v; d) −
X
e∈E◦
dg([e]; d);
(38)
degint(d) =
X
u∈V ◦
X
µ∈V (Cu)
δint
deg(u, [µ]; d) +
X
v∈V (T)\V ◦
δint
deg(v; d) −
X
e∈E◦
degint([e]; d);
(39)
B.5
Assigning Bond-Multiplicity
Variables.
• Integer variables βu
i ∈[0, 3], u ∈V ◦, i ∈[1, 2cmax −cmin], that stores the bond-
multiplicty of the edge ei in Cu;
• integer variables β[e] ∈[1, 3], e ∈E(T), that stores the bond-multiplicty of the edge
e;
• binary variables δβ(u, i; m), u ∈V ◦, i ∈[1, 2cmax −cmin], m ∈[1, 3], δβ(u, i; m) = 1 ⇔
βu
i = m;
• binary variables δβ([e]; m), e ∈E(T), m ∈[1, 3], δβ([e]; m) = 1 ⇔β[e] = m;
• integer variables bd(m), m ∈[1, 3], that stores the number of edges with bond-
multiplicty m;
Constraints.
eu
i ≤βu
i ≤3eu
i ,
u ∈V ◦, i ∈[1, 2cmax −cmin];
(40)
1 ≤β[e] ≤3,
e ∈E(T);
(41)
28


--- Page 29 ---
X
m∈[1,3]
δβ(u, i; m) = eu
i ,
X
m∈[1,3]
m · δβ(u, i; m) = βu
i ,
u ∈V ◦, i ∈[1, 2cmax −cmin];
(42)
X
m∈[1,3]
δβ([e]; m) = 1,
X
m∈[1,3]
m · δβ([e]; m) = β[e],
e ∈E(T);
(43)
For each u ∈V ◦, e ∈E◦(u):
3(xedge,u
[e],i
−1) ≤βu
i −β[e] ≤3(1 −xedge,u
[e],i
),
i ∈[1, 2cmax −cmin];
(44)
For each m ∈[1, 3]:
bd(m) =
X
u∈V ◦
X
i∈[1,2cmax−cmin]
δβ(u, i; m) +
X
e′∈E(T)\E◦
δβ([e′]; m) −
X
e∈E◦
δβ([e]; m);
(45)
B.6
Assigning Chemical Elements and Valence Condition
Constants.
• A set Λ consisting of all available chemical elements;
• functions αr(ψ), valex
F (ψ), eledegF(ψ), na(ψ) denoting the chemical element of the
root, root valence, ion-valence, number of non-root chemical element a of the fringe-
tree ψ, respectively;
• functions val(a), mass∗(a) denoting the valence and mass of the chemical element a,
respectively;
• integers naint
LB([a]), naint
UB([a]) ∈[0, nUB], a ∈Λ, that represent the lower and upper
bounds of the chemical element a in the interior part, respectively;
• integers naex
LB([a]), naex
UB([a]) ∈[0, nUB], a ∈Λ, that represent the lower and upper
bounds of the chemical element a in the exterior part, respectively;
• integers naLB([a]), naUB([a]) ∈[0, nUB], a ∈Λ, that represent the lower and upper
bounds of the chemical element a in GT , respectively;
• a positive constant Mms ∈R+ that represents a suﬃciently large number;
Variables.
• Integer variables α(u, [µ]), u ∈V ◦, µ ∈V (Cu), that represents the chemical element
assigned to the vertex µ in Cu;
• integer variables α(v), v ∈V (T) \ V ◦, that represents the chemical element assigned
to the vertex v;
• binary variables δα(u, [µ]; [a]), u ∈V ◦, µ ∈V (Cu), a ∈Λ, δα(u, [µ]; [a]) = 1 ⇔
α(u, [µ]) = [a];
• binary variables δα(v; [a]), v ∈V (T) \ V ◦, a ∈Λ, δα(v; [a]) = 1 ⇔α(v) = [a];
• integer variables βnode,u
[e′],[µ] , u ∈V ◦, µ ∈V (Cu), e′ ∈
¯E◦(u), indicating the bond-
multiplicity assigned to the non-ring edge e′ at vertex µ;
29


--- Page 30 ---
• integer variables βedge,u
[e],[µ],+, u ∈V ◦, µ ∈V (Cu), e ∈E◦(u), indicating the bond-
multiplicity other than that of the ring edge e at µ in Cu;
• integer variables βedge,u
[e],[µ],−, u ∈V ◦, µ ∈V (Cu), e ∈E◦(u), indicating the augmented
bond-multiplicity for µ because of the ring edge e;
• integer variables na([e]; [a]) ∈[0, 2], e ∈E◦, a ∈Λ, that stores the number of chemical
element a used in the ring edge e;
• integer variables naint([a]) ∈[naint
LB([a]), naint
UB([a])], a ∈Λ, that stores the number of
chemical element a in the interior part;
• integer variables naex([a]) ∈[naex
LB([a]), naex
UB([a])], a ∈Λ, that stores the number of
chemical element a in the exterior part;
• integer variables na([a]) ∈[naLB([a]), naUB([a])], a ∈Λ, that stores the number of
chemical element a in GT ;
• binary variables δatm(i), i ∈[nLB+naLB([H]), nUB+naUB([H])], δatm(i) = 1 ⇔nG = i;
• integer variable Mass that represents the total mass of GT ;
• real variable ms that represents the average mass of GT ;
Constraints.
For each u ∈V ◦, µ ∈V (Cu):
α(u, [µ]) =
X
ψ∈Fu
[αr(ψ)] · δF(u, [µ]; [ψ]);
(46)
X
a∈Λ
δα(u, [µ]; [a]) =
X
ξ∈Ξu,|ξ|≥[µ]
xu
[ξ];
(47)
X
a∈Λ
[a] · δα(u, [µ]; [a]) = α(u, [µ]);
(48)
For each v ∈V (T) \ V ◦:
α(v) =
X
ψ∈Fv
[αr(ψ)] · δF(v; [ψ]);
(49)
X
a∈Λ
δα(v; [a]) = 1;
(50)
X
a∈Λ
[a] · δα(v; [a]) = α(v);
(51)
30


--- Page 31 ---
For each u ∈V ◦, µ ∈V (Cu):
0 ≤βnode,u
[e′],[µ] ≤3xnode,u
[e′],[µ] ,
e′ ∈¯E◦(u);
(52)
3(xnode,u
[e′],[µ] −1) ≤β[e′] −βnode,u
[e′],[µ] ≤3(1 −xnode,u
[e′],[µ] ),
e′ ∈¯E◦(u);
(53)
0 ≤βedge,u
[e],[µ],+ ≤6
X
ν∈(E(Cu))(µ)
xedge,u
[e],[ν]
e ∈E◦(u);
0 ≤βedge,u
[e],[µ],−≤6
X
ν∈(E(Cu))(µ)
xedge,u
[e],[ν]
e ∈E◦(u);
(54)
6(xedge,u
[e],[ν] −1) ≤βedge,u
[e],[µ],+ + β[e] −
X
ν′∈(E(Cu))(µ)
βu
[ν′]
−
X
e′∈¯E◦(u)
βnode,u
[e′],[µ] ≤6(1 −xedge,u
[e],[ν] ),
e ∈E◦(u), ν ∈(E(Cu))(µ);
(55)
For each e = uu′ ∈E◦such that [u] < [u′]:
3(xedge,u
[e],[ν] + xedge,u′
[e],[ν′] −2) ≤βedge,u
[e],i1,−−βedge,u′
[e],j2,+ ≤3(2 −xedge,u
[e],[ν] −xedge,u′
[e],[ν′] ),
3(xedge,u
[e],[ν] + xedge,u′
[e],[ν′] −2) ≤βedge,u
[e],i2,−−βedge,u′
[e],j1,+ ≤3(2 −xedge,u
[e],[ν] −xedge,u′
[e],[ν′] ),
3(xedge,u
[e],[ν] + xedge,u′
[e],[ν′] −2) ≤βedge,u′
[e],j2,−−βedge,u
[e],i1,+ ≤3(2 −xedge,u
[e],[ν] −xedge,u′
[e],[ν′] ),
3(xedge,u
[e],[ν] + xedge,u′
[e],[ν′] −2) ≤βedge,u′
[e],j1,−−βedge,u
[e],i2,+ ≤3(2 −xedge,u
[e],[ν] −xedge,u′
[e],[ν′] ),
ν = ui1ui2 ∈E(Cu), ν′ = u′
j1u′
j2 ∈E(Cu′)
such that i1 < i2, j1 < j2;
(56)
X
a∈Λ
val(a) · δα(u, [µ]; [a]) =
X
ν∈(E(Cu))(µ)
βu
[ν] +
X
e′∈¯E◦(u)
βnode,u
[e′],[µ] +
X
e∈E◦(u)
βedge,u
[e],[µ],−
+
X
ψ∈Fu
(valex
F (ψ) −eledegF(ψ))δF(u, [µ]; [ψ]),
u ∈V ◦, µ ∈V (Cu);
(57)
X
a∈Λ
val(a) · δα(v; [a]) =
X
e′∈¯E◦(v)
β[e′] +
X
ψ∈Fv
(valex
F (ψ) −eledegF(ψ))δF(v; [ψ]),
v ∈V (T) \ V ◦;
(58)
For each a ∈Λ:
na([e]; [a]) =
X
ψ∈FT ,αr(ψ)=a
fc([e]; [ψ]),
e ∈E◦;
(59)
naint([a]) =
X
u∈V ◦
X
µ∈V (Cu)
δα(u, [µ]; [a]) +
X
v∈V (T)\V ◦
δα(v; [a]) −
X
e∈E◦
na([e]; [a]);
(60)
naex([a]) =
X
ψ∈FT
na(ψ) · fc([ψ]);
(61)
na([a]) = naint([a]) + naex([a]);
(62)
31


--- Page 32 ---
Mass =
X
a∈Λ
mass∗(a) · na([a]);
(63)
X
i∈[nLB+naLB([H]),nUB+naUB([H])]
δatm(i) = 1;
(64)
X
i∈[nLB+naLB([H]),nUB+naUB([H])]
i · δatm(i) = nG + naex([H]);
(65)
Mms(δatm(i) −1) ≤ms −Mass
i
≤Mms(1 −δatm(i)),i ∈[nLB + naLB([H]), nUB + naUB([H])];
(66)
B.7
Descriptors for the Number of Adjacency-conﬁgurations
Constants.
• A set Γint
ac consisting of available adjacency-conﬁgurations;
• integers acint
LB(γ), acint
UB(γ) ∈[0, nUB +|V ◦|−1], γ ∈Γint
ac , that represent the lower and
upper bounds of the adjacency-conﬁguration γ in GT , respectively;
Here, for an adjacency-conﬁguration γ = (a, b, m), we denote γ := (b, a, m). The set Γint
ac
is supposed to satisfy γ ∈Γint
ac ⇒γ ∈Γint
ac .
Variables.
• Binary variables δac(u, [ν]; [γ]), u ∈V ◦, ν ∈E(Cu), γ ∈Γint
ac , indicating whether the
edge ν has adjacency-conﬁguration γ;
• binary variables δac([e]; [γ]), e ∈E(T), γ ∈Γint
ac , indicating whether the edge e has
adjacency-conﬁguration γ;
• integer variables acint([γ]) ∈[acint
LB(γ), acint
UB(γ)], γ ∈Γint
ac , that stores the adjacency-
conﬁgurations;
Constraints.
For each u ∈V ◦, ν = uiuj ∈E(Cu) such that i < j:
X
γ∈Γint
ac
δac(u, [ν]; [γ]) = eu
[ν];
(67)
X
γ=(a,b,m)∈Γint
ac
m · δac(u, [ν]; [γ]) −βu
[ν] ≥3(eu
[ν] −1);
X
γ=(a,b,m)∈Γint
ac
m · δac(u, [ν]; [γ]) ≤βu
[ν];
(68)
X
γ=(a,b,m)∈Γint
ac
[a] · δac(u, [ν]; [γ]) −α(u, i) ≥|Λ|(eu
[ν] −1);
X
γ=(a,b,m)∈Γint
ac
[a] · δac(u, [ν]; [γ]) ≤α(u, i);
(69)
X
γ=(a,b,m)∈Γint
ac
[b] · δac(u, [ν]; [γ]) −α(u, j) ≥|Λ|(eu
[ν] −1);
X
γ=(a,b,m)∈Γint
ac
[b] · δac(u, [ν]; [γ]) ≤α(u, j);
(70)
32


--- Page 33 ---
For each e ∈E(T):
X
γ∈Γint
ac
δac([e]; [γ]) = 1;
(71)
X
γ=(a,b,m)∈Γint
ac
m · δac([e]; [γ]) = β[e];
(72)
For each non-ring edge e′ = uv ∈E(T) \ E◦such that [u] < [v]:
X
γ=(a,b,m)∈Γint
ac
[a] · δac([e′]; [γ]) = α(u),
if u /∈V ◦;
|Λ|(xnode,u
[e′],[µ] −1) ≤
X
γ=(a,b,m)∈Γint
ac
[a] · δac([e′]; [γ]) −α(u, [µ]) ≤|Λ|(1 −xnode,u
[e′],[µ] ),
µ ∈V (Cu), if u ∈V ◦;
(73)
X
γ=(a,b,m)∈Γint
ac
[b] · δac([e′]; [γ]) = α(v),
if v /∈V ◦;
|Λ|(xnode,v
[e′],[µ] −1) ≤
X
γ=(a,b,m)∈Γint
ac
[b] · δac([e′]; [γ]) −α(v, [µ]) ≤|Λ|(1 −xnode,v
[e′],[µ]),
µ ∈V (Cv), if v ∈V ◦;
(74)
For each e = uu′ ∈E◦such that [u] < [u′]:
|Λ|(xedge,u
[e],[ν] −1) ≤
X
γ=(a,b,m)∈Γint
ac
[a] · δac([e]; [γ]) −α(u, i1) ≤|Λ|(1 −xedge,u
[e],[ν] ),
|Λ|(xedge,u
[e],[ν] −1) ≤
X
γ=(a,b,m)∈Γint
ac
[b] · δac([e]; [γ]) −α(u, i2) ≤|Λ|(1 −xedge,u
[e],[ν] ),
ν = ui1ui2 ∈E(Cu) such that i1 < i2;
(75)
For each γ ∈Γint
ac :
acint([γ]) =
X
u∈V ◦
X
ν∈E(Cu)
(δac(u, [ν]; [γ]) + δac(u, [ν]; [γ])
+
X
e′∈E(T)\E◦
(δac([e′]; [γ]) + δac([e′]; [γ]))
−
X
e∈E◦
(δac([e]; [γ]) + δac([e]; [γ])),
if γ ̸= γ;
acint([γ]) =
X
u∈V ◦
X
ν∈E(Cu)
δac(u, [ν]; [γ]) +
X
e′∈E(T)\E◦
δac([e′]; [γ])
−
X
e∈E◦
δac([e]; [γ]),
if γ = γ;
(76)
B.8
Descriptors for the Number of Edge-conﬁgurations
Constants.
• A set Γint
ec consisting of available edge-conﬁgurations;
33


--- Page 34 ---
• integers ecint
LB(τ), ecint
UB(τ) ∈[0, nUB + |V ◦| −1], γ ∈Γint
ec , that represent the lower and
upper bounds of the adjacency-conﬁguration τ in GT , respectively;
Here, for an edge-conﬁguration τ = (ad, bd′, m), we denote τ := (bd′, ad, m). The set Γint
ec
is supposed to satisfy τ ∈Γint
ec ⇒τ ∈Γint
ec .
Variables.
• Binary variables δec(u, [ν]; [τ]), u ∈V ◦, ν ∈E(Cu), τ ∈Γint
ec , indicating whether the
edge ν has edge-conﬁguration τ;
• binary variables δec([e]; [τ]), e ∈E(T), τ ∈Γint
ec , indicating whether the edge e has
edge-conﬁguration τ;;
• integer variables ecint([τ]) ∈[ecint
LB(τ), ecint
UB(τ)], τ ∈Γint
ec , that stores the edge-conﬁgurations;
Constraints.
For each u ∈V ◦, ν = uiuj ∈E(Cu) such that i < j:
X
τ∈Γint
ec
δec(u, [ν]; [τ]) = eu
[ν];
(77)
X
τ=(ad,bd′,m)∈Γint
ec
[(a, b, m)] · δec(u, [ν]; [τ]) =
X
γ∈Γint
ac
[γ] · δac(u, [ν]; [γ]);
(78)
X
τ=(ad,bd′,m)∈Γint
ec
d · δec(u, [ν]; [τ]) −
X
d∈[1,4]
d · δdeg(u, i; d) ≥4(eu
[ν] −1);
X
τ=(ad,bd′,m)∈Γint
ec
d · δec(u, [ν]; [τ]) ≤
X
d∈[1,4]
d · δdeg(u, i; d);
(79)
X
τ=(ad,bd′,m)∈Γint
ec
d′ · δec(u, [ν]; [τ]) −
X
d′∈[1,4]
d′ · δdeg(u, j; d′) ≥4(eu
[ν] −1);
X
τ=(ad,bd′,m)∈Γint
ec
d′ · δec(u, [ν]; [τ]) ≤
X
d′∈[1,4]
d′ · δdeg(u, j; d′);
(80)
For each e ∈E(T):
X
τ∈Γint
ec
δec([e]; [τ]) = 1;
(81)
X
τ=(ad,bd′,m)∈Γint
ec
[(a, b, m)] · δec([e]; [τ]) =
X
γ∈Γint
ac
[γ] · δac([e]; [γ]);
(82)
34


--- Page 35 ---
For each non-ring edge e′ = uv ∈E(T) \ E◦such that [u] < [v]:
X
τ=(ad,bd′,m)∈Γint
ec
d · δec([e′]; [τ]) =
X
d∈[1,4]
d · δdeg(u; d),
if u /∈V ◦;
X
τ=(ad,bd′,m)∈Γint
ec
d · δec([e′]; [τ]) −
X
d∈[1,4]
d · δdeg(u, [µ]; d) ≥4(xnode,u
[e′],[µ] −1),
X
τ=(ad,bd′,m)∈Γint
ec
d · δec([e′]; [τ]) −
X
d∈[1,4]
d · δdeg(u, [µ]; d) ≤4(1 −xnode,u
[e′],[µ] ),
µ ∈V (Cu), if u ∈V ◦;
(83)
X
τ=(ad,bd′,m)∈Γint
ec
d′ · δac([e′]; [τ]) =
X
d′∈[1,4]
d′ · δdeg(v; d),
if v /∈V ◦;
X
τ=(ad,bd′,m)∈Γint
ec
d′ · δec([e′]; [τ]) −
X
d′∈[1,4]
d′ · δdeg(v, [µ]; d′) ≥4(xnode,v
[e′],[µ] −1),
X
τ=(ad,bd′,m)∈Γint
ec
d′ · δec([e′]; [τ]) −
X
d′∈[1,4]
d′ · δdeg(v, [µ]; d′) ≤4(1 −xnode,v
[e′],[µ]),
µ ∈V (Cv), if v ∈V ◦;
(84)
For each e = uu′ ∈E◦such that [u] < [u′]:
4(xedge,u
[e],[ν] −1) ≤
X
τ=(ad,bd′,m)∈Γint
ec
d · δec([e]; [τ]) −
X
d∈[1,4]
d · δdeg(u, i1; d) ≤4(1 −xedge,u
[e],[ν] ),
4(xedge,u
[e],[ν] −1) ≤
X
τ=(ad,bd′,m)∈Γint
ec
d′ · δec([e]; [τ]) −
X
d′∈[1,4]
d′ · δdeg(u, i2; d) ≤4(1 −xedge,u
[e],[ν] ),
ν = ui1ui2 ∈E(Cu) such that i1 < i2; (85)
For each τ ∈Γint
ec :
ecint([τ]) =
X
u∈V ◦
X
µ∈V (Cu)
(δec(u, [µ]; [τ]) + δec(u, [µ]; [τ])
+
X
e′∈E(T)\E◦
(δec([e′]; [τ]) + δec([e′]; [τ]))
−
X
e∈E◦
(δec([e]; [τ]) + δec([e]; [τ])),
if τ ̸= τ;
ecint([τ]) =
X
u∈V ◦
X
µ∈V (Cu)
δec(u, [µ]; [τ]) +
X
e′∈E(T)\E◦
δec([e′]; [τ])
−
X
e∈E◦
δec([e]; [τ]),
if τ = τ;
(86)
35
