--- Page 1 ---
Dynamic Quantum Optimal Communication Topology
Design for Consensus Control in Linear Multi-Agent Systems
Milad Hasanzadeh a, Amin Kargarian a
aDepartment of Electrical Engineering, Louisiana State University, Louisiana, USA
Abstract
This paper proposes a quantum framework for the design of communication topologies in consensus-based multi-agent systems.
The communication graph is selected online by solving a mixed-integer quadratic program (MIQP) that minimizes a cost
combining communication and distance penalties with degree-regularization terms, while enforcing exact connectivity through
a flow-based formulation. To cope with the combinatorial complexity of this NP-hard problem, we develop a three-block
ADMM scheme that decomposes the MIQP into a convex quadratic program in relaxed edge and flow variables, a pure binary
unconstrained subproblem, and a closed-form auxiliary update. The binary subproblem is mapped to a quadratic unconstrained
binary optimization (QUBO) Hamiltonian and approximately solved via quantum imaginary time evolution (QITE). The
resulting time-varying, optimizer-generated Laplacians are applied to linear first- and second-order consensus dynamics.
Numerical simulations on networks demonstrate that the proposed method produces connected topologies that satisfy degree
constraints, achieve consensus, and incur costs comparable to those of classical mixed-integer solvers, thereby illustrating how
quantum algorithms can be embedded as topology optimizers within closed-loop distributed control architectures.
Key words: Quantum optimization; Multi-agent systems; Consensus control; Communication topology design; Mixed-integer
quadratic programming
1
Introduction
1.1
Background and Motivation
Multi-agent systems (MASs) consist of a collection of
interacting agents that cooperate to achieve collective
objectives through local communication and distributed
control [14]. A central problem in MASs is consensus,
the process by which agents agree on quantities by ex-
changing information with neighbors over a communi-
cation network [19]. In early research on consensus, the
communication links between agents were fixed and did
not change during the task. This setup is called a static
topology, in which the communication network structure
remains the same over time [10, 11]. To make the sys-
tem more flexible, later studies introduced time-varying
or switching topologies, called dynamic topologies, in
which the connections between agents change over time
⋆This paper was not presented at any IFAC meeting. This
work was supported by the National Science Foundation un-
der Grant ECCS-1944752 and Grant ECCS-2312086. Corre-
sponding author A. Kargarian.
Email addresses: mhasa42@lsu.edu (Milad Hasanzadeh),
kargarian@lsu.edu (Amin Kargarian).
according to schedules [26].
To improve system performance, researchers have stud-
ied how to design an optimized communication network
for MASs. This is called optimal topology design, where
the connections between agents are chosen or updated
based on goals such as fast consensus, low communica-
tion cost, or strong network reliability [3,22,30]. In pre-
vious works, the communication graph is chosen by max-
imizing algebraic connectivity or by enforcing a lower
bound on the Fiedler eigenvalue of the Laplacian, which
leads to mixed-integer semidefinite or spectral optimiza-
tion problems [22,25,27]. These formulations are mathe-
matically elegant and provide direct control over a spec-
tral performance index, but they also have some limita-
tions for practical use. First, they optimize an eigenvalue
proxy rather than physical quantities such as communi-
cation cost, link distance, or security risk, which makes
the trade-offs less transparent. Second, semidefinite con-
straints and eigenvalue inequalities are computationally
heavy, especially if the topology must be recomputed re-
peatedly in a closed loop or for many different operating
points.
Motivated by these limitations, a different modeling ap-
proach that is closer in spirit to classical minimum-cost
Preprint submitted to Automatica
9 February 2026
arXiv:2602.06215v1  [eess.SY]  5 Feb 2026


--- Page 2 ---
network design and degree-constrained spanning tree
problems can be adopted [7]. The resulting problem is
a mixed-integer quadratic program (MIQP). While ef-
fective, such approaches also quickly become computa-
tionally expensive as the number of agents and potential
links grows due to the nonconvex nature of the prob-
lem [4,28]. Exact solvers scale poorly for these NP-hard
problems, and heuristic methods trade optimality for
tractability [5, 23]. This highlights the need for faster
and more scalable methods to design optimal communi-
cation topologies.
Quantum computing has emerged as a promising tech-
nology for tackling hard optimization problems, includ-
ing those arising in optimal communication topology de-
sign. In contrast to classical bits, qubits can exist in su-
perpositions and become entangled, enabling quantum
algorithms that provably outperform the best-known
classical methods for certain tasks, as in Shor’s factoring
and Grover’s search algorithms [8,18,24]. This has mo-
tivated a broader line of quantum algorithms for com-
binatorial optimization and Hamiltonian problems [16].
At the same time, we are still in the noisy intermediate-
scale quantum (NISQ) era: available devices have lim-
ited qubits and non-negligible gate errors, and large,
fault-tolerant speedups on realistic control problems are
not yet practical [21]. Consequently, most applications
of quantum algorithms to classical optimization adopt a
proof-of-concept viewpoint and rely on gate-level simu-
lators, for example, in chemistry, portfolio optimization,
or network design [2, 6, 20]. The emphasis is on show-
ing how mixed-integer or combinatorial models can be
mapped to Hamiltonians and embedded into larger al-
gorithmic or control architectures, so that the same for-
mulations and circuits can be executed on real devices
as larger and more reliable quantum processors become
available.
Within this proof-of-concept landscape, several algo-
rithmic paradigms have been proposed for ground-state
and optimization tasks. Variational Quantum Eigen-
solver (VQE) [20] and the Quantum Approximate Op-
timization Algorithm (QAOA) [6] are prominent exam-
ples: both use a parameterized quantum circuit (ansatz)
evaluated on the quantum device, while a classical opti-
mizer updates the parameters to minimize a cost func-
tion. These hybrid schemes are flexible and well-suited
to NISQ hardware, but they introduce an outer classical
optimization loop with step sizes, learning rates, and
other hyperparameters that must be tuned, which can
be burdensome when the same combinatorial problem
must be solved repeatedly inside a control loop.
An alternative is the Quantum Imaginary Time Evo-
lution (QITE) algorithm [17]. QITE can also be used
to find low-energy solutions of an objective encoded as
a Hamiltonian, but it is a fully quantum method: the
ansatz parameters are updated directly through a quan-
tum routine that approximates imaginary-time evolu-
tion, using quantum linear solvers or quantum differen-
tial equation solvers. In this way, QITE avoids the outer
classical optimization loop that VQE and QAOA rely
on. This leads to fewer hyperparameters to tune and a
more streamlined training procedure, which is attractive
for control and optimization applications.
Recent studies have begun exploring quantum com-
puting and communication concepts in the context of
MAS applications. For example, [13] introduces quan-
tum protocols and entanglement to enhance distributed
MAS environments, focusing primarily on secure syn-
chronization and improved efficiency. The survey [32]
discusses quantum multi-agent reinforcement learning,
highlighting the potential of quantum tools in multi-
agent learning scenarios; however, it does not address
distributed control mechanisms. More recently, [1] in-
vestigates quantum telecommunication for MASs, em-
phasizing quantum teleportation and wireless channels
to mitigate communication delays. While these contri-
butions lay useful foundations, they do not examine the
application of quantum optimization algorithms, such
as QITE, to design communication topologies.
1.2
Contributions
This paper presents a quantum optimization framework
for consensus control in MASs, in which QITE dynam-
ically optimizes the communication topology. The key
idea is to decompose the MIQP problem into three
blocks using an alternating direction method of multi-
pliers (ADMM)-based decomposition: a convex classi-
cal subproblem, a pure binary subproblem suitable for
quantum optimization, and a simple auxiliary update.
The binary subproblem is then solved using QITE. The
main contributions of this work are:
• We formulate the communication topology design
problem as an MIQP with practical cost terms and we
enforce graph connectivity exactly using a standard
flow-based formulation.
• We use a three-block ADMM splitting that relaxes
the binary edge variables, introduces a binary proxy
and an auxiliary continuous variable, and leads to (i)
a convex QP subproblem for the relaxed topology and
flows, (ii) a pure binary unconstrained subproblem in
the binary proxy, and (iii) a closed-form update for
the auxiliary variable.
• We
map
the
binary
unconstrained
subproblem
to a quadratic unconstrained binary optimization
(QUBO) Hamiltonian and use QITE as a fully quan-
tum solver to approximate its ground state.
1.3
Preliminaries
Graph Theory [15]: A MAS is modeled as an undirected
graph G = (V, E), where V = {1, 2, . . . , n} is the set of
2


--- Page 3 ---
Fig. 1. Visualization of a qubit in superposition and mea-
surement outcomes.
nodes (agents), and E ⊆V × V is the set of communi-
cation links. A path is a sequence of edges and nodes
between two distinct nodes with no duplicated edges or
nodes. A graph is connected if a path exists between any
pair of nodes. The adjacency matrix A ∈Rn×n is de-
fined by aij = 1 if (i, j) ∈E, and 0 otherwise. The degree
matrix D is diagonal with dii = P
j aij. The Laplacian
matrix is given by L = D −A. The algebraic connec-
tivity of the graph is the second smallest eigenvalue λ2
of L, which reflects the graph’s connectivity and affects
consensus convergence.
Quantum Computing [18]: Quantum computing oper-
ates on qubits, which can exist in a superposition of
pure states |0⟩= [1, 0]T and |1⟩= [0, 1]T . A general
single-qubit state is written as |ψ⟩= α|0⟩+ β|1⟩, where
α, β ∈C and |α|2 + |β|2 = 1. Multiple qubits can be en-
tangled, creating non-classical correlations across sub-
systems. Quantum gates are unitary matrices denoted
by U, satisfying U †U = I, where U † is the Hermitian
conjugate of U. Applying a gate to a quantum state
evolves it as |ψ1⟩= U|ψ0⟩. Typical quantum gates in-
clude single-qubit rotations (e.g., Rx, Ry, Rz) and two-
qubit entangling gates such as CNOT. A quantum cir-
cuit is a sequence of such gates acting on one or more
qubits. A final measurement collapses each qubit into
a classical bit (0 or 1), with probabilities determined
by the squared magnitudes of the amplitudes. Fig. 1 il-
lustrates the concept of a qubit in superposition and
the probabilistic nature of quantum measurement. It
also shows the Bloch sphere representation of a qubit.
Quantum circuits used for optimization can be broadly
grouped into two types. Variational circuits contain pa-
rameterized gates whose angles are tunable. Algorithms
like QITE use parameterized quantum circuits and up-
date the parameters directly via a quantum routine that
approximates imaginary-time evolution. The goal is to
prepare a quantum state that approximates the ground
state of a Hamiltonian encoding the program.
2
Problem Statement and Closed-Loop System
Here, we describe the MAS consensus dynamics, the as-
sumptions regarding the communication network, and
the communication topology optimization problem. We
deliberately focus on linear first- and second-order con-
sensus dynamics as a clear starting point. The optimiza-
tion layer is combinatorial and does not depend on the
linearity of the dynamics, so the same ideas can be ap-
plied to nonlinear models.
2.1
Networked Consensus
In this section, we recall standard consensus dynamics
for first- and second-order multi-agent systems, and then
state the assumptions under which the proposed time-
varying, optimizer-generated graph guarantees consen-
sus.
2.1.1
First-Order Consensus Dynamics
Consider a network of n agents with first-order dynamics
˙x(t) = u(t),
(1)
where x(t) = [x1(t), . . . , xn(t)]⊤∈Rn is the stacked
vector of agent states and u(t) = [u1(t), . . . , un(t)]⊤∈
Rn is the vector of control inputs. Consensus is achieved
if
lim
t→∞|xi(t) −xj(t)| = 0,
∀i, j ∈{1, . . . , n}.
As proposed in [19], consensus in first-order MASs can
be achieved using the classical distributed control law
ui(t) = −
X
j∈Ni
aij
 xi(t) −xj(t)

,
where Ni is the set of neighbors of agent i and aij ≥0 are
the edge weights of the communication graph. In vector
form, this becomes
u(t) = −Lx(t),
where L ∈Rn×n is the graph Laplacian matrix. Sub-
stituting this controller into (1) yields the closed-loop
system
˙x(t) = −Lx(t).
(2)
If the graph is connected, then L is positive semidefinite
with a single zero eigenvalue associated with the eigen-
vector 1, and all other eigenvalues are strictly positive.
In the presence of a time-varying communication topol-
ogy, the Laplacian becomes time-dependent, and the
closed-loop dynamics are
˙x(t) = −L(t) x(t),
(3)
where L(t) is the Laplacian of the communication graph
at time t. In our framework, L(t) is determined by the
optimizer at each step and held constant until the next
update.
3


--- Page 4 ---
2.1.2
Second-Order Consensus Dynamics
We now consider a network of n agents with second-
order dynamics. Each agent has a position xi(t) and a
velocity vi(t), and the overall system is described by
˙x(t) = v(t),
(4)
˙v(t) = u(t),
(5)
where x(t), v(t), u(t) ∈Rn are the stacked vectors of po-
sitions, velocities, and control inputs, respectively. Con-
sensus in this case means that all agents reach the same
position and move with the same velocity, i.e.,
lim
t→∞|xi(t) −xj(t)| = 0, lim
t→∞|vi(t) −vj(t)| = 0,
∀i, j.
As shown in [31], second-order consensus can be achieved
using the distributed controller
ui(t) = −α
X
j∈Ni
aij
 xi(t)−xj(t)

−β
X
j∈Ni
aij
 vi(t)−vj(t)

,
where α, β > 0 are control parameters and aij, Ni are
as defined above. In vector form,
u(t) = −αLx(t) −βLv(t).
Substituting this into (4)–(5) yields the closed-loop
second-order system
˙x(t) = v(t),
(6)
˙v(t) = −αLx(t) −βLv(t).
(7)
With a time-varying topology, we obtain
˙x(t) = v(t),
(8)
˙v(t) = −αL(t) x(t) −βL(t) v(t),
(9)
where L(t) is again the Laplacian of the communication
graph at time t. In the proposed framework, L(t) is up-
dated by the optimizer at discrete times and held con-
stant in between.
2.1.3
Assumptions and Consensus Guarantee
The topology optimization algorithm described later
produces, at each update time, a Laplacian L(t) that
is applied to the closed-loop consensus dynamics. In
this subsection, we state the modeling assumptions on
the communication layer and the resulting time-varying
topology, and we recall the corresponding consensus
guarantees.
Assumption 1 (Ideal communication) Communication
links are lossless and delay-free, so the Laplacian L(t)
designed by the optimizer is exactly realized by the phys-
ical multi-agent system. Packet drops, noise, and time
delays are not modeled in this work.
Assumption 2 (Connectivity) For all t ≥0, L(t) is
the Laplacian of an undirected graph with nonnegative
weights. The topology is piecewise constant, and there
exists τmin > 0 such that each topology is applied for
at least τmin time units. Moreover, the graph is con-
nected at all times, i.e., its algebraic connectivity satisfies
λ2(L(t)) > 0 for all t.
Under these assumptions, consensus is guaranteed for
both first- and second-order dynamics.
Theorem 1 Consider the first-order system (3) or the
second-order system (8)–(9) under Assumptions 1–2.
Then all agents achieve consensus. In particular, for all
i, j ∈{1, . . . , n},
lim
t→∞|xi(t) −xj(t)| = 0,
and, in the second-order case,
lim
t→∞|vi(t) −vj(t)| = 0.
Proof. We sketch the main ideas; detailed proofs can be
found in [19,31].
First-order case: Define the average state ¯x(t)
:=
1
n1⊤x(t) and the disagreement vector
y(t) := x(t) −¯x(t) 1 =

I −1
n11⊤
x(t).
Using L(t)1 = 0 for all t, it is easy to see from (3) that
˙¯x(t) = 0, so the average is invariant. The disagreement
dynamics are
˙y(t) = −L(t) y(t),
with L(t) symmetric and positive semidefinite. By As-
sumption 2, λ2(L(t)) > 0 for all t, so along any nonzero
disagreement direction the system has strictly negative
instantaneous contraction rate. Since the topology is
piecewise constant with a uniform dwell time, standard
arguments for linear time-varying systems (see, e.g., [19])
imply that y(t) →0 as t →∞. Therefore, all agents
converge to the same value, equal to the initial average
¯x(0), and consensus is achieved.
Second-order case: Define the stacked state ξ(t) =
[x(t)⊤, v(t)⊤]⊤. In the disagreement coordinates ob-
tained by projecting onto the subspace orthogonal to 1,
4


--- Page 5 ---
the dynamics (8)–(9) decompose into n−1 independent
second-order modes of the form
˙ξ1,i(t) = ξ2,i(t), ˙ξ2,i(t) = −αλi(t) ξ1,i(t) −βλi(t) ξ2,i(t),
where λi(t), i = 2, . . . , n, are the positive eigenvalues of
L(t) [31]. For each mode, Assumption 2 implies λi(t) >
0, so the corresponding 2 × 2 time-varying system ma-
trix has eigenvalues with strictly negative real parts. Us-
ing Lyapunov arguments as in [31], together with the
piecewise constant structure and dwell-time condition,
one shows that all disagreement modes converge to zero.
Thus, positions and velocities converge to a common
value, resulting in second-order consensus.
□
Remark 1 Stability and convergence depend only on the
connectivity and nonnegativity conditions in Assump-
tion 2, not on global optimality of the topology with respect
to any cost. The optimization layer is used to improve
performance (e.g., communication cost), while feasibility
and stability are enforced by the connectivity and degree
constraints.
2.2
Communication Topology Optimization
We now formalize the communication topology design
problem that generates the Laplacian L(t) used in the
consensus dynamics. The goal is to choose, at discrete
update times, a connected communication graph that
balances communication cost, geometric distance, and
fairness in the distribution of degrees across agents.
Let 0 = t0 < t1 < t2 < . . . denote the discrete update
times at which the communication topology is recom-
puted. At each tk we select an undirected graph Gk. The
corresponding Laplacian matrix is denoted by Lk, and
we set
L(t) = Lk,
t ∈[tk, tk+1).
This piecewise-constant structure is consistent with As-
sumption 2 and ensures that the consensus dynamics see
a constant topology between updates.
We start from the complete undirected candidate edge
set
E =

(i, j)
 1 ≤i < j ≤n
	
.
For each potential edge (i, j) ∈E and update time tk,
we introduce a binary decision variable
zk
ij ∈{0, 1},
where zk
ij = 1 indicates that the link between agents i
and j is active in Ek, and zk
ij = 0 means that the link
is absent. When the time index is clear, we write zij for
simplicity.
At time tk, each potential edge (i, j) is assigned two basic
cost components:
• Communication cost ccomm
ij
≥0, which models hard-
ware, bandwidth, or energy expenditure associated
with maintaining the link (i, j);
• Distance cost dij ≥0, typically based on the spatial
distance between agents, e.g.,
dij =
xi(tk) −xj(tk)

2,
so that long-range links are penalized more heavily
than short-range ones.
We combine these into a single linear weight
wij := ccomm
ij
+ dij,
∀(i, j) ∈E.
(10)
The total linear cost of a topology is then
Jlin(z) =
X
(i,j)∈E
wijzij.
(11)
To avoid centralized topologies in which a few nodes act
as large hubs, we include a quadratic penalty on the
degrees of the nodes. Under a topology z, the degree of
node i is
deg(i) =
X
j̸=i
zmin{i,j},max{i,j},
(12)
and we add the quadratic term
Jdeg(z) =
n
X
i=1
κi
 deg(i)
2,
(13)
where κi ≥0 determines how strongly we penalize high
degree at node i. This term encourages the optimizer to
spread edges more evenly across nodes.
In addition to the quadratic penalty, we impose a hard
upper bound on the degree of every node:
deg(i) ≤γ,
∀i ∈V,
(14)
where
γ
is
a
prescribed
maximum
degree.
Con-
straint (14) limits the worst-case communication load
on any single agent, while the quadratic term (13) softly
discourages uneven degree distributions within that
feasible set.
The consensus guarantees in Theorem 1 require that
the communication graph be connected at all times. To
enforce connectivity exactly, we use a standard flow-
based formulation that introduces artificial flows over
the graph.
5


--- Page 6 ---
Fix an arbitrary root node r ∈V and define the directed
arc set
A =

(i, j), (j, i)
 (i, j) ∈E
	
.
For each directed arc (i, j) ∈A, we introduce a nonneg-
ative continuous flow variable fij ≥0. Intuitively, one
unit of artificial flow must be delivered from the root to
each other node, and flow is only allowed to use active
edges.
We impose capacity constraints
0 ≤fij ≤(n −1) zmin{i,j},max{i,j},
∀(i, j) ∈A, (15)
and the flow conservation constraints
X
j:(j,k)∈A
fjk −
X
j:(k,j)∈A
fkj = 1,
∀k ∈V \ {r},
(16)
X
j:(r,j)∈A
frj −
X
j:(j,r)∈A
fjr = n −1,
for the root r.
(17)
If a solution satisfies (15)–(17), then there exists a span-
ning tree rooted at r, and the undirected graph induced
by {(i, j) ∈E : zij = 1} is connected.
Collecting the objective and constraints, the communi-
cation topology design problem at time tk is written as
the MIQP
min
z,f J(z) := Jlin(z) + Jdeg(z)
(18a)
s.t. zij ∈{0, 1},
∀(i, j) ∈E,
(18b)
fij ≥0,
∀(i, j) ∈A,
(18c)
deg(i) ≤γ,
∀i ∈V,
(18d)
0 ≤fij ≤(n −1) zmin{i,j},max{i,j},
∀(i, j) ∈A,
(18e)
X
j
fjk −
X
j
fkj = 1,
∀k ∈V \ {r},
(18f)
X
j
frj −
X
j
fjr = n −1.
(18g)
The binary variables zij select the active edges, the con-
tinuous flow variables fij certify connectivity via the
constraints (18e)–(18g), and the degree-related terms
(18d)–(18a) enforce sparsity. Solving (18) at each up-
date time tk produces a connected topology and a cor-
responding Lk that is used in the consensus dynamics.
Assumption 3 The maximum degree satisfies 1 ≤γ ≤
n−1, and for n ≥3 we require γ ≥2 so that a connected
graph with bounded degree exists.
Lemma 1 Under Assumption 3, the MIQP (18) has a
nonempty feasible set.
Proof. We construct an explicit feasible solution (z, f).
Step 1 (choice of a connected graph with bounded de-
gree). For n = 1 there are no edges and the problem
is trivially feasible. For n = 2, a single edge between
the two nodes gives a connected graph with degrees
deg(1) = deg(2) = 1, which satisfies 1 ≤γ ≤n −1 = 1
by Assumption 3. Thus the degree constraints hold.
Now consider n ≥3. By Assumption 3, we have 2 ≤γ ≤
n−1. Define a path graph on the node set V = {1, . . . , n}
by setting
zi,i+1 = 1,
i = 1, . . . , n −1,
and zij = 0 for all other pairs. The resulting undirected
graph is connected and the node degrees satisfy
deg(1) = deg(n) = 1,
deg(i) = 2, i = 2, . . . , n −1.
Therefore, deg(i) ≤2 ≤γ for all i, and the degree con-
straints (18d) are satisfied. Since we never exceed degree
2, the upper bound γ ≤n−1 is automatically respected.
Step 2 (flows that satisfy the connectivity constraints).
Fix the root node r = 1 without loss of generality. On
the undirected path, there is a unique simple path from
r to every node k. Define the directed flow variables on
the arc set A as follows. For each edge (i, i + 1) with
i = 1, . . . , n −1, set
fi,i+1 = n −i,
fi+1,i = 0,
and fij = 0 for all other directed arcs (i, j) ∈A. The
quantity fi,i+1 represents how many downstream nodes
must receive one unit of artificial flow from the root.
By construction, fij ≥0 for all (i, j), and since n −i ≤
n−1 and zi,i+1 = 1, the capacity constraints (18e) hold:
0 ≤fi,i+1 = n −i ≤n −1 = (n −1) zi,i+1.
For each non-root node k > 1, the net inflow is
X
j
fjk −
X
j
fkj = 1,
and for the root r = 1 the net outflow equals n −1.
Thus the flow conservation constraints (18f)–(18g) are
satisfied.
We have therefore exhibited (z, f) that satisfies all con-
straints of (18), so the feasible set is nonempty.
□
6


--- Page 7 ---
3
Three-Block ADMM Decomposition
The MIQP in (18) gives an exact formulation of the
topology design problem at each update time. However,
it is difficult to solve this mixed-integer problem to op-
timality at every step when the network is large. In this
subsection, we describe how to decompose the problem
into three simpler blocks using the ADMM. The goal
is to keep the connectivity and degree constraints in a
classical convex block, to move the binary decisions into
a pure binary block, and to use a third block to couple
them.
3.1
Three-Block Formulation
We keep the binary edge variables of the MIQP and
introduce two extra copies of them. For each undirected
edge (i, j) ∈E we define three variables:
• a relaxed edge variable zij ∈[0, 1], which appears in
the cost and in the constraints of (18);
• a binary proxy variable rij ∈{0, 1}, which will be the
input to the binary subproblem;
• an auxiliary variable sij ∈R, which helps to enforce
agreement between zij and rij.
If we stack all edges into vectors z, r, s ∈Rm with m =
|E|, we connect them with the linear constraint
z −r + s = 0,
(19)
which holds elementwise. In the original MIQP we would
require z ∈{0, 1}m. In the three-block scheme, we relax
this to z ∈[0, 1]m, keep r binary, and use the constraint
(19) with penalties and dual variables to keep z and r
close to each other.
The constraints of the MIQP, namely the degree con-
straint (18d), the capacity constraint (18e), and the flow
conservation constraints (18f)–(18g), together with the
box constraint 0 ≤z ≤1, define a convex feasible set for
(z, f) once integrality is removed.
To apply ADMM, we introduce a dual variable λ ∈Rm
for the constraint (19) and add a quadratic penalty. We
also add a small regularization on s. Let ρ > 0 and β ≥0
be fixed parameters. We use an indicator function for
the convex constraints of the MIQP:
ιC(z, f) =
(
0,
if (18d)–(18g) and 0 ≤z ≤1 hold,
+∞,
otherwise.
(20)
The augmented Lagrangian associated with (18) and
(19) is
L(z, f, r, s, λ) =J(z) + ιC(z, f) + λ⊤(z −r + s)
+ ρ
2∥z −r + s∥2
2 + β
2 ∥s∥2
2,
(21)
where J(z) is the MIQP objective in (18a). The ADMM
method minimizes L with respect to each block (z, f),
r, and s in turn, and then updates the dual variable λ.
In Block 1, we update the relaxed topology z and the
flows f. At iteration k, given r(k−1), s(k−1), and λ(k−1),
we solve
(z(k), f (k)) = arg min
z,f
L(z, f, r(k−1), s(k−1), λ(k−1))
(22)
subject to the convex constraints encoded in ιC(z, f).
Since the integrality constraint on z is relaxed and all
constraints in C are linear, this is a convex quadratic op-
timization problem. It can be solved by standard clas-
sical solvers. Intuitively, Block 1 chooses a connected
topology and flows that minimize the MIQP cost plus a
quadratic term that keeps z close to r(k−1) −s(k−1).
In Block 2, we update the binary proxy r. At iteration
k, we fix z(k), f (k), s(k−1), and λ(k−1), and solve
r(k) = arg
min
r∈{0,1}m L(z(k), f (k), r, s(k−1), λ(k−1)). (23)
The terms in L that depend on r are
−λ(k−1)⊤r + ρ
2∥z(k) −r + s(k−1)∥2
2.
If we expand the squared norm, we obtain a quadratic
function in r with no constraints other than r ∈{0, 1}m.
This is a QUBO problem.
In Block 3, we update the auxiliary vector s. At iteration
k, we fix z(k), r(k), and λ(k−1) and solve
s(k) = arg min
s∈Rm L(z(k), f (k), r(k), s, λ(k−1)).
(24)
For each component e = 1, . . . , m, the dependence on se
is quadratic:
λ(k−1)
e
(z(k)
e
−r(k)
e
+ se) + ρ
2(z(k)
e
−r(k)
e
+ se)2 + β
2 s2
e.
Taking the derivative with respect to se and setting it
to zero gives
λ(k−1)
e
+ ρ
 z(k)
e
−r(k)
e
+ s(k)
e

+ βs(k)
e
= 0.
7


--- Page 8 ---
Algorithm 1 Three-block ADMM topology solver at
update time tk
1: Initialize: (z(0), f (0), r(0), s(0), λ(0)), penalty pa-
rameters ρ > 0, β ≥0, and stopping tolerances. Set
k ←1.
2: while stopping criterion not met do
3:
Block 1: Compute (z(k), f (k)) by solving(22).
4:
Block 2: Update r(k) by solving (23).
5:
Block 3: Update s(k) componentwise using (25).
6:
Dual update: Update according to (27).
7:
k ←k + 1.
8: end while
9: Return: final edge vector z(k) and Laplacian Lk
constructed from the active edges.
Therefore
s(k)
e
= −λ(k−1)
e
+ ρ
 z(k)
e
−r(k)
e

ρ + β
,
e = 1, . . . , m. (25)
This update is fully explicit and independent across
edges, so Block 3 is computationally cheap.
After updating (z(k), f (k), r(k), s(k)), we update the dual
variables. The residual of the coupling constraint (19) at
iteration k is
d(k) := z(k) −r(k) + s(k).
(26)
The dual variables are updated by
λ(k) = λ(k−1) + ρ d(k).
(27)
If the method converges, then d(k) tends to zero, so z, r,
and s agree asymptotically.
Algorithm 1 summarizes the three-block ADMM scheme
for a single topology update time. In the closed-loop set-
ting, this algorithm is called at each tk, and the resulting
edge vector z(K) is used to build the Laplacian Lk.
3.2
Convergence and Stability of the Three-Block
ADMM
Here, we study the convergence and the algorithmic sta-
bility of the three-block ADMM scheme in Algorithm 1.
Under a set of regularity assumptions stated below, we
show that the consensus residual converges to zero and
that any limit point of the ADMM iterates satisfies the
first-order optimality conditions of the augmented La-
grangian. We focus on the iteration of the optimization
layer, not on the physical stability of the multi-agent con-
sensus dynamics, which was already discussed in Theo-
rem 1.
We recall that for each undirected edge, we introduced
three variables: the relaxed edge variable, the binary
proxy, and the auxiliary variable. If we stack all edges
in a fixed order, we obtain the vectors z, r, s ∈Rm,
where m = |E|. The coupling between these three vec-
tors is expressed by the consensus constraint in (19). The
augmented Lagrangian that we use in the three-block
ADMM is given in (21). At iteration k, Algorithm 1
first updates the relaxed topology and flow variables
(z(k), f (k)), then updates the binary proxy r(k), then up-
dates the auxiliary variable s(k), and finally updates the
dual variable λ(k).
To study the behavior of this iteration, we treat the
ADMM scheme as a discrete-time dynamical system. We
denote the stacked iterate at step k as
Ξ(k) :=
 z(k), f (k), r(k), s(k), λ(k)
.
Then Algorithm 1 defines a recursion of the form
Ξ(k+1) = T
 Ξ(k)
,
where T is the operator that represents one full ADMM
sweep. The dual update step can be written as
λ(k+1) = λ(k) + ρ d(k+1),
(28)
where d(k+1) is the consensus residual at iteration k + 1
defined in (26). This relation shows that changes in the
dual variable are directly driven by the residual of the
consensus constraint.
Assumption 4 (Bounded iterates) The sequence of
iterates
Ξ(k) :=
 z(k), f (k), r(k), s(k), λ(k)
generated by Algorithm 1 is bounded. In other words,
there exists a compact set such that all these iterates re-
main inside it for all k ≥0.
This is a standard technical assumption in nonconvex
ADMM analysis and can be enforced in practice, e.g.,
by projecting the dual variable onto a large box.
Assumption 5 (Exact block updates) At every it-
eration k, each block subproblem in Algorithm 1 is solved
exactly. Block 1 returns an exact minimizer (z(k), f (k))
of the convex QP in (22) subject to the constraints col-
lected in C. Block 2 returns an exact minimizer r(k) of
the QUBO problem (23) over {0, 1}m. Block 3 updates
s(k) using the explicit formula in (25).
Assumption 6 (Strong convexity of Block 1) For
any fixed (r, s, λ), the objective of the Block 1 subproblem
8


--- Page 9 ---
is strongly convex in the variables (z, f) over the feasi-
ble set defined by C. This strong convexity is induced,
for example, by the quadratic degree penalty Jdeg(z) to-
gether with the quadratic penalty ρ
2∥z −r + s∥2
2 in (21),
and possibly by a small convex regularization in f. For
example, one can add a small term ϵ
2∥f∥2
2 with ϵ > 0 to
the objective of Block 1 to ensure strong convexity with
respect to f.
Assumption 7 (Regularity) The
augmented
La-
grangian L in (21) is proper, lower semicontinuous,
and bounded from below on the domain defined by the
constraints in C and by r ∈{0, 1}m. Moreover, L satis-
fies the Kurdyka– Lojasiewicz property. This holds, for
example, because J(z) is a sum of linear and convex
quadratic terms, ιC is the indicator of a polyhedral set,
the remaining terms in (21) are quadratic in (z, r, s, λ),
and the overall function is semialgebraic in (z, f, r, s, λ).
Under these assumptions, we can use a Lyapunov candi-
date to analyze the behavior of the three-block ADMM.
The idea is to combine the augmented Lagrangian and
a quadratic penalty on the residual into a single scalar
function that does not increase along the iterations and
that is bounded from below. We define
V (k) := L
 z(k), f (k), r(k), s(k), λ(k)
+ κ
2
d(k)2
2, (29)
where κ > 0 is a tuning parameter. The first term in
V (k) measures the objective plus the constraint penalties
at the current iterate. The second term penalizes the
violation of the consensus constraint. If the algorithm
converges to a point where the consensus constraint is
satisfied, then both terms should approach finite limits.
To study how V (k) changes from one iteration to the
next, we write
V (k+1) −V (k) = L
 z(k+1), f (k+1), r(k+1), s(k+1), λ(k+1)
−L
 z(k), f (k), r(k), s(k), λ(k)
+ κ
2
d(k+1)2
2 −
d(k)2
2

.
(30)
For notational convenience, we denote by
Lk(λ) := L
 z(k), f (k), r(k), s(k), λ

the augmented Lagrangian evaluated at the primal vari-
ables of iteration k and at a generic dual vector λ. Then
we can rewrite (30) as
V (k+1) −V (k) = Lk+1(λ(k+1)) −Lk(λ(k))
+ κ
2
d(k+1)2
2 −
d(k)2
2

.
(31)
We now split the change in the augmented Lagrangian
into a dual part and a primal part. We add and subtract
Lk+1(λ(k)) inside the first difference:
Lk+1(λ(k+1)) −Lk(λ(k)) =

Lk+1(λ(k+1)) −Lk+1(λ(k))

+

Lk+1(λ(k)) −Lk(λ(k))

.
(32)
The first bracket corresponds to the effect of updating
the dual variable from λ(k) to λ(k+1) while the primal
variables are fixed at (z(k+1), f (k+1), r(k+1), s(k+1)). The
second bracket corresponds to the effect of updating the
primal variables from iteration k to iteration k +1 while
the dual variable remains equal to λ(k).
We first consider the dual part. In the augmented La-
grangian in (21), the dual variable appears only in the
linear term λ⊤(z −r + s). Therefore, for any fixed
(z, f, r, s) and any two dual vectors λ and ˜λ, we have
L(z, f, r, s, ˜λ) −L(z, f, r, s, λ) = (˜λ −λ)⊤(z −r + s).
If we apply this identity with λ = λ(k), ˜λ = λ(k+1) and
the primal variables set to their (k + 1) values, then
z −r + s is equal to d(k+1) and we obtain
Lk+1(λ(k+1)) −Lk+1(λ(k)) =
 λ(k+1) −λ(k)⊤d(k+1).
(33)
Using the dual update (28), we have λ(k+1) −λ(k) =
ρ d(k+1), and therefore
Lk+1(λ(k+1)) −Lk+1(λ(k)) = ρ
d(k+1)2
2.
(34)
We now consider the primal part, that is the second
bracket in (32). This term is
Lk+1(λ(k)) −Lk(λ(k)),
and it measures the change in the augmented Lagrangian
due to the updates of (z, f), r and s at fixed dual variable
λ(k). We follow the three primal blocks in Algorithm 1.
In Block 1, the pair (z(k+1), f (k+1)) is obtained by min-
imizing L with respect to (z, f) under the convex con-
straints in C, with (r, s, λ) fixed at (r(k), s(k), λ(k)). By
strong convexity of the Block 1 objective in (z, f), there
exists a constant σ1 > 0 such that
L
 z(k+1),f (k+1), r(k), s(k), λ(k)
≤L
 z(k), f (k), r(k), s(k), λ(k)
−σ1
(z(k+1), f (k+1)) −(z(k), f (k))
2
2.
(35)
9


--- Page 10 ---
This inequality means that, if (z, f) moves, then the
augmented Lagrangian decreases by at least a quadratic
amount in the step size of (z, f).
In Block 2, the vector r(k+1) is obtained by minimizing L
with respect to r in the set {0, 1}m with (z, f, s, λ) fixed
at (z(k+1), f (k+1), s(k), λ(k)). Since r(k+1) is a minimizer
of this subproblem, we have
L
 z(k+1),f (k+1), r(k+1), s(k), λ(k)
≤L
 z(k+1), f (k+1), r(k), s(k), λ(k)
.
(36)
Here, we only know that the augmented Lagrangian does
not increase in Block 2.
In Block 3, the vector s(k+1) is obtained by minimiz-
ing L with respect to s in Rm with (z, f, r, λ) fixed at
(z(k+1), f (k+1), r(k+1), λ(k)). This minimization has the
closed-form solution in (25). The dependence of L on s is
strictly convex and quadratic, so there exists a constant
σ2 > 0 such that
L
 z(k+1),f (k+1), r(k+1), s(k+1), λ(k)
≤L
 z(k+1), f (k+1), r(k+1), s(k), λ(k)
−σ2
s(k+1) −s(k)2
2.
(37)
If we combine (35), (36) and (37), and we identify
Lk(λ(k)) = L
 z(k), f (k), r(k), s(k), λ(k)
,
and
Lk+1(λ(k)) = L
 z(k+1), f (k+1), r(k+1), s(k+1), λ(k)
,
we obtain the bound
Lk+1(λ(k))−Lk(λ(k)) ≤
−σ1
(z(k+1), f (k+1)) −(z(k), f (k))
2
2
−σ2
s(k+1) −s(k)2
2.
(38)
Now we substitute (32), (34) and (38) into (31). We get
V (k+1) −V (k) ≤ρ
d(k+1)2
2
−σ1
(z(k+1), f (k+1)) −(z(k), f (k))
2
2
−σ2
s(k+1) −s(k)2
2
+ κ
2
d(k+1)2
2 −
d(k)2
2

.
(39)
Collecting the terms with d(k+1) and d(k), we can rewrite
this as
V (k+1) −V (k) ≤

ρ + κ
2
 d(k+1)2
2 −κ
2
d(k)2
2
−σ1
(z(k+1), f (k+1)) −(z(k), f (k))
2
2
−σ2
s(k+1) −s(k)2
2.
(40)
Inequality (40) shows that the Lyapunov candidate V (k)
can only increase through the terms that depend on the
residuals, while the changes in (z, f) and in s always de-
crease the augmented Lagrangian by at least a quadratic
amount. Combined with the lower boundedness and reg-
ularity of L in Assumption 7, this type of inequality
is standard in the convergence analysis of nonconvex
ADMM schemes, see for example [9,12,29].
Theorem 2 Suppose that Assumptions 4–7 hold and
that the penalty parameter ρ is chosen sufficiently large.
Then the sequence {Ξ(k)} generated by Algorithm 1 has
the following properties:
(1) The consensus residual converges to zero,
d(k) →0
as k →∞,
so that the coupling constraint z −r + s = 0 is
satisfied at any limit point.
(2) The sequence has square-summable increments, in
the sense that
∞
X
k=0
(z(k+1), f (k+1)) −(z(k), f (k))
2
2
+
s(k+1) −s(k)2
2

< +∞.
(41)
(3) Every limit point of {Ξ(k)} is a stationary point of
the augmented Lagrangian L under the convex con-
straints on (z, f) and the binary constraints on r.
In particular, if the sequence {Ξ(k)} has a unique limit
point, then the entire sequence converges to this station-
ary point.
4
Quantum Optimization of the Binary Block
In this section, we describe how the binary Block 2 of the
three-block ADMM is mapped to a QUBO problem and
then encoded as a quantum Hamiltonian. The ground
state of this Hamiltonian corresponds to an optimal or
near-optimal binary edge configuration for the commu-
nication topology. We then explain how the QITE algo-
rithm is used as a quantum solver for this Hamiltonian.
10


--- Page 11 ---
4.1
Binary ADMM Block as QUBO Hamiltonian
In the three-block ADMM scheme in Section 3, the bi-
nary block updates the proxy vector r ∈{0, 1}m by
minimizing the augmented Lagrangian with respect to
r, while all other variables are fixed. The Block 2 sub-
problem in (23) can be written in the compact form
min
r∈{0,1}m Φ(r) := λ⊤(z−r+s)+ρ
2∥z−r+s∥2
2+µ
 m
X
i=1
ri
2
,
(42)
where, for simplicity of notation, we dropped the itera-
tion superscripts and we used µ ≥0 to denote a small
cardinality penalty.
The first two terms in (42) come directly from the aug-
mented Lagrangian in (21). If we only keep these two
terms, the objective is separable in the components of
r. Indeed, the quadratic term in ∥z −r + s∥2
2 produces
diagonal contributions in the Hessian with respect to r,
and the linear term λ⊤(z −r + s) only shifts each vari-
able individually. In this ideal case, every ri could be
updated independently by comparing two scalar costs,
since ri ∈{0, 1}.
However, in practice, we observed that a completely sep-
arable binary block can lead to slower convergence and
oscillations in the ADMM iterations, because each edge
variable reacts locally to the current z and s values, with-
out any direct coupling with the other edges. Moreover,
the separable structure does not encode any preference
for the total number of active links. For these reasons,
we add the heuristic cardinality regularization
Jcard(r) := µ
 m
X
i=1
ri
2
,
which appears as the last term in (42). This penalty is
small compared to the main terms, but it has two use-
ful effects. First, it discourages both extremely dense
and extremely sparse topologies, because the cost grows
quadratically with the number of active edges. Second, it
introduces a controlled coupling between all binary vari-
ables. This coupling produces a non-diagonal quadratic
form in r and tends to stabilize the ADMM dynamics
by correlating the updates of different edges.
To make the quantum mapping explicit, we rewrite (42)
in the standard QUBO form. If we expand the squared
norm and the cardinality term, we can always write
Φ(r) = r⊤Qr + q⊤r,
r ∈{0, 1}m,
(43)
where Q ∈Rm×m is a symmetric matrix collecting all
quadratic coefficients and q ∈Rm is a linear coefficient
vector. In particular, the diagonal of Q and the entries
of q come from the expansion of λ⊤(z −r + s) and
∥z −r + s∥2
2, while the off-diagonal entries of Q are cre-
ated by the cardinality term Jcard(r). In the absence of
the cardinality penalty, Q would be diagonal and the
problem would be separable.
The QUBO in (43) is a purely combinatorial problem in
the binary vector r. To use a quantum algorithm, it is
convenient to transform it into a Hamiltonian acting on
m qubits. This is done by introducing Pauli-Z spin op-
erators and by encoding each binary decision into a spin
variable. Following a standard construction, we associate
to each QUBO variable ri ∈{0, 1} a Pauli-Z operator
Zi with eigenvalues ±1 and we use the linear mapping
ri = 1 −Zi
2
,
i = 1, . . . , m.
(44)
If we substitute (44) into (43), and we expand all prod-
ucts rirj in terms of Zi and Zj, we obtain an operator
of the form
H =
m
X
i=1
hiZi +
X
1≤i<j≤m
JijZiZj + const,
(45)
where hi and Jij are real coefficients that can be com-
puted by simple algebraic manipulations of Q and q, and
the constant shift does not change the ground state. This
operator H is a Hamiltonian acting on m qubits, writ-
ten as a linear combination of tensor products of Pauli-Z
matrices.
From a quantum computing point of view, the Hamil-
tonian H in (45) is the encoding of the topology design
binary block into the language of quantum mechanics.
Each bitstring r ∈{0, 1}m corresponds to a basis state
of the m-qubit system, and the QUBO cost becomes the
energy of that state. The optimal edge configuration is
obtained by finding the ground state of H, that is, the
eigenstate with the minimum eigenvalue.
4.2
QITE Solver
After we map the binary ADMM block to the Hamil-
tonian in (45), the problem becomes the following: we
want to find the ground quantum state of H, that is, the
quantum state with the smallest energy. Each bitstring
corresponds to one quantum basis state, and the energy
of that quantum state is equal to the QUBO cost. If we
can prepare the quantum ground state of H, we can read
out a good binary solution by measuring it. Note that
each time we talk about a state in this section is a quan-
tum state and not a state of MAS. We can think of the
energy of H as a landscape with many hills and valleys.
The ground state is the bottom of the deepest valley.
The QITE algorithm is a way to slide down this land-
scape. In quantum mechanics, time evolution is usu-
11


--- Page 12 ---
Fig. 2. Example of an ansatz circuit U(θ) for QITE
ally defined with the Schr¨odinger equation. If we re-
place the real-time variable t with −iτ, where i is the
imaginary unit, we obtain an imaginary-time equation.
This imaginary-time evolution damps the high-energy
components of the state while preserving the low-energy
components. After some imaginary time, the state tends
to align with the ground state of H.
Implementing this ideal imaginary-time evolution di-
rectly is difficult on current noisy quantum hardware, be-
cause it would require non-unitary operations. Instead,
QITE uses an approximate, variational approach. The
main idea is to restrict the search for the ground state to
a family of states generated by a fixed quantum circuit
with tunable parameters. We write
|ψ(θ)⟩= U(θ) |0⟩,
where U(θ) is called an ansatz and θ is a vector of real
parameters. In our setting, U(θ) is a hardware-efficient
circuit acting on the m qubits associated with the edge
variables. It contains several layers of single-qubit rota-
tions and entangling gates between nearby qubits. The
structure of U(θ) is fixed in advance, and only the rota-
tion angles in these gates are adjusted.
QITE then interprets the imaginary-time evolution as a
differential equation, not on the full state space, but on
the parameter vector θ. Conceptually, we want θ(τ) to
evolve in such a way that the ansatz state |ψ(θ(τ))⟩fol-
lows the ideal imaginary-time evolution of H as closely as
possible. This is why QITE is often described as a quan-
tum differential equation solver: the imaginary unit in
the original Schr¨odinger equation leads to an imaginary-
time equation, and QITE approximates its solution by
updating the circuit parameters rather than explicitly
evolving the full wavefunction.
In practice, the algorithm proceeds in small imaginary-
time steps. At each step, the following operations are
performed. First, the current parameters θ are fixed
and the ansatz circuit U(θ) is executed on the quan-
tum device to prepare the current state |ψ(θ)⟩. Second,
expectation values of certain observables that involve
the Hamiltonian H are measured, and the derivatives of
the state with respect to the parameters are calculated.
These measurements provide the numerical coefficients
of a small linear system that describes how θ should
change to approximate one step of imaginary-time evo-
lution. Third, the small linear system is solved, yielding
an update ∆θ. Finally, the parameters are moved in that
QUBO data (Q, q)
and Hamiltonian H
Initial parameters
θ(0)
Prepare ansatz state
|ψ(θ)⟩= U(θ)|0⟩
on quantum device
Measure expectation
values w.r.t. H
Build and solve small
linear system for ∆θ
Update parameters
θ ←θ + ∆θ
Approximate ground-state
parameters θ⋆and
low-energy bitstrings
Imaginary-time
steps
Fig. 3. Schematic view of the QITE procedure
direction, for example, θ ←θ + ∆θ. This procedure is
then repeated for several steps. Each step is designed to
decrease the energy expectation ⟨ψ(θ)|H|ψ(θ)⟩, so the
parameters gradually move toward a region where the
ansatz state has low energy.
After a finite number of imaginary-time steps, we obtain
a parameter vector θ⋆for which the ansatz state |ψ(θ⋆)⟩
has low energy with respect to H. This state is an ap-
proximation of the ground quantum state of the QUBO
Hamiltonian. To extract a binary topology from it, we
measure |ψ(θ⋆)⟩in the computational basis many times.
Each measurement produces a bitstring r ∈{0, 1}m,
which encodes one candidate set of active edges. The
probabilities of these bitstrings depend on the ampli-
tudes of the quantum state. In our implementation, we
collect the bitstrings with the highest empirical proba-
bilities, evaluate their exact QUBO cost z⊤Qz + q⊤z on
a classical computer, and select the bitstring with the
lowest cost as the solution of the binary block for that
ADMM iteration.
In the overall three-block ADMM algorithm, this QITE-
based solver is used as a module that proposes a binary
proxy vector r. At each ADMM iteration, the current
QUBO is converted to a Hamiltonian, QITE is run for a
limited number of imaginary-time steps, and a small set
of candidate bitstrings is sampled and evaluated. If the
new candidate improves the QUBO objective, it is ac-
cepted and used as the updated r; otherwise, the previ-
ous binary solution can be kept. In this way, the quantum
routine explores the combinatorial space of communica-
tion topologies, while the ADMM framework maintains
a clear structure and convergence properties for the full
topology design algorithm.
The overall closed-loop dynamic procedure that com-
bines ADMM-based topology optimization, QITE-based
binary updates, and consensus dynamics is summarized
12


--- Page 13 ---
Algorithm 2 Dynamic topology design
1: Inputs: initial states x(0) (and v(0)), update times {tℓ},
degree bound γ, ADMM parameters ρ, β, µ, QITE set-
tings (ansatz, steps, shots).
2: Choose initial connected graph G0 and Laplacian L0 sat-
isfying Assumption 2.
3: Set ℓ←0.
4: while closed-loop operation is active do
5:
Consensus evolution on [tℓ, tℓ+1):
6:
Simulate consensus with Lℓ:
7:
First-order: (3).
8:
Second-order: (8)–(9).
9:
At tℓ+1, measure agent positions (and velocities).
10:
Update edge weights wij via (10).
11:
Form MIQP (18) with costs (11), (13) and constraints
(18d)–(18g).
12:
Initialize ADMM:
13:
Choose (z(0), f (0), r(0), s(0), λ(0)), set k ←0.
14:
while ADMM stopping criterion not met do
15:
k ←k + 1.
16:
Block 1 (classical convex subproblem):
17:
Given r(k−1), s(k−1), λ(k−1), solve (22)
18:
for (z(k), f (k)) over C.
19:
Block 2 (quantum binary subproblem):
20:
Build QUBO cost Φ(r) in (42).
21:
Map QUBO to Ising H(k) via (44), (45).
22:
Run QITE for H(k):
23:
Initialize ansatz U(θ) (Fig. 2).
24:
for each imaginary-time step do
25:
Prepare |ψ(θ)⟩= U(θ)|0⟩.
26:
Measure expectations required by QITE.
27:
Build and solve the small linear system for ∆θ.
28:
Update θ ←θ + ∆θ.
29:
end for
30:
Sample bitstrings r from |ψ(θ)⟩.
31:
Evaluate Φ(r) and set r(k) to the best sample.
32:
Block 3 (auxiliary update):
33:
Update s(k) using (25).
34:
Dual update:
35:
Compute d(k) from (26) and update λ(k) via (27).
36:
Check convergence as in Theorem 2.
37:
end while
38:
Laplacian update:
39:
Construct Eℓ+1 and Lℓ+1 from the ADMM output
40:
(e.g., using r(k) or thresholded z(k)),
41:
ensuring (18d)–(18g) hold.
42:
Set ℓ←ℓ+ 1.
43: end while
in Algorithm 2.
5
Numerical Results
We present numerical examples that demonstrate the
proposed dynamic quantum topology design method.
All experiments are generated by a single Python script
that follows Algorithm 2. The simulations are carried
out on a classical computer, and the quantum routines
are executed on a Qiskit simulator rather than on real
quantum hardware. We use Qiskit version 0.46.3 and
qiskit-algorithms version 0.3.1. The QITE solver is im-
plemented using VarQITE from qiskit-algorithms, com-
bined with the ImaginaryMcLachlanPrinciple and an Ef-
ficientSU2 ansatz with linear entanglement. The com-
plete code is available at GitHub.
5.1
Simulation Setup and Implementation
The code starts by fixing the number of agents, the or-
der of the consensus dynamics, and the initial condi-
tions. The underlying candidate graph is the complete
undirected graph on n nodes, and from this edge list we
build a simple incidence matrix used to compute degrees
and to assemble the Laplacian from a given edge indica-
tor vector. In each topology update, the script calls the
ADMM routine that implements the three-block split-
ting described in Section 3.
Block 2 constructs the QUBO in the binary proxy vari-
able. From the resulting quadratic and linear coefficients,
we build an Ising Hamiltonian. When the brute-force
option is active, the code evaluates the exact QUBO
cost over all bitstrings and selects the best one, which is
useful for debugging and for small graphs. When QITE
is used, VarQITE evolves an EfficientSU2 ansatz under
imaginary time with respect to this Hamiltonian.
The ADMM hyperparameters are fixed at the beginning
of each run. The penalty parameter ρ is kept the same
in all experiments, while the penalty on the auxiliary
variable, denoted by β, is chosen as a simple function
of the number of agents. In the implementation β takes
moderate values (around 102) for small networks and
grows gradually for larger networks according to a geo-
metric rule. These values were tuned by trial and error
to achieve stable residual histories and reasonable con-
vergence speed, and they can be adjusted by the user for
different problem sizes.
After convergence of the ADMM loop at a given snap-
shot, the relaxed edge vector is thresholded at 0.5 to
produce a binary topology. From this binary vector, we
construct the Laplacian and compute its eigenvalues to
verify that the resulting graph is connected. The Lapla-
cian is then used in the consensus dynamics. The final
state at the end of the interval becomes the initial con-
dition for the next topology update. At each step, the
code computes a consensus error. The online loop stops
when this error falls below a chosen tolerance or when
a maximum simulation time is reached. In some exper-
iments, we also allow random perturbations of the po-
sitions when the error remains large for a long time, so
that the algorithm must reconfigure the topology.
5.2
Numerical Examples
In all examples, the candidate communication graph is
the complete undirected graph on n nodes, and the de-
gree bound is fixed at γ = 2. The degree penalty coeffi-
cients are chosen as κi = 0.1, i = 1, . . . , n, so that highly
13


--- Page 14 ---
unbalanced degree profiles are mildly penalized. The
ADMM hyperparameters are ρ = 20,
µcard = 0.1,
while the auxiliary penalty β is chosen as a function of
the network size n = NAGENTS:
β =



200,
n = 5,
400,
n = 6,
600,
n = 7.
The maximum number of ADMM iterations at each
topology update is set to kmax = 500 ADMM tolerance
10−3. For the second-order consensus dynamics we fix
the control gains α = 3.0,
β = 3.0, as in (9). The
initial positions are sampled uniformly at random in the
interval [−5, 5], xi(0) ∼U(−5, 5), and the initial veloci-
ties in the second-order cases are set to zero, vi(0) = 0.
The initial topology is a connected graph that satisfies
the degree bound and Assumption 2, and it is held con-
stant until t = 5 s. After this first update time, the
topology is recomputed every ∆t = 0.5 s using Algo-
rithm 2. The overall closed-loop simulation is capped at
Tmax = 10 s.
To monitor convergence we use a standard consensus
error metric. The closed-loop run is terminated as soon
as the position disagreement drops below the tolerance
e(t) ≤CONS TOL = 10−3
or when t reaches Tmax. The quantum binary block uses
VarQITE with imaginary-time horizon τ = 1.5, dis-
cretized in 30 steps, an EfficientSU2 ansatz with one
repetition and linear entanglement.
Example 1: Five Agents with First-Order Dynamics
In the first example we consider a network of n = 5
agents with first-order consensus dynamics (3).
Figure 4 shows the evolution of the agent positions.
Starting from dispersed initial conditions, the trajecto-
ries converge to a common value close to the initial av-
erage, in agreement with Theorem 1.
Figure 5 depicts the optimized graphs obtained during
the simulation. All node degrees satisfy deg(i) ≤γ =
2, and the resulting topology is sparse and close to a
path-like structure, which is consistent with the degree
constraints and with the quadratic degree penalty.
The corresponding consensus error (3) is plotted in
Fig. 6.
Example 2: Six Agents with Second-Order Dynamics
In the second example, we consider a network of n = 6
agents with second-order consensus dynamics (8)–(9).
Fig. 4. Example 1 (first-order consensus with n = 5 agents):
evolution of the agent positions
Fig. 5. optimized communication graphs
Fig. 6. consensus error versus time
Fig. 7. Example 2 (second-order consensus with n = 6
agents): evolution of the agent positions
Figure 7 shows the evolution of the agent positions. The
trajectories converge to a common value, consistent with
second-order consensus.
Figure 8 shows the corresponding velocity trajectories,
which converge to zero for all agents.
14


--- Page 15 ---
Fig. 8. Example 2: evolution of the agent velocities
Fig. 9. Example 2: optimized communication graphs
Fig. 10. Example 2: position and velocity consensus errors
versus time
Figure 9 depicts the optimized communication graphs
obtained during the simulation. All node degrees satisfy
deg(i) ≤γ = 2, and the resulting topologies remain
sparse and connected.
The corresponding position and velocity consensus er-
rors are plotted in Fig. 10.
Example 3: Seven Agents with Second-Order Dynamics
In the third example, we consider a network of n = 7
agents with second-order consensus dynamics (8)–(9).
Figure 11 shows the evolution of the agent positions.
Despite the larger network, the trajectories converge to
a common value.
Figure 12 shows the velocity trajectories, which converge
to zero for all agents.
Figure 13 depicts the optimized communication graphs
obtained during the simulation. The topologies are
Fig. 11. Example 3 (second-order consensus with n = 7
agents): evolution of the agent positions
Fig. 12. Example 3: evolution of the agent velocities
Fig. 13. Example 3: optimized communication graphs
Fig. 14. Example 3: position and velocity consensus errors
versus time
sparse, degree-bounded, and remain connected through-
out the run.
The corresponding position and velocity consensus er-
rors are plotted in Fig. 14.
15


--- Page 16 ---
6
Conclusion
We proposed a dynamic quantum framework for on-
line communication topology design in consensus-based
linear multi-agent systems, formulating the problem as
an MIQP with explicit communication, distance, and
degree costs, and exact flow-based connectivity con-
straints. A three-block ADMM splitting was introduced
that keeps all graph constraints in a convex classical
block, isolates a pure binary unconstrained block, and
couples them via a simple auxiliary update, so that only
the binary core is delegated to a quantum solver. The
binary block is mapped to a QUBO Hamiltonian and
approximately solved by QITE, which embeds a fully
quantum ground-state routine within a structured clas-
sical decomposition while preserving first- and second-
order consensus guarantees under mild connectivity and
dwell-time assumptions. Numerical simulations with five
to seven agents show that the method produces sparse,
degree-bounded, connected topologies that achieve con-
sensus and communication costs, illustrating a concrete
pathway for integrating near-term quantum optimizers
into closed-loop distributed control.
References
[1]
Stefalo
Acha
and
Sun
Yi.
Application
of
quantum
telecommunication in multi-agent system. Discover Robotics,
1(1):3, 2025.
[2]
Akshay Ajagekar and Fengqi You. Quantum computing for
energy systems optimization: Challenges and opportunities.
Energy, 179:76–89, 2019.
[3]
Rosario Aragues, Guodong Shi, Dimos V Dimarogonas,
Carlos Sag¨u´es, Karl Henrik Johansson, and Youcef Mezouar.
Distributed algebraic connectivity estimation for undirected
graphs
with
upper
and
lower
bounds.
Automatica,
50(12):3253–3259, 2014.
[4]
Samuel Burer and Adam N Letchford.
On nonconvex
quadratic programming with box constraints. SIAM Journal
on Optimization, 20(2):1073–1089, 2009.
[5]
Ana Maria de Almeida, Pedro Martins, and Maur´ıcio C
de
Souza.
Min-degree
constrained
minimum
spanning
tree
problem:
complexity,
properties,
and
formulations.
International
Transactions
in
Operational
Research,
19(3):323–352, 2012.
[6]
Edward
Farhi,
Jeffrey
Goldstone,
and
Sam
Gutmann.
A quantum approximate optimization algorithm.
arXiv
preprint arXiv:1411.4028, 2014.
[7]
Michel X Goemans.
Minimum bounded degree spanning
trees. In 2006 47th Annual IEEE Symposium on Foundations
of Computer Science (FOCS’06), pages 273–282. IEEE, 2006.
[8]
Lov K Grover.
A fast quantum mechanical algorithm for
database search. In Proceedings of the twenty-eighth annual
ACM symposium on Theory of computing, pages 212–219,
1996.
[9]
Ke Guo, Deren Han, David ZW Wang, and Tingting Wu.
Convergence of admm for multi-block nonconvex separable
optimization models.
Frontiers of Mathematics in China,
12(5):1139–1162, 2017.
[10] Milad
Hasanzadeh,
Mahdi
Baradarannia,
and
Farzad
Hashemzadeh. Distributed fixed-time rotating encirclement
control of linear multi-agent systems with moving targets.
Journal of the Franklin Institute, 361(11):106970, 2024.
[11] Milad Hasanzadeh and Shu-Xia Tang.
Dynamic average
consensus as distributed PDE-based control for multi-agent
systems. In 2024 European Control Conference (ECC), pages
828–833. IEEE, 2024.
[12] Mingyi Hong, Zhi-Quan Luo, and Meisam Razaviyayn.
Convergence analysis of alternating direction method of
multipliers for a family of nonconvex problems.
SIAM
Journal on Optimization, 26(1):337–364, 2016.
[13] A Jenefa, K Vidhya, Antony Taurshia, V Edward Naveen,
Bessy M Kuriakose, and V Vijula.
Enhancing distributed
agent environments with quantum multi-agent systems and
protocols. Multiagent and Grid Systems, 20(2):109–127, 2024.
[14] Amin
Kargarian,
Javad Mohammadi, Junyao Guo, Sambuddha Chakrabarti,
Masoud Barati, Gabriela Hug, Soummya Kar, and Ross
Baldick. Toward distributed/decentralized dc optimal power
flow implementation in future electric power systems. IEEE
Transactions on Smart Grid, 9(4):2574–2594, 2016.
[15] Mehran Mesbahi and Magnus Egerstedt.
Graph theoretic
methods in multiagent networks. 2010.
[16] Ashley Montanaro. Quantum algorithms: an overview. npj
Quantum Information, 2(1):1–8, 2016.
[17] Mario Motta, Chong Sun, Adrian TK Tan, Matthew J
O’Rourke, Erika Ye, Austin J Minnich, Fernando GSL
Brandao, and Garnet Kin-Lic Chan. Determining eigenstates
and thermal states on a quantum computer using quantum
imaginary time evolution.
Nature Physics, 16(2):205–210,
2020.
[18] Michael
A
Nielsen
and
Isaac
L
Chuang.
Quantum
computation
and
quantum
information.
Cambridge
university press, 2010.
[19] Reza Olfati-Saber, J Alex Fax, and Richard M Murray.
Consensus
and
cooperation
in
networked
multi-agent
systems. Proceedings of the IEEE, 95(1):215–233, 2007.
[20] Alberto Peruzzo, Jarrod McClean, Peter Shadbolt, Man-
Hong Yung, Xiao-Qi Zhou, Peter J Love, Al´an Aspuru-
Guzik, and Jeremy L O’brien. A variational eigenvalue solver
on a photonic quantum processor. Nature communications,
5(1):4213, 2014.
[21] John Preskill.
Quantum Computing in the NISQ era and
beyond. Quantum, 2:79, August 2018.
[22] Mohammad Rafiee and Alexandre M Bayen.
Optimal
network topology design in multi-agent systems for efficient
average consensus.
In 49th IEEE Conference on Decision
and Control (CDC), pages 3877–3883. IEEE, 2010.
[23] Ramamoorthi Ravi, Madhav V Marathe, SS Ravi, Daniel J
Rosenkrantz,
and
Harry
B
Hunt
III.
Approximation
algorithms for degree-constrained minimum-cost network-
design problems. Algorithmica, 31(1):58–78, 2001.
[24] Peter W Shor.
Polynomial-time algorithms for prime
factorization
and
discrete
logarithms
on
a
quantum
computer. SIAM review, 41(2):303–332, 1999.
[25] Neelkamal
Somisetty,
Harsha
Nagarajan,
and
Swaroop
Darbha. Optimal robust network design: Formulations and
algorithms for maximizing algebraic connectivity.
IEEE
Transactions on Control of Network Systems, 2024.
[26] Shize Su and Zongli Lin. Distributed consensus control of
multi-agent systems with higher order agent dynamics and
dynamically changing directed interaction topologies. IEEE
Transactions on Automatic Control, 61(2):515–519, 2015.
16


--- Page 17 ---
[27] Emma Tegling, Bassam Bamieh, and Henrik Sandberg. Scale
fragilities in localized consensus dynamics.
Automatica,
153:111046, 2023.
[28] Juan Pablo Vielma.
Mixed integer linear programming
formulation techniques. Siam Review, 57(1):3–57, 2015.
[29] Yu Wang, Wotao Yin, and Jinshan Zeng. Global convergence
of admm in nonconvex nonsmooth optimization. Journal of
Scientific Computing, 78(1):29–63, 2019.
[30] Peng Yang, Randy A Freeman, Geoffrey J Gordon, Kevin M
Lynch, Siddhartha S Srinivasa, and Rahul Sukthankar.
Decentralized estimation and control of graph connectivity
for mobile sensor networks. Automatica, 46(2):390–396, 2010.
[31] Wenwu Yu, Guanrong Chen, Ming Cao, and J¨urgen Kurths.
Second-order consensus for multiagent systems with directed
topologies and nonlinear dynamics.
IEEE Transactions
on Systems, Man, and Cybernetics, Part B (Cybernetics),
40(3):881–891, 2009.
[32] Jun
Zhao
and
Wenhan
Yu.
Quantum
multi-agent
reinforcement learning as an emerging ai technology: A survey
and future directions. Authorea Preprints, 2023.
17
