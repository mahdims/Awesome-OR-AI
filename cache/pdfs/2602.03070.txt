--- Page 1 ---
ProOPF: Benchmarking and Improving LLMs for Professional-Grade
Power Systems Optimization Modeling
Chao Shen * 1 Zihan Guo * 2 Xu Wan * 1 Zhenghao Yang 2 Wenqi Huang 3 Jie Song 2 Zongyan Zhang 2
Mingyang Sun 2
Abstract
Growing renewable penetration introduces sub-
stantial uncertainty into power system opera-
tions, necessitating frequent adaptation of dis-
patch objectives and constraints and challeng-
ing expertise-intensive, near-real-time modeling
workflows. Large Language Models (LLMs) pro-
vide a promising avenue for automating this pro-
cess by translating natural-language (NL) opera-
tional requirements into executable optimization
models via semantic reasoning and code syn-
thesis. Yet existing LLM datasets and bench-
marks for optimization modeling primarily tar-
get coarse-grained cross-domain generalization,
offering limited, rigorous evaluation in power-
system settings, particularly for Optimal Power
Flow (OPF). We therefore introduce ProOPF-
D and ProOPF-B, a dataset and benchmark for
professional-grade OPF modeling: ProOPF-D
contains 12K instances pairing NL requests with
parameter adjustments and structural extensions
to a canonical OPF, together with executable im-
plementations; ProOPF-B provides 121 expert-
annotated test cases with ground-truth code, en-
abling end-to-end evaluation under both concrete
and abstract OPF modeling regimes.
1. Introduction
Power system optimization modeling has become increas-
ingly complex as growing renewable penetration and ex-
panding system scale amplify the diversity of operating
conditions and operational requirements (Shen et al., 2025;
Biagioni et al., 2020; Pan et al., 2020; Wan et al., 2023). In
this context, optimal power flow (OPF) and its variants serve
as a foundational modeling framework that underpins a wide
range of operational decision-making tasks in power sys-
tems (Abdi et al., 2017; Zuo et al., 2025). Since its introduc-
tion by Carpentier in 1962 (Carpentier, 1962), OPF has been
widely deployed to optimize generation and network oper-
ation under physical power flow laws and operational con-
straints, delivering substantial economic benefits (Schecter
& O‚ÄôNeill, 2013). In real-world operations, diverse oper-
ating conditions are typically reflected through parameter
variations in OPF instances, such as changes in loads, or net-
work limits (Pan et al., 2020; Rivera et al., 2026). Beyond
parametric changes, certain scenarios impose additional
operational requirements‚Äîe.g., security constraints‚Äîthat
necessitate structural modifications to OPF formulations,
including the introduction of new objectives, constraints, or
decision variables (Wang et al., 2023; Zuo et al., 2025). As
a result, practical OPF-based power system optimization
remains heavily dependent on domain expertise to interpret
operating contexts and to select appropriate formulation
components that ensure both physical consistency and oper-
ational validity (Jia et al., 2025).
Recent advances in large language models (LLMs), exem-
plified by GPT (Achiam et al., 2023) and Qwen (Bai et al.,
2023), have made it increasingly feasible to leverage LLMs
for optimization modeling and code generation from natural
language (NL) specifications, including OPF in power sys-
tems (Jia et al., 2025). Motivated by this prospect, numerous
benchmarks have been proposed to evaluate LLM capabili-
ties in optimization modeling (Xiao et al., 2025), including
NL4Opt (Ramamonjison et al., 2023) for NL-to-formulation
translation, and MAMO (Huang et al., 2024) and Optibench
(Yang et al., 2025b), which incorporate paired solutions
and industry-inspired instances. Despite these advances,
existing benchmarks focus on coarse-grained cross-domain
generalization across heterogeneous optimization tasks (e.g.,
vehicle routing (Xiao et al., 2023) and job-shop scheduling
(Yang et al., 2025b)) as shown in Figure 1, but fall short in
evaluating fine-grained, expert-level modeling competence,
which is essential for power system operation.
Complementing these benchmarks, a range of datasets and
data synthesis pipelines has been developed to support LLM
training for optimization modeling (Huang et al., 2025;
Jiang et al., 2025; Yang et al., 2025b). Existing synthe-
sis pipelines adopt two complementary approaches: either
rewriting NL problem descriptions and inferring correspond-
ing optimization models (Huang et al., 2025), or operat-
ing directly on structured optimization models and reverse-
generating aligned NL descriptions (Huang et al., 2025;
1
arXiv:2602.03070v3  [eess.SY]  6 Feb 2026


--- Page 2 ---
Title Suppressed Due to Excessive Size
LLM-based Optimization
Vehicle 
Routing
Power System 
Planning
Finance ‚Ä¶
Existing benchmarks & datasets  (cross-domain & coarse-grained)
General-Purpose Optimization
Power Optimization Specific 
Increasing Specialization
Optimal Power Flow (OPF)
Power System Optimization
Load
Impedance
Cost
‚Ä¶
Parametric Modifications
Structural Modifications
Security
Uncertainty
‚Ä¶
Robust
The Proposed ProOPF-B/D (within-domain & fine-grained)
(a) From cross-domain to within-domain generalization
NL4OPT
MAMO-EasyLP
Optibench ProOPF-B (ours)
Optimization Benchmarks
0
20
40
60
80
100
Accuracy (%)
85.9
93.0
69.1
14.1
82.4
90.3
58.3
33.9
93.5
92.3
49.5
29.8
91.5
93.7
48.6
23.3
82.6
75.8
53.9
37.2
GPT-5.2
Claude-4.5-Sonnet
Deepseek-3.2
Qwen3-Coder
Gemini-3-pro
(b) Comparison of existing benchmarks and ProOPF-B
Figure 1. From cross-domain to within-domain generalization in LLM-based optimization. Existing works emphasize coarse-grained
generalization across heterogeneous optimization tasks, whereas ProOPF-B/D targets fine-grained, within-domain generalization in OPF
through parametric and structural formulation modifications.
Yang et al., 2025b). However, these pipelines exhibit three
limitations: 1) they focus only on mathematical solvability
without explicitly enforcing physical validity; 2) insufficient
fine-grained coverage of realistic OPF operating scenarios;
and 3) they mainly supervise LLMs to generate complete
optimization formulations, which is unnecessary for OPF
modeling and prone to introducing physical and modeling
inconsistencies.
To bridge these gaps, we introduce ProOPF-D (Dataset)
and ProOPF-B (Benchmark)1 to systematically improve
and evaluate LLM competence in professional-grade power
system optimization modeling. 1) ProOPF-D comprises
12K samples organized into four difficulty levels, defined
by the form of parameter specification (explicit versus infer-
ence) and the required degree of structural extension beyond
a base OPF formulation. ProOPF-D designs a modification-
based representation in which each instance specifies the
differential components (parameter changes and structural
extensions) rather than the full OPF formulations. In addi-
tion, expert-curated constraints restrict the feasible spaces of
parameter modifications and structural extensions to enforce
physical consistency with power system laws. 2) ProOPF-B
comprises 121 benchmark instances spanning all four diffi-
culty levels of ProOPF-D. Each instance is expert-annotated
with representative OPF modeling tasks from the litera-
ture, facilitating systematic evaluation across OPF modeling
complexities. As shown in Figure 1b, while state-of-the-art
LLMs can achieve over 90% accuracy on existing bench-
marks, their performance drops to below 30% on ProOPF-B,
highlighting the need for fine-grained, professional-grade
evaluation frameworks to accurately assess domain-specific
modeling competence.
1ProOPF-D and ProOPF-B are available: ProOPF-B/D reposi-
tory
The main contributions of this work are:
1. We introduce ProOPF-D/B, the first dataset & bench-
mark designed to systematically evaluate LLM competence
in specialized power system optimization modeling, shift-
ing LLM-based optimization to large-scale, complex power
domain specific modeling.
2. For ProOPF-D, we introduce a novel multi-level dataset
construction pipeline that systematically progresses from
explicit to inferred parameters and from parametric changes
to structural extensions. Each instance is represented as
a modification to a canonical OPF formulation and con-
strained within physically feasible spaces, with aligned NL
descriptions, OPF modeling specifications, and executable
implementations.
3. For ProOPF-B, we construct a benchmark from expert-
selected, peer-reviewed literature and aligned its difficulty
tiers with those of ProOPF-D. In particular, a level-specific
evaluation protocol is proposed that distinguishes concrete
and abstract OPF-based modeling, enabling rigorous end-
to-end assessment of executable correctness.
2. Related Work
Benchmarks for Optimization Modeling. A range of
benchmarks have been developed to evaluate optimiza-
tion modeling from NL using LLMs. Early work such as
NL4Opt (Ramamonjison et al., 2023) focuses on translating
NL descriptions into mathematical formulations, without
considering solver execution. Subsequent benchmarks, in-
cluding ComplexOR (Xiao et al., 2023), NLP4LP (Ahma-
diTeshnizi et al., 2023), and Mamo (Huang et al., 2024),
provide paired NL descriptions and optimization solutions,
but remain largely confined to linear or mixed-integer linear
programs. More recent benchmarks, such as IndustryOR
2


--- Page 3 ---
Title Suppressed Due to Excessive Size
(Huang et al., 2025) and OptiBench (Yang et al., 2025b),
extend coverage to nonlinear optimization problems derived
from industrial scenarios.
However, prior benchmarks largely emphasize breadth
across heterogeneous optimization domains, which limits
fine-grained evaluation on complex, power-domain specific
tasks such as OPF with tightly coupled physical constraints.
A substantial scale gap further complicates assessment: even
small OPF instances (e.g., IEEE 9-bus) typically have >20
decision variables and >60 constraints, while IndustryOR
averages fewer than 15 variables and constraints per instance
(Xiao et al., 2025).
Datasets Synthesis for LLM-based Optimization
High-quality training data for optimization modeling re-
mains scarce, motivating data synthesis techniques to
construct scalable datasets (Xiao et al., 2025). Existing
synthesis pipelines broadly fall into problem-centric and
model-centric approaches. Problem-centric methods ex-
pand datasets by rewriting NL descriptions from seed prob-
lems and inferring corresponding optimization models (e.g.,
OR-Instruct (Huang et al., 2025), LLMOPT (Jiang et al.,
2025), Evo-Step-Instruct (Wu et al., 2024)), but they strug-
gle to systematically scale instance complexity, as map-
ping increasingly elaborate NL to valid and solvable models
can be fragile. By contrast, model-centric methods oper-
ate directly on structured optimization models and reverse-
generate aligned NL descriptions (e.g., ReSocratic (Yang
et al., 2025b), MILP-Evolve (Li et al., 2024)), offering con-
trollable instance generation with solvability and semantic
consistency.
Across paradigms, samples are often generated by perturb-
ing seed problems without explicitly enforcing domain
physics (e.g., power flow constraints), so physical feasi-
bility may be violated even when the formulation is mathe-
matically well-posed. Moreover, most pipelines supervise
LLMs to regenerate complete models; for OPF, instances
largely share a common backbone and differ mainly via
scenario-dependent parameter updates and structured ex-
tensions, making end-to-end regeneration redundant and
error-prone.
3. Power System Optimization Modeling
3.1. Foundation: Optimal Power Flow Problem
The OPF problem seeks optimal generator dispatch and net-
work operating conditions by minimizing generation cost
under power flow equations and network operating con-
straints. Given a power system represented as a graph with
bus set N, branch set E, and generator set G ‚äÜN, the OPF
problem can be formulated as:
min
x
f(x)
(1)
s.t.
g(x) = 0, h(x) ‚â§0,
(2)
x ‚àà[ x, x ].
(3)
where x = [V , Œ∏, P G, QG] denotes the decision variables,
including the voltage magnitudes V = {Vi}i‚ààN and phase
angles Œ∏ = {Œ∏i}i‚ààN at all buses, as well as the active and
reactive power outputs of generators, P G = {PG,g}g‚ààG and
QG = {QG,g}g‚ààG. The objective function f(x) represents
the total generation cost and is defined as
f(x) =
X
g‚ààG
 agP 2
G,g + bgPG,g + cg

,
(4)
where ag, bg, and cg denote the cost coefficients of g-th
generator. The equality constraints g(x) are given by the
real and reactive power balance equations at each bus i ‚ààN:
PG,i ‚àíPD,i = Vi
X
j‚ààN
Vj (Gij cos Œ∏ij + Bij sin Œ∏ij) ,
QG,i ‚àíQD,i = Vi
X
j‚ààN
Vj (Gij sin Œ∏ij ‚àíBij cos Œ∏ij) ,
(5)
Here, PG,i and QG,i denote the active and reactive power
injections at bus i (set to zero if no generator is connected),
PD,i and QD,i are the corresponding power demands, Gij
and Bij denote the conductance and susceptance between
buses i and j, and Œ∏ij = Œ∏i ‚àíŒ∏j is the voltage phase angle
difference. The inequality constraints h(x) enforce branch
thermal limits by bounding the apparent power flows at both
ends of each transmission line. For each branch (i, j) ‚ààE,
the apparent power magnitudes at the from and to ends are
constrained by
|Sf,ij| = |ViI‚àó
f,ij| ‚â§Sij,
|St,ij| = |VjI‚àó
t,ij| ‚â§Sij, (6)
where |Sf,ij| and |St,ij| are the apparent power at the from
and to ends, Vi and Vj are the complex bus voltages, If,ij
and It,ij are the complex branch currents, (¬∑)‚àódenotes the
complex conjugate, and Sij is the thermal apparent power
limit of branch (i, j). The variable limits in (3) impose
bounds on bus voltage magnitudes and phase angles, as well
as on generator active and reactive power outputs:
Vi ‚àà[V i, V i], Œ∏i ‚àà[Œ∏i, Œ∏i], ‚àÄi‚ààN;
PG,g ‚àà[P G,g, P G,g], QG,g ‚àà[QG,g, QG,g], ‚àÄg‚ààG.
(7)
where (¬∑) and (¬∑) denote the lower and upper bounds.
3.2. Base Model Modification
The OPF formulation in (4)‚Äì(7) produces a large-scale,
tightly coupled nonlinear program, with O(|N| + |G|) deci-
sion variables and O(|N| + |E| + |G|) constraints. At this
3


--- Page 4 ---
Title Suppressed Due to Excessive Size
scale, annotating complete models is costly, and generating
complete formulations while preserving global structural
validity (indexing, dimensions, and network couplings) is
brittle. We therefore leverage the invariant physical back-
bone shared across OPF instances and supervise only what
varies‚Äîparameter updates and structured extensions‚Äîby
representing each instance as a modification of a canonical
base model. To formalize this, we introduce a base OPF
problem Q0 corresponding to (4)‚Äì(7), parameterized by
base system parameters œÄsys with the following structure:
œÄsys ‚âú{(ag, bg, cg)g‚ààG, (Gij, Bij, Sij)(i,j)‚ààE,
(x, x), (PD,i, QD,i)i‚ààN }.
(8)
We parameterize each target OPF model Q as a modification
of the canonical base model Q0, specified by parameter
modifications ‚àÜœÄ and a structural modification operator s:
Q(‚àÜœÄ,s | œÄsys) ‚âúModifys(Q0(œÄsys + ‚àÜœÄ)) ,
‚àÜœÄ ‚àà‚Ñ¶œÄ, s ‚àà‚Ñ¶s ‚à™{‚àÖ},
(9)
where ‚Ñ¶œÄ and ‚Ñ¶s are expert-curated sets of admissible pa-
rameter modifications and structural modification operators,
respectively.
4. ProOPF-D: Expert-Curated Dataset via
Modification-Based OPF Representation
4.1. Structured Sample Representation
Each sample z ‚ààProOPF-D is represented as a triple
z = {P, M, I},
(10)
where P denotes an NL description of OPF modeling and
solving requirements, M denotes a target OPF model speci-
fication, and I denotes an executable implementation of M.
Following (9), the target OPF model Q is fully specified by
parameter modifications ‚àÜœÄ, structural modification opera-
tor s, and base system parameters œÄsys. Accordingly, M is
represented as
M = {œâ, ‚àÜœÄ, s, R
	
,
(11)
where œâ ‚àà‚Ñ¶sys identifies a reference power system and re-
trieves the corresponding base parameters œÄsys(œâ). The
complete list of systems in ‚Ñ¶sys is provided in subsec-
tion A.1. Parametric modifications ‚àÜœÄ are organized as a
finite set of parameter patches {Œ¥k}K
k=1 where each patch Œ¥k
is a structured tuple encoding the component type, target pa-
rameter identifier, modification operation, value, and other
fields. Structural modifications s are organized as a triple
s = {sp, sc, so} where sp denotes the problem type (e.g.,
DCOPF), sc specifies constraint extensions (e.g., security
constraints), and so encodes objective function modifica-
tions (e.g., renewable curtailment penalties). Each compo-
nent may contain multiple fields specifying the modification
type and formulation details. The resolution specification
R encodes solver configuration parameters including solver
selection (e.g., MIPS), termination criteria (e.g., violation
tolerance), and output options. The space ‚Ñ¶R denotes the
set of all admissible solver requirement. Detailed specifica-
tions M are provided in Appendix A.
4.2. Multi-Level Difficulty Taxonomy and Synthesis
ProOPF-D is categorized into four levels based on the de-
gree of expert knowledge required to translate an NL re-
quest into an executable OPF formulation. In particular, we
consider two orthogonal dimensions: whether parameter
modifications ‚àÜœÄ are explicitly specified in P or should be
inferred from scenario-dependent operational description,
and whether a structural modification s ‚ààS is required
beyond the base OPF model. The Cartesian product of these
two binary dimensions yields four difficulty levels that sys-
tematically cover the modeling action space ‚Ñ¶œÄ√ó(S‚à™{‚àÖ}),
spanning a progressive spectrum from basic modification
to expert-level model adaptation. Data synthesis follows a
model-centric paradigm: M is first instantiated from the
level-specific sampling space ‚Ñ¶Li
M for level i, then P and I
are derived through deterministic or LLM-guided generation
conditioned on M. Complete examples and prompts used
for LLM-based generation of P and I for all four levels are
provided in Appendix D. The synthesis procedures for each
level are shown in Figure 2 and formalized as pseudocode
algorithms (Algorithm 1-4) in Appendix C. We elaborate
on each level below.
Level 1 (L1): Explicit Parameter Specification
Task Definition. L1 covers cases in which parameter modi-
fications ‚àÜœÄ are explicitly specified in P without any struc-
tural modifications (s = ‚àÖ). For example, the input de-
scription ‚ÄúIncrease active loads at Bus 7 by 10%‚Äù explicitly
specifies ‚àÜœÄ and enables direct model instantiation. Such
explicit parameter directives commonly arise in control-
room operations and what-if studies, where measurements,
forecasts, or operating limits are already quantified and can
be issued as numeric updates. L1 evaluates the model‚Äôs abil-
ity to parse explicit numerical instructions and accurately
map them to corresponding OPF parameter configurations.
Data Synthesis. For each sample z ‚ààL1, we construct the
data instance via a two-stage generative process. First, an
OPF model specification is uniformly sampled as ML1 ‚àº
U

‚Ñ¶L1
M

, where ‚Ñ¶L1
M := ‚Ñ¶sys√ó‚Ñ¶œÄ√ó{‚àÖ}√ó‚Ñ¶R denotes the
sampling space over system templates, explicit parameter
patches, empty structural modifications, and solver require-
ments.
Conditioned on the sampled model specification ML1 and
a pre-defined instruction specification œÑ, an NL request P
and an executable implementation I are generated by the
4


--- Page 5 ---
Title Suppressed Due to Excessive Size
Structural
Extensions
( »Ø ‚àà⁄ús )
Base 
OPF
(                )
Explicit Instruction
EXÔºö‚Äúincrease active loads at bus 7 by 10%‚Äù
Semantic inference 
EXÔºö‚Äúheatwave conditions with elevated risk of transmission line thermal sag‚Äù
Random
Sampling
Template
⁄∞‡™è◊Ü
‡™ê‡™è◊ä
‡™ê‡™è◊Ü
Ìúü⁄¨
generators at bus 32         500 MW
Ìúü⁄¨
«Ä÷ç’Ω÷ë at bus 10         0
opf.violation         1e-8
OPF Model ⁄µ
Solver
R
OPF Model ⁄µ
Solver
R
Structural
 Library
s
Template
⁄∞‡™è◊ä
Expert Tree 
Retrieve
‡™ê‡™è◊å
Structural
 Library
s
OPF Model ⁄µ
Solver
R
{»π…Å}…Å=◊Ö
»ß
‡™ê‡™è◊à
{»π…Å}…Å=◊Ö
»ß
           par ÿ∞÷Ö = ∆Ω’Ω÷Å
dir ÿ∞÷Ö = decrease
ÿ∞÷Ö sampled:
 ‚ÄúExtreme heatwave‚Äù 
+
 ‚ÄúReduced transmission 
thermal margin‚Äù
«á÷Ö
Ex: 
Ex: 
OPF Model⁄µ
Solver
R
Template
⁄∞‡™è◊à
Template
⁄∞‡™è◊å
Level 1 
Level 3 
Level 2 
Level 4 
Data Cleaning 
Text Refinement
&
3K
Size
Dataset
‚Ñí1
‚Ñí2
‚Ñí3
‚Ñí4
»Ø ‚àà‚àÖ 
Figure 2. The ProOPF-D dataset construction pipeline. L1 generates samples by directly instantiating OPF models from explicitly
specified parameter patches. L2 synthesizes scenario-driven samples by mapping qualitative operational descriptions to parameter
modification directions using expert-curated scenario trees. L3 extends the base OPF formulation with expert-designed structural variants
combined with explicit parameter updates. L4 integrates semantic parameter inference and structural extensions, representing the most
challenging expert-level modeling setting. Finally, the synthetic data undergoes Data Cleaning and Text Refinement, resulting in a total
dataset of 12k samples evenly distributed across four levels (3k each).
LLM according to
(P, I) ‚àºpLLM
 ¬∑ | ML1, œÑ L1
,
(12)
where œÑ L1 defines structured prompting rules that guide
the LLM in translating the sampled parameter patches and
solver requirements into coherent NL descriptions and exe-
cutable MATPOWER code. The complete sample z is then
formed by combining ML1, P, and I.
Level 2 (L2): Semantic Parameter Inference
Task Definition. In L2, parameter modifications ‚àÜœÄ are
implicitly conveyed through operational scenario descrip-
tions, requiring models to infer affected parameter types and
qualitative variation trends without concrete numerical val-
ues. For instance, the description ‚Äúheatwave conditions with
elevated risk of transmission line thermal sag‚Äù semantically
implies thermal constraint tightening, which translates to
decreased apparent power limits Sij. More generally, L2
maps scenario-level semantic cues to qualitative parameter
adjustments (e.g., increase, decrease, no change), typical of
event-driven operating conditions (e.g., heatwaves, storms,
contingencies) where only qualitative implications for limits
and demands are available.
Data Synthesis. For each sample z ‚ààL2, a model specifi-
cation ML2 is sampled uniformly from
‚Ñ¶L2
M := ‚Ñ¶sys √ó ‚Ñ¶dir
œÄ √ó {‚àÖ} √ó ‚Ñ¶R.
(13)
Compared to L1, the space ‚Ñ¶dir
œÄ consists of parameter
patches Œ¥k without concrete values, each characterized by a
parameter identifier par(Œ¥k) and a qualitative modification
indicator dir(Œ¥k) ‚àà{INCREASE, DECREASE, SETZERO}.
However, directly prompting an LLM with ML2 to generate
P is problematic for two reasons. First, exposing parameter
identifiers and modification directions in the prompt may
cause the generated P to explicitly enumerate these param-
eters and their trends (e.g., ‚Äúdecrease thermal limits Sij‚Äù),
which leaks the inference targets that L2 is designed to eval-
uate. Second, unconstrained generation without domain-
specific guidance may yield semantically misaligned sce-
nario descriptions due to limited coverage of power system
operational semantics.
To address this, we introduce a collection of expert-curated
scenario trees T = {Tm}M
m=1 (see Figure 3), hierarchically
organizing operational semantics from event-level nodes
(E-level, e.g., extreme heatwave) to mechanism-level nodes
(M-level, e.g., reduced transmission thermal margin), with
leaf nodes annotated by parameter-direction pairs. Given
‚àÜœÄ = {Œ¥k}K
k=1 ‚àà‚Ñ¶dir
œÄ , we retrieve the corresponding leaf
nodes:
Vk = Retrieve(T | par(Œ¥k), dir(Œ¥k)) ,
(14)
where Vk consists of all leaf nodes in T whose associ-
ated parameter and direction annotations match par(Œ¥k)
and dir(Œ¥k), respectively. Let Nk denote the set of root-to-
leaf paths induced by Vk. A scenario fragment is sampled
uniformly as ck ‚àºU(Nk), where each ck is a concatenation
of E-level and M-level nodes along a root-to-leaf path. The
resulting fragment set c = {ck}K
k=1 replaces ‚àÜœÄ to form
the intermediate specification f
ML2:
f
ML2 = {œâ, {ck}K
k=1, s, R}
(15)
5


--- Page 6 ---
Title Suppressed Due to Excessive Size
Retrieve: ùëÜùëñùëó, Decrease
ùúπùíåsampled:
par ùõøùëò= ùëÜùëñùëó
dir ùõøùëò= decrease
ùíÑùíåmatch scenario:
‚ÄúExtreme heatwave‚Äù + 
‚ÄúReduced transmission 
thermal margin‚Äù
Expert-curated Scenario Trees
‚Ä¶
ùëÜùëñùëó
ùëÉùê∫,ùëî
ùëÉùê∑
‚Ä¶
Event
Mech.
Param-
-Dir
Increased air-
condition usage
Reduced branch 
thermal margin
Generator 
derating
Hurricane
Extreme Heatwave
Ice Storm
‚Ä¶
Figure 3. Expert-curated scenario trees for L2 synthesis. Top: Hi-
erarchical structure from event-level (E-level) through mechanism-
level (M-level) nodes to leaf nodes encoding parameter types
and modification trends.
Bottom:
Retrieval process where
Retrieve(T | par(Œ¥k), dir(Œ¥k)) matches parameter patch Œ¥k to
leaf nodes, and the root-to-leaf path forms scenario fragment ck.
This substitution prevents the leakage of inference targets by
removing direct ‚àÜœÄ exposure. Meanwhile, the scenario frag-
ments {ck}K
k=1 facilitate diverse and semantically grounded
scenario descriptions aligned with power system operational
knowledge. Given f
ML2 and instructions œÑ L2, the LLM gen-
erates the NL description P and executable implementation
I jointly:
(P, I) ‚àºpLLM

¬∑ | f
ML2, œÑ L2
,
(16)
where œÑ L2 directs the LLM to aggregate scenario fragments
{ck}K
k=1 into a coherent operational narrative in P and to
express I via placeholder-based parameter assignments that
preserve the specified modification directions.
Level 3 (L3): Structural Extensions with Explicit Param-
eters
Task Definition. L3 focuses on the challenging scenario
where a model simultaneously accommodates structural
modifications s ‚àà‚Ñ¶s that extend the base OPF formulation
and explicit parameter modifications ‚àÜœÄ specified in P.
Structural extensions introduce additional controllable units
(e.g., unit commitment variables), operational constraints
(e.g., N-1 security constraints), or objective functions (e.g.,
environmental emission costs). For instance, the input ‚Äúen-
force N-1 security constraints with active loads at bus 7 in-
creased by 10%‚Äù requires introducing a structural extension
(security constraints) while explicitly specifying parameter
modifications (load adjustments).
Data Synthesis. For each sample z ‚ààL3, a model specifi-
cation ML3 is sampled uniformly from
‚Ñ¶L3
M := ‚Ñ¶sys √ó ‚Ñ¶œÄ √ó ‚Ñ¶s √ó ‚Ñ¶R,
(17)
Unlike L1 and L2, L3 employs a non-empty structural
modification space ‚Ñ¶s instead of {‚àÖ}. We construct ‚Ñ¶s
through expert curation of established OPF variants from
peer-reviewed literature and industry practices (see Ap-
pendix B for complete references), ensuring physical va-
lidity and engineering soundness. The space ‚Ñ¶s comprises
three orthogonal dimensions: decision variable extensions
Sp (7 variants), objective function extensions So (15 vari-
ants), and constraint extensions Sc (9 variants). Four do-
main experts provided design rationales and implementation
code for each variant. Complete specifications, including
names, mathematical formulations, and design rationales,
are provided in Appendix B.
For each sample, a structural modification s = (sp, so, sc)
is constructed by sampling sp ‚àºU(Sp) to establish the base
formulation, then sampling so ‚äÜSo and sc ‚äÜSc from their
power sets, subject to cardinality bounds |so| ‚â§Ko and
|sc| ‚â§Kc for computational tractability. This yields ‚Ñ¶s =
Sp √ó2So √ó2Sc, where 2So and 2Sc denote the power sets of
So and Sc, respectively. The remaining components (œâ, ‚àÜœÄ,
R) are sampled as in L1, and combined with s to form ML3.
Given ML3 and instructions œÑ L3, the LLM generates the
NL description P and executable implementation I:
(P, I) ‚àºpLLM
 ¬∑ | ML3, œÑ L3
,
(18)
where œÑ L3 extends œÑ L1 by incorporating the variant name,
the design rationale for generating P, and the implementa-
tion code I for each structural component in s.
Level 4 (L4): Structural Extensions with Semantic Pa-
rameters
Task Definition. L4 targets scenarios where models simul-
taneously infer parameter modifications ‚àÜœÄ from scenario-
level semantics and accommodate structural modifications
s ‚àà‚Ñ¶s that extend the base OPF formulation. For instance,
the input ‚Äúformulate an optimal transmission switching prob-
lem under heatwave conditions with elevated transmission
line thermal risk‚Äù requires inferring parameter modifications
(e.g., decreased thermal limits) from the scenario descrip-
tion while introducing structural extensions (e.g., optimal
transmission switching).
Data Synthesis. For each sample z ‚ààL4, a model specifi-
cation ML4 is sampled uniformly from
‚Ñ¶L4
M := ‚Ñ¶sys √ó ‚Ñ¶dir
œÄ √ó ‚Ñ¶s √ó ‚Ñ¶R,
(19)
combining the parameter space ‚Ñ¶dir
œÄ from L2 with the struc-
tural modification space ‚Ñ¶s from L3.
Structural modi-
fication s = (sp, so, sc) is constructed as in L3, with
relaxed cardinality bounds |so| ‚â§K‚Ä≤
o and |sc| ‚â§K‚Ä≤
c
where K‚Ä≤
o > Ko and K‚Ä≤
c > Kc. Parameter modifications
‚àÜœÄ ‚àà‚Ñ¶dir
œÄ are converted into scenario fragments {ck}K
k=1
via the scenario tree retrieval mechanism from L2, replacing
‚àÜœÄ in ML4 to form f
ML4. Given f
ML4 and instructions
œÑ L4, the LLM generates P and I:
(P, I) ‚àºpLLM

¬∑ | f
ML4, œÑ L4
,
(20)
6


--- Page 7 ---
Title Suppressed Due to Excessive Size
where œÑ L4 combines œÑ L2 (for scenario fragment aggrega-
tion) and œÑ L3 (for structural variant integration).
Data Cleaning and Text Refinement.
We post-process synthesized samples to enforce semantic
validity and improve linguistic diversity. We first apply
compatibility filtering using an expert-curated rule table
C to remove semantically invalid pairs of structural edits
and parameter patches, e.g., DCOPF omits reactive power
and voltage-magnitude constraints, so reactive-power or
voltage-bound updates are inapplicable. We discard z if
(s, ‚àÜœÄ) ‚ààC. Second, to reduce lexical redundancy among
samples with the same model specification M, we di-
versify the NL prompt Pi within each equivalence class
ZM = {zi | Mi = M} (when |ZM| > 1) via LLM-based
paraphrasing:
P‚Ä≤
i ‚àºpLLM(¬∑ | Pi, œÑ diversify) ,
‚àÄzi ‚ààZM,
(21)
where œÑ diversify enforces semantic equivalence while varying
surface form. The full cleaning and diversification pipeline
is given in Algorithm 5 (see Section C.5).
5. ProOPF-B: Benchmark for LLM
Performance on OPF Modeling Tasks
ProOPF-B is an expert-annotated benchmark for assess-
ing LLMs‚Äô OPF modeling capability across four difficulty
levels (Section 4.2). We recruited four power system ex-
perts to curate representative OPF modeling tasks from peer-
reviewed literature and to provide aligned reference imple-
mentations using a MATPOWER-based toolchain. ProOPF-
B comprises 121 test cases spanning all levels (Level 1: 36;
Level 2: 30; Level 3: 29; Level 4: 26) and is evaluated via
two end-to-end pipelines, distinguished by whether P speci-
fies concrete parameter instantiations: concrete OPF model-
ing (Levels 1/3) and abstract OPF modeling (Levels 2/4),
as illustrated in Figure 5. All benchmark instances were au-
dited to ensure no overlap with ProOPF-D. See Appendix E
for representative examples and evaluation prompts.
Concrete OPF Modeling Evaluation (Levels 1/3). For
Levels 1 and 3, each test sample z in ProOPF-B consists of
three components:
z = {P, I, f ‚àó}
(22)
where f ‚àódenotes the optimal objective value obtained by
executing I via the MATLAB engine. During evaluation,
the LLM receives P and generates an implementation bI,
which is executed to obtain c
f ‚àó. A test case is considered
correct if and only if |c
f ‚àó‚àíf ‚àó| ‚â§œµ for a tolerance threshold
œµ > 0 (a small positive number). The complete evaluation
workflow is formalized in Algorithm 6.
Abstract OPF Modeling Evaluation (Levels 2/4). For
Levels 2 and 4, each test sample z in ProOPF-B consists of
four components:
z = {P, I, œÄ, f ‚àó(œÄ)}
(23)
where œÄ denotes a predefined parameter instantiation consis-
tent with the modification trends inferred from P, and f ‚àó(œÄ)
denotes the optimal objective value obtained by executing
I with œÄ as input. For evaluation, the LLM receives only
P and generates an implementation bI, which is executed
with œÄ to obtain c
f ‚àó(œÄ). A test case is considered correct if
and only if |c
f ‚àó(œÄ) ‚àíf ‚àó(œÄ)| ‚â§œµ. The complete evaluation
workflow is formalized in Algorithm 7.
6. Experiment and Analysis
6.1. Baselines and Settings
Baselines and Evaluation Setting. We evaluate models on
ProOPF-B across four difficulty levels using objective value
accuracy computed from the generated implementations,
as detailed in section 5 and Appendix F. As baselines, we
consider the GPT-family (Achiam et al., 2023), Claude-
family (Anthropic, 2024), DeepSeek-family (Liu et al.,
2024), and Qwen3-family (Yang et al., 2025a) models in
both zero-shot and few-shot settings. For the supervised
fine-tuning (SFT) setting, we use Qwen3-30B-A3B as the
pre-trained model and finetune it on ProOPF-D.
Fine-tuning Setting.
We fine-tuned Qwen3-30B-A3B-
Instruct on ProOPF-D via the VERL framework (Sheng
et al., 2025) using 8 √ó A100 (80GB) GPUs. The training
employs a learning rate of 1 √ó 10‚àí4, a global batch size of
8, and a maximum sequence length of 8192 tokens.
6.2. Baslines Evaluation on ProOPF-B
Table 1 presents the performance of six state-of-the-art
LLMs on ProOPF-B under few-shot and zero-shot settings.
From Explicit to Semantic. Model performance exhibits
a sharp negative correlation with task abstraction.
As
shown in Table 1, leading models like Gemini 3.0 Pro and
DeepSeek V3.2 demonstrate strong proficiency in explicit
parametric modifications, achieving 94.44% accuracy on
Level 1. However, the introduction of semantic ambiguity in
Level 2 triggers a catastrophic collapse, with accuracy rates
plummeting near zero. Crucially, cause the compounding
complexity of structural modifications coupled with seman-
tic parameter inference renders the task intractable for Level
4, all models result in 0.00% success rate.
From Few-shot to Zero-shot.
The dependency on in-
context learning is highly uneven across task types for cur-
rent models. For Level 1, all models experience perfor-
mance declines ranging from 5% to 18%. More critically,
the removal of few-shot examples triggers a collapse in
structural modification capabilities, with relative accuracy
7


--- Page 8 ---
Title Suppressed Due to Excessive Size
Table 1. Model Performance(%) on Four Levels in ProOPF-B
Setting
Model
Concrete Modeling
Abstract Modeling
Average
Level 1
Level 3
Level 2
Level 4
Few-shot
GPT-5.2
33.33
10.34
6.67
0.00
14.05
Claude 4.5 Sonnet
77.78
37.93
6.67
0.00
33.88
DeepSeek V3.2
94.44
6.90
0.00
0.00
29.75
Gemini 3.0 Pro
94.44
31.03
6.67
0.00
37.19
Qwen3-Coder
80.56
0.00
0.00
0.00
23.97
Qwen3-30B-A3B
50.00
0.00
0.00
0.00
14.88
Zero-shot
GPT-5.2
25.00
5.56
6.67
0.00
10.42
Claude 4.5 Sonnet
66.67
5.56
6.67
0.00
22.82
DeepSeek V3.2
88.89
0.00
0.00
0.00
26.45
Gemini 3.0 Pro
77.78
13.89
0.00
0.00
26.47
Qwen3-Coder
13.89
5.56
0.00
0.00
5.46
Qwen3-30B-A3B
0.00
0.00
0.00
0.00
0.00
SFT
(ProOPF-D)
Qwen3-30B-A3B
(few-shot)
75.00
20.70
33.30
11.54
35.53
Qwen3-30B-A3B
(zero-shot)
63.90
10.30
23.30
7.69
27.26
Semantic Param
Explicit Param
Structural Mod
Exec Rate
Resolutoin Spec
Exec Correct
13.8%
66.2%
72.3%
48.8%
95.4%
60.0%
Figure 4. Six-Dimensional Capability Radar Chart.
Each axis represents a fundamental competency in
OPF modeling (see Appendix G for detailed defini-
tions). All values are expressed as percentages.
plummeting by 50% to over 85% across leading baselines,
indicating that current models depend heavily on in-context
scaffolding to navigate topological constraints.
Diagnostic Failure Analysis. Here we decompose capabil-
ity limitations using the six-dimensional framework, isolat-
ing distinct failure modes:
1. The Implementation Gap: Most models exhibit a strong
conceptual understanding of structural changes, achiev-
ing Structural Modification Identification scores be-
tween 60%‚Äì72%. However, it fails to translate this
into working code. It indicates that the bottleneck lies
not in recognizing what to change, but in a deficiency
of specific resolution specification and API knowledge
required to implement these changes without errors.
2. The Non-Executable Expert: A distinct pathology is
observed in models like GPT-5.2, characterized by a
high Executable Correctness Rate with a critically low
Executable Rate. It implies that the model generates
logically sound OPF formulations that are rendered
useless by trivial syntax errors or invalid solver config-
urations, highlighting a fragility in basic coding profi-
ciency despite high-level domain logic.
3. The Semantic Barrier: The universal failure on Levels
2 and 4 is directly attributable to deficits in Seman-
tic Parameter Inference, where scores hover near zero
across all baselines. Unlike structural tasks where fail-
ure occurs at the implementation stage, here the failure
is foundational: models are unable to map qualitative
descriptors (e.g., ‚Äúheavy load‚Äù) to quantitative domain
standards without explicit numerical grounding.
6.3. Supervised Fine-tuning on ProOPF-D
To further validate the effectiveness of ProOPF-D, we fine-
tune Qwen3-30B-A3B using the dataset. As shown in Ta-
ble 1, SFT yields substantial improvement. The most pro-
found improvement occurs at Level 2, where few-shot accu-
racy surges from 0.00% to 33.30%. Notably, on Level-4,
the most challenging setting that combines semantic in-
ference with structural reformulation which is completely
unsolved by all baseline models, the fine-tuned model at-
tains 11.54% accuracy. Under zero-shot evaluation, the
fine-tuned model also achieves at least a 7.69% gain across
all four levels, indicating that ProOPF-D provides effective,
structure-preserving supervision in OPF tasks.
7. Conclusion and Future Work
We introduce ProOPF-D and ProOPF-B, the first dataset
and benchmark for evaluating LLMs on professional-grade
OPF modeling. ProOPF-D contains 12K instances across
four difficulty levels, covering parametric updates and struc-
tural extensions of a canonical OPF. ProOPF-B provides
121 expert-annotated test cases for end-to-end evaluation.
Results show that while LLMs handle explicit parameter
modifications, they struggle with semantic parameter infer-
ence and structural modeling, motivating future work on
domain-aware training and supervision.
Impact Statement
This paper presents work whose goal is to advance the field
of Machine Learning. There are many potential societal
consequences of our work, none which we feel must be
specifically highlighted here.
8


--- Page 9 ---
Title Suppressed Due to Excessive Size
References
Abdi, H., Beigvand, S. D., and La Scala, M. A review of
optimal power flow studies applied to smart grids and
microgrids. Renewable and Sustainable Energy Reviews,
71:742‚Äì766, 2017.
Achiam, J., Adler, S., Agarwal, S., Ahmad, L., Akkaya, I.,
Aleman, F. L., Almeida, D., Altenschmidt, J., Altman, S.,
Anadkat, S., et al. Gpt-4 technical report. arXiv preprint
arXiv:2303.08774, 2023.
AhmadiTeshnizi, A., Gao, W., and Udell, M. Optimus: Op-
timization modeling using mip solvers and large language
models. arXiv preprint arXiv:2310.06116, 2023.
Anthropic. Claude. https://claude.ai, 2024. Large
Language Model.
Bai, J., Bai, S., Chu, Y., Cui, Z., Dang, K., Deng, X., Fan,
Y., Ge, W., Han, Y., Huang, F., et al. Qwen technical
report. arXiv preprint arXiv:2309.16609, 2023.
Biagioni, D., Graf, P., Zhang, X., Zamzam, A. S., Baker, K.,
and King, J. Learning-accelerated admm for distributed
dc optimal power flow. IEEE Control Systems Letters, 6:
1‚Äì6, 2020.
Carpentier, J. Contribution to the economic dispatch prob-
lem. Bulletin de la Societe Francoise des Electriciens, 3
(8):431‚Äì447, 1962.
Huang, C., Tang, Z., Hu, S., Jiang, R., Zheng, X., Ge, D.,
Wang, B., and Wang, Z. Orlm: A customizable frame-
work in training large models for automated optimization
modeling. Operations Research, 2025.
Huang, X., Shen, Q., Hu, Y., Gao, A., and Wang, B. Mamo:
a mathematical modeling benchmark with solvers. arXiv
e-prints, pp. arXiv‚Äì2405, 2024.
Jia, M., Cui, Z., and Hug, G. Enhancing llms for power sys-
tem simulations: A feedback-driven multi-agent frame-
work. IEEE Transactions on Smart Grid, 2025.
Jiang, C., Shu, X., Qian, H., Lu, X., Zhou, J., Zhou, A.,
and Yu, Y. Llmopt: Learning to define and solve gen-
eral optimization problems from scratch. The Thirteenth
International Conference on Learning Representations,
2025.
Langley, P. Crafting papers on machine learning. In Langley,
P. (ed.), Proceedings of the 17th International Conference
on Machine Learning (ICML 2000), pp. 1207‚Äì1216, Stan-
ford, CA, 2000. Morgan Kaufmann.
Li, S., Kulkarni, J., Menache, I., Wu, C., and Li, B. Towards
foundation models for mixed integer linear programming.
arXiv preprint arXiv:2410.08288, 2024.
Liu, A., Feng, B., Xue, B., Wang, B., Wu, B., Lu, C., Zhao,
C., Deng, C., Zhang, C., Ruan, C., et al. Deepseek-v3
technical report. arXiv preprint arXiv:2412.19437, 2024.
Pan, X., Zhao, T., Chen, M., and Zhang, S. Deepopf: A
deep neural network approach for security-constrained
dc optimal power flow. IEEE Transactions on Power
Systems, 36(3):1725‚Äì1735, 2020.
Ramamonjison, R., Yu, T., Li, R., Li, H., Carenini, G., Ghad-
dar, B., He, S., Mostajabdaveh, M., Banitalebi-Dehkordi,
A., Zhou, Z., et al. Nl4opt competition: Formulating
optimization problems based on their natural language
descriptions. In NeurIPS 2022 competition track, pp.
189‚Äì203. PMLR, 2023.
Rivera, A. K., Bhagavathula, A., Carbonero, A., and Donti,
P. PfŒ¥: A benchmark dataset for power flow under load,
generation, and topology variations, 2026. URL https:
//arxiv.org/abs/2510.22048.
Schecter, A. and O‚ÄôNeill, R. Exploration of the acopf fea-
sible region for the standard ieee test set. FERC staff
technical paper, 2013.
Shen, C., Zuo, K., and Sun, M. Physics-following neural
network for online dynamic security assessment. IEEE
Transactions on Power Systems, 2025.
Sheng, G., Zhang, C., Ye, Z., Wu, X., Zhang, W., Zhang, R.,
Peng, Y., Lin, H., and Wu, C. HybridFlow: A Flexible
and Efficient RLHF Framework. In Proceedings of the
Twentieth European Conference on Computer Systems,
pp. 1279‚Äì1297, March 2025. doi: 10.1145/3689031.
3696075.
Wan, X., Sun, M., Chen, B., Chu, Z., and Teng, F. Adapsafe:
Adaptive and safe-certified deep reinforcement learning-
based frequency control for carbon-neutral power sys-
tems. In Proceedings of the AAAI Conference on Artificial
Intelligence, volume 37, pp. 5294‚Äì5302, 2023.
Wang, Z., Younesi, A., Liu, M. V., Guo, G. C., and
Anderson, C. L.
AC Optimal Power Flow in Power
Systems With Renewable Energy Integration: A Re-
view of Formulations and Case Studies.
IEEE Ac-
cess, 11:102681‚Äì102712, 2023. ISSN 2169-3536. doi:
10.1109/ACCESS.2023.3314330.
Wu, Y., Zhang, Y., Wu, Y., Wang, Y., Zhang, J., and Cheng,
J. Evo-step: Evolutionary generation and stepwise vali-
dation for optimizing llms in or. openreview.net, 2024.
Xiao, Z., Zhang, D., Wu, Y., Xu, L., Wang, Y. J., Han, X.,
Fu, X., Zhong, T., Zeng, J., Song, M., et al. Chain-of-
experts: When llms meet complex operations research
problems. In The twelfth international conference on
learning representations, 2023.
9


--- Page 10 ---
Title Suppressed Due to Excessive Size
Xiao, Z., Xie, J., Xu, L., Guan, S., Zhu, J., Han, X., Fu,
X., Yu, W., Wu, H., Shi, W., et al. A survey of optimiza-
tion modeling meets llms: progress and future directions.
In Proceedings of the Thirty-Fourth International Joint
Conference on Artificial Intelligence, pp. 10742‚Äì10750,
2025.
Xu, Z.
118-bus, 300-bus and 3266-bus system data,
2025.
URL https://dx.doi.org/10.21227/
vma9-wk20.
Yang, A., Li, A., Yang, B., Zhang, B., Hui, B., Zheng,
B., Yu, B., Gao, C., Huang, C., Lv, C., Zheng, C., Liu,
D., Zhou, F., Huang, F., Hu, F., Ge, H., Wei, H., Lin,
H., Tang, J., Yang, J., Tu, J., Zhang, J., Yang, J., Yang,
J., Zhou, J., Zhou, J., Lin, J., Dang, K., Bao, K., Yang,
K., Yu, L., Deng, L., Li, M., Xue, M., Li, M., Zhang,
P., Wang, P., Zhu, Q., Men, R., Gao, R., Liu, S., Luo,
S., Li, T., Tang, T., Yin, W., Ren, X., Wang, X., Zhang,
X., Ren, X., Fan, Y., Su, Y., Zhang, Y., Zhang, Y., Wan,
Y., Liu, Y., Wang, Z., Cui, Z., Zhang, Z., Zhou, Z., and
Qiu, Z. Qwen3 technical report, 2025a. URL https:
//arxiv.org/abs/2505.09388.
Yang, Z., Wang, Y., Huang, Y., Guo, Z., Shi, W., Han, X.,
Feng, L., Song, L., Liang, X., and Tang, J. Optibench
meets resocratic: Measure and improve llms for optimiza-
tion modeling. In ICLR, 2025b.
Zimmerman, R. D., Murillo-S¬¥anchez, C. E., and Thomas,
R. J. Matpower: Steady-state operations, planning, and
analysis tools for power systems research and education.
IEEE Transactions on power systems, 26(1):12‚Äì19, 2010.
Zuo, K., Shen, C., Cheng, P., Song, J., and Sun, M. Proba-
bilistic robustness verified data-driven transient security-
constrained optimal power flow. IEEE Transactions on
Power Systems, 2025.
10


--- Page 11 ---
Title Suppressed Due to Excessive Size
A. Details of Model Specification in ProOPF-D
A.1. Base System Pool ‚Ñ¶sys
The base system pool ‚Ñ¶sys comprises 63 base power systems that serve as reference configurations for synthesizing ProOPF-
D samples. These systems are curated from three primary sources: (1) the MATPOWER test case library (Zimmerman
et al., 2010), which provides standardized power system models widely used in research and education; (2) IEEE PES Test
Feeder Archive (IEEE Dataport) (Xu, 2025), which hosts peer-reviewed test systems representing diverse network topologies
and operating characteristics; and (3) academic publications in power systems journals and conferences, which document
real-world system configurations and benchmark problems. Each system œâ ‚àà‚Ñ¶sys is associated with base parameters
œÄsys(œâ) encoding network topology, generator cost coefficients, branch impedances, load profiles, and operational limits.
The systems span a wide range of scales, from small-scale test networks (e.g., 9-bus systems) to large-scale transmission
networks (e.g., 300+ bus systems), enabling comprehensive evaluation across varying problem complexities.
A summary of the base system pool, including network topology statistics and system descriptions, is provided in Table 2.
For each system, the table reports the number of buses |N|, branches |E|, and generators |G|, along with brief descriptions
of system characteristics and source information.
Table 2: Base system pool ‚Ñ¶sys summary statistics.
System Name œâ
|N|
|E|
|G|
Description
case4 dist
4
3
2
4-bus example radial distribution system case
case4gs
4
4
2
4-bus example case from Grainger & Stevenson
case5
5
6
5
modified 5-bus PJM example case from Rui Bo
case6ww
6
11
3
6-bus example case from Wood & Wollenberg
case9
9
9
3
9-bus example case from Chow
case10ba
10
9
1
10-bus radial distribution system from Baghzouz and Ertem
case12da
12
11
1
12-bus radial distribution system from Das, Nagi, and Kothari
case14
14
20
5
IEEE 14-bus case
case15da
15
14
1
15-bus radial distribution system from Das, Kothari, and Kalam
case15nbr
15
14
1
15-bus radial distribution system from Battu, Abhyankar, Senroy
case16am
15
14
1
16-bus radial distribution system from Das, Kothari, and Kalam
case16ci
16
16
3
16-bus distribution system from Civanlar, Grainger, Yin, and Lee
case17me
17
16
1
17-bus radial distribution system from Mendoza, Morales, Lopez, et. al.
case18
18
17
1
18-bus radial distribution system from Grady, Samotyj and Noyola
case18nbr
18
17
1
18-bus radial distribution system from Battu, Abhyankar, Senroy
case22
22
21
1
22-bus radial distribution system from Raju, Murthy and Ravindra
case24 ieee rts
24
38
33
IEEE RTS 24-bus case
case28da
28
27
1
28-bus radial distribution system from Das, Nagi, and Kothari
case30
30
41
6
30-bus case, based on IEEE 30-bus case
case ieee30
30
41
6
IEEE 30-bus case
case33bw
33
37
1
33-bus radial distribution system from Baran and Wu
case33mg
33
37
1
33-bus radial distribution system from Kashem, Ganapathy, Jasmon and
Buhari
case34sa
34
33
1
34-bus radial distribution system from Salama and Chikhani
case38si
38
37
1
38-bus radial distribution system from Singh and Misra
case39
39
46
10
39-bus New England case
case51ga
51
50
1
51-bus radial distribution system from Gampa and Das
case51he
51
50
1
51-bus radial distribution system from Hengsritawat, Tayjasanant and
Nimpitiwan
case57
57
80
7
IEEE 57-bus case
case69
69
68
1
69-bus radial distribution system from Baran and Wu
case70da
70
76
2
70-bus distribution system from Das
case RTS GMLC
73
120
158
96-machine, 73-bus Reliability Test System
case74ds
74
73
1
74-bus radial distribution system from Myint and Naing
case85
85
84
1
85-bus radial distribution system from Das, Kothari and Kalam
case89pegase
89
210
12
89-bus portion of European transmission system from PEGASE project
case94pi
94
93
1
94-bus radial distribution system from Pires, Antunes and Martins
case118
118
186
54
IEEE 118-bus case
case118zh
118
132
1
118-bus radial distribution system from Zhang, Fu and Zhang
case136ma
136
156
1
136-bus radial distribution system from Mantovani, Casari and Romero
Continued on next page
11


--- Page 12 ---
Title Suppressed Due to Excessive Size
Table 2 ‚Äì continued from previous page
System Name
|N|
|E|
|G|
Description
case141
141
140
1
141-bus radial distribution system from Khodr, Olsina, De Jesus and
Yusta
case145
145
453
50
IEEE 145-bus case, 50 generator dynamic test case
case ACTIVSg200
200
245
49
200-bus Illinois synthetic model
case300
300
411
69
IEEE 300-bus case
case ACTIVSg500
500
597
90
500-bus South Carolina synthetic model
case1354pegase
1354
1991
260
1354-bus portion of European transmission system from PEGASE
project
case1888rte
1888
2531
298
1888-bus snapshot of VHV French transmission system from RTE
case1951rte
1951
2596
392
1951-bus snapshot of VHV French transmission system from RTE
case ACTIVSg2000
2000
3206
544
2000-bus Texas synthetic model
case2383wp
2383
2896
327
Polish system - winter 1999-2000 peak
case2736sp
2736
3504
420
Polish system - summer 2004 peak
case2737sop
2737
3506
399
Polish system - summer 2004 off-peak
case2746wop
2746
3514
514
Polish system - winter 2003-04 off-peak
case2746wp
2746
3514
520
Polish system - winter 2003-04 evening peak
case2848rte
2848
3776
548
2848-bus snapshot of VHV French transmission system from RTE
case2868rte
2868
3808
600
2868-bus snapshot of VHV French transmission system from RTE
case2869pegase
2869
4582
510
2869-bus portion of European transmission system from PEGASE
project
case3012wp
3012
3572
502
Polish system - winter 2007-08 evening peak
case3120sp
3120
3693
505
Polish system - summer 2008 morning peak
case3375wp
3374
4161
596
Polish system plus - winter 2007-08 evening peak
case6468rte
6468
9000
1296
6468-bus snapshot of VHV and HV French transmission system from
RTE
case6470rte
6470
9005
1331
6470-bus snapshot of VHV and HV French transmission system from
RTE
case6495rte
6495
9019
1373
6495-bus snapshot of VHV and HV French transmission system from
RTE
case6515rte
6515
9037
1389
6515-bus snapshot of VHV and HV French transmission system from
RTE
case9241pegase
9241
16049
1445
9241-bus portion of European transmission system from PEGASE
project
A.2. Parametric Modifications ‚àÜœÄ
Parametric modifications ‚àÜœÄ are organized as a finite set of parameter patches {Œ¥k}K
k=1, where each patch Œ¥k encodes a
single parameter modification operation. Each patch Œ¥k is a structured tuple that specifies which component parameter
is being modified, how it is modified, and the modification value or direction. The patch structure enables compact
representation of multiple parameter changes while preserving the relationship between components, their parameters, and
modification semantics.
Each parameter patch Œ¥k contains several key attributes that collectively define a parameter modification. The component
attribute identifies the power system component type (bus, generator, or branch) to which the modification applies. For
bus and generator components, the bus id attribute specifies the target bus identifier. For branch components, the fbus
and tbus attributes specify the from-bus and to-bus identifiers, respectively. The target parameter attribute identifies the
specific parameter being modified (e.g., active power demand, generator capacity limit, branch reactance). The modification
operation is specified through either an operation attribute (for Level 1 samples with explicit values) or a direction
attribute (for Level 2 samples with semantic constraints). When an explicit operation is used, the value attribute provides
the numerical modification value. Common operations include Scale (multiplicative scaling) and Set (absolute value
assignment), while common directions include Increase, Decrease, and Set zero.
The complete specification of patch attributes, their data types, allowed values, and usage examples are provided in Table 3.
Complete sample examples demonstrating parameter patch usage across all difficulty levels are provided in Appendix D.
This structured representation enables systematic sampling of parameter modifications while ensuring physical consistency
and semantic validity across different difficulty levels.
12


--- Page 13 ---
Title Suppressed Due to Excessive Size
Table 3: Parameter patch Œ¥k attribute specifications.
Attribute
Description
Example
component
Component type identifier
"bus", "gen", "branch"
bus id
Bus identifier (for bus/gen components)
1 (bus 1), 32 (bus 32)
fbus
From-bus identifier (for branch components)
2 (from bus 2)
tbus
To-bus identifier (for branch components)
25 (to bus 25)
target parameter
Parameter identifier being modified
"PD" (active power demand), "PMAX" (max
generator output), "BR X" (branch reactance),
"VMIN" (min voltage)
operation
Modification operation type (Level 1& 3)
"Scale" (multiplicative), "Set" (absolute)
direction
Modification direction constraint (Level 2&4)
"Increase", "Decrease", "Set zero"
value
Numerical modification value (Level 1&3)
1.5 (scale factor), 500 (absolute value in MW)
A.3. Structural Modifications s
Structural modifications s are organized as a triple s = {sp, sc, so} that encodes modifications to the problem formulation
structure. Each component corresponds to a specific aspect of structural variation: sp specifies the problem type (decision
variable extensions), sc specifies constraint extensions, and so specifies objective function modifications.
The problem component sp corresponds to decision variable extensions that fundamentally alter the problem structure by
introducing new decision variables or reformulating the problem formulation. Common problem types include "ACOPF"
(canonical AC optimal power flow), "DCOPF" (DC approximation), "ED" (economic dispatch), "UC" (unit commitment),
and "OTS" (optimal transmission switching). The problem type establishes the base formulation structure, upon which
objective and constraint extensions can be applied.
The objective modification component so encodes modifications to the objective function. Each objective modification
is a structured object containing fields such as op (operation type, e.g., "add" to add a new term), name (identifier for
the modification, e.g., "angle difference penalty"), form (mathematical formulation), and additional parameters
(e.g., beta for penalty coefficients). Multiple objective modifications can be combined to form composite objective
functions.
The constraint modification component sc specifies constraint extensions that add new constraints to the base problem
formulation. Similar to objective modifications, constraint modifications are structured objects containing fields such as
op (operation type), name (constraint identifier, e.g., "N-1 security"), form (constraint formulation), and associated
parameters. Constraint modifications enable the incorporation of operational requirements such as security constraints,
voltage stability limits, and renewable integration constraints.
The complete specification of structural modification components, their fields, data types, and usage examples are provided
in Table 4. Complete sample examples demonstrating structural modification usage across all difficulty levels are provided
in Appendix D. The complete catalog of available structural variants in the seed set Sseed is detailed in Appendix B.
Table 4: Structural modification s component and field specifications.
Component/Field
Description
Example
problem (sp)
Problem type identifier
"ACOPF", "DCOPF", "ED", "UC", "OTS"
objective modification
(so)
Objective function modification object
{"op":
"add", "name":
"angle difference penalty", ...}
op
Operation type for objective modifica-
tion
"add" (add new term), "replace" (replace
objective)
name
Identifier for the objective modification
"angle difference penalty",
"renewable curtailment"
Continued on next page
13


--- Page 14 ---
Title Suppressed Due to Excessive Size
Table 4 ‚Äì continued from previous page
Component/Field
Description
Example
form
Mathematical formulation of the objec-
tive term
"beta * ||E*Va|| 2ÀÜ2"
beta
Penalty coefficient parameter
10 (penalty coefficient)
constraint modification
(sc)
Constraint extension object
{"op":
"add", "name":
"N-1 security", ...}
op
Operation type for constraint modifica-
tion
"add" (add new constraint)
name
Identifier for the constraint modification
"N-1 security",
"voltage stability"
form
Mathematical formulation of the con-
straint
"L i(V,theta) <= LÀÜmax"
A.4. Resolution Specification R
The resolution specification R encodes solver configuration parameters that control how the OPF model is solved and how results are
reported. The specification contains three main categories of parameters: solver selection, convergence criteria, and output configuration.
Complete specifications of resolution parameters, their descriptions, and usage examples are provided in Table 5. Complete sample
examples demonstrating resolution specification usage across all difficulty levels are provided in Appendix D.
Table 5. Resolution specification R parameter categories and field specifications.
Category/Field
Description
Example
solver
Optimization solver identifier
"MIPS", "IPOPT", "KNITRO"
opf violation
Maximum acceptable constraint violation
tolerance (convergence criterion)
1e-8 (tight tolerance), 1e-6 (loose tolerance)
output
Output configuration specifying precision
and verbosity
Numerical precision settings, verbosity levels
14


--- Page 15 ---
Title Suppressed Due to Excessive Size
B. Seed Set of OPF Structural Variants
This appendix presents the curated seed set Sseed of OPF structural variants used for synthesizing Level 3 and Level 4 data in ProOPF-D.
The seed set defines the structural modification space for generating OPF problem variants beyond the canonical AC-OPF formulation.
The variants included in Sseed are drawn from established formulations reported in peer-reviewed power systems literature and operational
practices adopted in industry. Each variant represents a well-documented extension or reformulation that addresses specific operational
requirements, computational constraints, or modeling objectives encountered in real-world power system planning and operation. Detailed
references for each variant, including corresponding academic publications and industrial case studies, are provided in the supplementary
material: OPF variants reference list.
The structural modification space is organized into three orthogonal dimensions: decision variable extensions Sp (8 variants including the
base AC-OPF formulation), objective function extensions SO (15 variants), and constraint extensions Sc (9 variants). Decision variable
extensions define the fundamental problem formulation, encompassing variants that introduce new decision variables or reformulate
the problem structure (e.g., economic dispatch, DCOPF, unit commitment, optimal transmission switching). These variants often
correspond to distinct power system optimization problems that share structural similarities with OPF. Objective function extensions and
constraint extensions represent modular components that can be combined to extend a base problem formulation. The complete structural
modification space is given by the Cartesian product Sp √ó 2SO √ó 2Sc, where 2SO and 2Sc denote the power sets (allowing combinations
of multiple extensions) of objective function and constraint extensions, respectively.
As described in subsection 4.2, each Level 3 or Level 4 sample is constructed by first sampling a decision variable extension sp ‚àºU(Sp)
to establish the base problem formulation, then sampling compatible objective function and constraint extensions from SO and Sc
(potentially as combinations), and finally combining the resulting structural modification s with parameter modifications ‚àÜœÄ sampled
from ‚Ñ¶œÄ.
B.1. Decision Variable Extensions Sp
This category comprises 8 problem formulations, including the canonical AC-OPF (ID 1) as the base formulation studied in this work,
along with 7 structural variants that define alternative problem formulations by introducing new decision variables or reformulating
the problem structure. These variants capture distinct power system optimization problems that share structural similarities with OPF,
including economic dispatch that neglects network constraints, DC approximation for computational tractability, temporal coupling
through multi-period optimization and unit commitment, topology control via transmission switching, and load curtailment for feasibility
recovery. Each variant sp ‚ààSp establishes the base problem structure, upon which objective function and constraint extensions can be
applied. Table 6 present the complete problem formulation and key features for each formulation.
Table 6: Decision variable variants in OPF problems.
ID
Problem Type
Formulation
Descriptions
1
AC OPF
min
Pg,Qg,V,Œ∏
X
g‚ààG
Cg(Pg)
subject to:
Pg ‚àíPd = P
k ViVkYik cos(Œ∏i ‚àíŒ∏k ‚àíŒ±ik),
‚àÄi
Qg ‚àíQd = P
k ViVkYik sin(Œ∏i ‚àíŒ∏k ‚àíŒ±ik),
‚àÄi
P min
g
‚â§Pg ‚â§P max
g
,
Qmin
g
‚â§Qg ‚â§Qmax
g
,
‚àÄg
V min ‚â§V ‚â§V max,
|Sik| ‚â§Smax
ik
,
‚àÄi, k
Canonical OPF formulation studied in
this work; optimizes generator
dispatch (Pg, Qg) and bus voltages
(V, Œ∏) subject to nonlinear AC power
flow equations and operational limits;
serves as the base problem
formulation upon which objective
function and constraint extensions are
applied
2
DC OPF
min
Pg,Œ∏
X
g‚ààG
Cg(Pg)
subject to:
P
g‚ààGi Pg ‚àíPd,i = P
k‚ààNi Bik(Œ∏i ‚àíŒ∏k),
‚àÄi ‚ààN
|Bik(Œ∏i ‚àíŒ∏k)| ‚â§F max
ik
,
‚àÄ(i, k) ‚ààL
P min
g
‚â§Pg ‚â§P max
g
,
‚àÄg
Œ∏ref = 0
Simplifies AC-OPF by eliminating
voltage magnitude and reactive power
variables; linearizes power flow using
small-angle approximation; widely
used in large-scale system operations,
market clearing, and real-time
dispatch due to computational
efficiency
Continued on next page
15


--- Page 16 ---
Title Suppressed Due to Excessive Size
Table 6 ‚Äì continued from previous page
ID
Problem Type
Formulation
Descriptions
3
Multi-period OPF
min
Pg,Qg,V,Œ∏
T
X
t=1
X
g‚ààG
Cg(Pgt)
subject to:
Pgt ‚àíPdt = P
k VitVktYik cos(Œ∏it ‚àíŒ∏kt ‚àíŒ±ik),
‚àÄi, t
Qgt ‚àíQdt = P
k VitVktYik sin(Œ∏it ‚àíŒ∏kt ‚àíŒ±ik),
‚àÄi, t
P min
g
‚â§Pgt ‚â§P max
g
,
Qmin
g
‚â§Qgt ‚â§Qmax
g
,
‚àÄg, t
V min ‚â§Vit ‚â§V max,
|Sikt| ‚â§Smax
ik
,
‚àÄi, k, t
Pgt ‚àíPg,t‚àí1 ‚â§Rup
g ,
Pg,t‚àí1 ‚àíPgt ‚â§Rdn
g ,
‚àÄg, t ‚â•2
Extends single-period OPF over
planning horizon T by coupling
consecutive periods via generator
ramping constraints; optimizes
generation schedule considering
temporal variations in load and
renewable generation; units remain
committed throughout horizon
4
Security-
constrained
unit commitment
min
u,Pg,Qg,V,Œ∏
T
X
t=1
X
g‚ààG
[Cg(Pgt)ugt + SCg(ugt, ug,t‚àí1)]
where SCg = Sup
g (1 ‚àíug,t‚àí1)ugt + Sdn
g ug,t‚àí1(1 ‚àíugt)
subject to:
AC power flow equations ‚àÄt
ugtP min
g
‚â§
Pgt
‚â§
ugtP max
g
,
ugtQmin
g
‚â§
Qgt
‚â§
ugtQmax
g
,
‚àÄg, t
V min ‚â§Vit ‚â§V max,
|Sikt| ‚â§Smax
ik
,
‚àÄi, k, t
Pgt‚àíPg,t‚àí1 ‚â§Rup
g ugt,
Pg,t‚àí1‚àíPgt ‚â§Rdn
g ug,t‚àí1,
‚àÄg, t
Pt
œÑ=t‚àíT up
g +1(1‚àíugœÑ) = 0,
Pt
œÑ=t‚àíT dn
g +1 ugœÑ = 0,
‚àÄg, t
ugt ‚àà{0, 1},
‚àÄg, t
Integrates unit commitment with
multi-period dispatch optimization;
determines optimal on/off schedule
and power output for each generator
over time horizon; enforces
inter-temporal constraints including
minimum up/down times and
startup-dependent ramping limits
5
Economic
dis-
patch
min
Pg
X
g‚ààG
Cg(Pg)
subject to:
P
g‚ààG Pg = P
d‚ààD Pd
P min
g
‚â§Pg ‚â§P max
g
,
‚àÄg
Simplest formulation that determines
generator active power outputs to
satisfy total demand at minimum cost;
neglects network topology, power flow
constraints, and reactive power;
provides fast dispatch decisions
assuming transmission capacity is
sufficient; serves as initial solution for
more detailed OPF models
6
Optimal transmis-
sion switching
min
Pg,Œ∏,z
X
g‚ààG
Cg(Pg)
subject to:
Pg ‚àíPd = P
k Bikzik(Œ∏i ‚àíŒ∏k),
‚àÄi
‚àízikP max
ik
‚â§Bik(Œ∏i ‚àíŒ∏k) ‚â§zikP max
ik
,
‚àÄ(i, k) ‚ààL
P min
g
‚â§Pg ‚â§P max
g
,
‚àÄg
zik ‚àà{0, 1},
‚àÄ(i, k) ‚ààL
Introduces binary variables for line
switching status to enable network
topology control; uses DC power flow
approximation (linearized) for
computational tractability; allows
strategic line outages to relieve
congestion and reduce generation cost;
results in mixed-integer linear
program (MILP)
7
Load shedding
min
Pg,Qg,V,Œ∏,Lshed
X
g‚ààG
Cg(Pg) +
X
d‚ààD
WdLshed
d
subject to:
Pg ‚àíPd + Lshed
d
= P
k ViVkYik cos(Œ∏i ‚àíŒ∏k ‚àíŒ±ik),
‚àÄi
Qg ‚àíQd = P
k ViVkYik sin(Œ∏i ‚àíŒ∏k ‚àíŒ±ik),
‚àÄi
P min
g
‚â§Pg ‚â§P max
g
,
Qmin
g
‚â§Qg ‚â§Qmax
g
,
V min ‚â§
V ‚â§V max
0 ‚â§Lshed
d
‚â§Ld,
‚àÄd
Introduces continuous load shedding
variables Lshed
d
to ensure problem
feasibility when generation capacity is
insufficient or network constraints are
too restrictive; assigns high penalty
cost Wd to represent severe economic
and social impact of unserved energy
B.2. Objective Function Extensions SO
This category comprises 15 structural variants that modify or extend the objective function of the base problem formulation. These
extensions reflect diverse operational goals encountered in modern power system operation, including economic dispatch with multiple
cost components, multi-objective optimization balancing economic and environmental criteria, and security-oriented objectives that
improve system robustness. Multiple objective function extensions can be combined to form composite objectives (e.g., minimizing
16


--- Page 17 ---
Title Suppressed Due to Excessive Size
generation cost while penalizing voltage deviations and line overloads). Table 7 presents the mathematical formulation and design
rationale for each variant.
Table 7: Objective function variants in OPF problems.
ID
Objective Name
Formulation
Descriptions
1
Real power redis-
patch cost (RPR)
RPR = P
i‚ààNG
 cu
itP u
G,it + cd
itP d
G,it

Minimize magnitude and cost of
real-power adjustments between
reference schedule and redispatched
solution
2
Reactive power gen-
eration cost (RGC)
RGC = P
i‚ààNG
 aQQ2
G,i + bQQG,i + cQ

Minimize total cost of providing reactive
power support from generators
3
Real power procure-
ment cost (RPC)
RPC = PNGp
i=1 PpiŒª
Minimize total payment for purchasing
active power from external sources at
price Œª
4
Reactive
power
procurement
cost
(QPC)
QPC = P
n‚ààNB
P
m‚àà‚Ñ¶n V 2
n
YCh,nm
2
Minimize reactive power procurement
from shunt capacitors to support bus
voltage magnitudes
5
Real power reserve
cost (RRC)
RRC = P
i‚ààIRU fu,i(Ru,i) + P
i‚ààISP fs,i(Rs,i)
Minimize capacity payment for multiple
types of active power reserves (up, down,
spinning, non-spinning)
6
Reactive
reserve
insufficiency
cost
(RRI)
RRI = ‚àíP
i‚ààNG wi(Qmax
G,i ‚àíQG,i)
Minimize negative reactive power
reserve margin (equivalently maximize
reserve) to enhance voltage security
7
System congestion
cost (SCC)
SCC =
1
NT
PNT
l=1
Sl
Smax
l
Minimize average utilization level of
transmission elements to enhance
loadability and reduce congestion
8
Voltage
stability
margin cost (VSC)
V SC = max(Li),
Lj =
1 ‚àíP Fji
Vi
Vj

Minimize maximum L-index to increase
distance to voltage-collapse points and
improve stability margin
9
Active power loss
cost (PLC)
PLC = PNG
i=1 PGi ‚àíPNL
j=1 PLj
Minimize total active power losses in
transmission network to improve system
efficiency
10
Environmental emis-
sion cost (EEC)
EEC =
P
i,t
 Œ±iP 2
G,it + Œ≤iPG,it + Œ≥i + Œ∂ieŒªiPG,it
Minimize total pollutant emissions (NOx,
SO2, CO2) using
quadratic-plus-exponential emission
functions
11
Negative transfer ca-
pability cost (NTC)
NTC = ‚àíŒª P
i‚ààSL bP i
Minimize negative transfer capability
(equivalently maximize load transfer
capacity) to estimate available transfer
capability
12
Negative social wel-
fare cost (NSW)
NSW = P
j‚ààG Cj(xj) ‚àíP
i‚ààC Bi(xi)
Minimize generation cost minus
consumer utility (equivalently maximize
social welfare) to achieve economic
efficiency
13
Voltage
deviation
penalty cost (VDP)
V DP = Cgen(PG) + Œ≤ PN
i=1(Vi ‚àí1.0)2
Minimize generation cost plus penalty on
squared voltage deviations from nominal
value (1.0 p.u.)
Continued on next page
17


--- Page 18 ---
Title Suppressed Due to Excessive Size
Table 7 ‚Äì continued from previous page
ID
Objective Name
Formulation
Descriptions
14
Angle
difference
penalty cost (ADP)
ADP = Cgen(PG) + Œ≤ P
(i,j)‚ààE(Œ∏i ‚àíŒ∏j)2
Minimize generation cost plus penalty on
excessive voltage angle differences
across transmission lines
15
Line
overload
penalty cost (LOP)
LOP = P
g Cg(Pg) ‚àíŒª P
‚Ñìs‚Ñì
Minimize generation cost with economic
penalty for line thermal limit violations
via slack variables s‚Ñì
B.3. Constraint Extensions Sc
This category comprises 9 structural variants that augment the constraint set of the base problem formulation to address security, reliability,
uncertainty, and operational flexibility requirements. These extensions reflect critical concerns in modern power system operation,
including N-1 security criteria for contingency resilience, probabilistic and robust formulations for uncertainty handling, frequency
stability constraints for low-inertia systems, and various reserve requirement formulations for ancillary services. Multiple constraint
extensions can be combined to enforce multiple operational requirements simultaneously (e.g., N-1 security constraints together with
reserve requirements and frequency stability constraints). Table 8 presents the mathematical formulation and design rationale for each
constraint variant.
Table 8: Constraint variants in OPF problems.
ID
Constraint Type
Formulation
Descriptions
1
Chance constraint
P{h(x, Œæ) ‚â§0} ‚â•1 ‚àíŒµ
Limit violation probability under
uncertain generation/load; balance
economy and risk level for high
renewable penetration
2
Robust constraint
h(x, Œæ) ‚â§0, ‚àÄŒæ ‚ààU
Maintain feasibility for all
uncertainty realizations in bounded
uncertainty set; provide worst-case
security guarantee
3
Frequency stability
constraint
‚àÜfmin ‚â•‚àÜf req,
RoCoF ‚â§RoCoFmax
Limit frequency nadir and rate of
change of frequency; reflect inertia
and primary frequency response
requirements
4
Reserve limit con-
straint
‚àíP D
R,i ‚â§‚àÜPG,i ‚â§P U
R,i,
‚àíQD
R,i ‚â§‚àÜQG,i ‚â§
QU
R,i
Explicitly limit dispatch adjustment
capability to pre-scheduled reserve
ranges for real and reactive power
5
Regulation
up
re-
serve constraint
RRU
j
‚àíP
i‚ààIRU ‚à©Zj RUi ‚â§0
Require sufficient upward
regulation reserve capacity within
each zone to handle load variations
and forecast errors
6
Spinning
reserve
constraint
RRU
j
+RSP
j
‚àíP
i‚ààIRU ‚à©Zj RUi‚àíP
i‚ààISP ‚à©Zj SPi ‚â§
0
Ensure adequate spinning reserve
for large disturbances such as
generator outages beyond
regulation needs
7
N-1
security
con-
straint (DC)
|B(k)
f
Œ∏(k)| ‚â§F max, ‚àÄk ‚ààC
Ensure no line overload after any
single line outage; implement
preventive security-constrained
dispatch
8
N-1
security
con-
straint (AC)
g(k)(x) = 0,
h(k)(x) ‚â§0,
‚àÄk ‚ààC
Enforce voltage magnitude and
thermal limits after any single
contingency in full AC power flow
model
Continued on next page
18


--- Page 19 ---
Title Suppressed Due to Excessive Size
Table 8 ‚Äì continued from previous page
ID
Constraint Type
Formulation
Descriptions
9
Voltage stability con-
straint
Li(V, Œ∏) ‚â§Lmax,
‚àÄi ‚ààNB
Prevent voltage instability by
constraining voltage stability
indices such as L-index below
critical threshold
19


--- Page 20 ---
Title Suppressed Due to Excessive Size
C. Data Synthesis Pseudocode
This appendix provides detailed pseudocode algorithms for the data synthesis process of each difficulty level in ProOPF-D. These
algorithms formalize the generative procedures described in subsection 4.2.
C.1. Level 1: Explicit Parameter Specification
Algorithm 1 Data Synthesis for Level 1 (L1)
Require: Base system pool ‚Ñ¶sys, parameter modification space ‚Ñ¶œÄ, solver requirement space ‚Ñ¶R, instruction specification
œÑ L1, LLM model pLLM, number of samples N
Ensure: Sample set Z = {zi}N
i=1 where each zi = {ML1
i , Pi, Ii}
1: Initialize sample set: Z ‚Üê‚àÖ
2: for i = 1 to N do
3:
Sample base system: œâ ‚àºU(‚Ñ¶sys)
4:
Sample parameter modifications: ‚àÜœÄ = {Œ¥k}K
k=1 ‚àºU(‚Ñ¶œÄ)
5:
Set structural modification: s ‚Üê‚àÖ
6:
Sample solver requirements: R ‚àºU(‚Ñ¶R)
7:
Construct model specification: ML1 ‚Üê{œâ, ‚àÜœÄ, s, R}
8:
Generate NL description and implementation: (P, I) ‚àºpLLM(¬∑ | ML1, œÑ L1)
9:
Form complete sample: z ‚Üê{ML1, P, I}
10:
Add to sample set: Z ‚ÜêZ ‚à™{z}
11: end for
12: return Z
C.2. Level 2: Semantic Parameter Inference
Algorithm 2 Data Synthesis for Level 2 (L2)
Require: Base system pool ‚Ñ¶sys, directional parameter space ‚Ñ¶dir
œÄ , solver requirement space ‚Ñ¶R, scenario tree collection
T = {Tm}M
m=1, instruction specification œÑ L2, LLM model pLLM, number of samples N
Ensure: Sample set Z = {zi}N
i=1 where each zi = {ML2
i , Pi, Ii}
1: Initialize sample set: Z ‚Üê‚àÖ
2: for i = 1 to N do
3:
Sample base system: œâ ‚àºU(‚Ñ¶sys)
4:
Sample directional parameter modifications: ‚àÜœÄ = {Œ¥k}K
k=1 ‚àºU(‚Ñ¶dir
œÄ )
5:
Set structural modification: s ‚Üê‚àÖ
6:
Sample solver requirements: R ‚àºU(‚Ñ¶R)
7:
Initialize scenario fragment set: c ‚Üê‚àÖ
8:
for k = 1 to K do
9:
Extract parameter identifier: pk ‚Üêpar(Œ¥k)
10:
Extract modification direction: dk ‚Üêdir(Œ¥k)
11:
Retrieve matching leaf nodes: Vk ‚ÜêRetrieve(T | pk, dk)
12:
Extract root-to-node paths: Nk ‚Üê{paths from root to v | v ‚ààVk}
13:
Sample scenario fragment: ck ‚àºU(Nk)
14:
Add to fragment set: c ‚Üêc ‚à™{ck}
15:
end for
16:
Construct intermediate specification: f
ML2 ‚Üê{œâ, c, s, R}
17:
Generate NL description and implementation: (P, I) ‚àºpLLM(¬∑ | f
ML2, œÑ L2)
18:
Reconstruct original model specification: ML2 ‚Üê{œâ, ‚àÜœÄ, s, R}
19:
Form complete sample: z ‚Üê{ML2, P, I}
20:
Add to sample set: Z ‚ÜêZ ‚à™{z}
21: end for
22: return Z
20


--- Page 21 ---
Title Suppressed Due to Excessive Size
C.3. Level 3: Structural Extensions with Explicit Parameters
Algorithm 3 Data Synthesis for Level 3 (L3)
Require: Base system pool ‚Ñ¶sys, parameter modification space ‚Ñ¶œÄ, structural modification space ‚Ñ¶s = Sp √ó 2So √ó 2Sc,
solver requirement space ‚Ñ¶R, cardinality bounds Ko, Kc, instruction specification œÑ L3, LLM model pLLM, number of
samples N
Ensure: Sample set Z = {zi}N
i=1 where each zi = {ML3
i , Pi, Ii}
1: Initialize sample set: Z ‚Üê‚àÖ
2: for i = 1 to N do
3:
Sample base system: œâ ‚àºU(‚Ñ¶sys)
4:
Sample parameter modifications: ‚àÜœÄ = {Œ¥k}K
k=1 ‚àºU(‚Ñ¶œÄ)
5:
Sample problem type: sp ‚àºU(Sp)
6:
Sample objective extensions: so ‚äÜSo with |so| ‚â§Ko
7:
Sample constraint extensions: sc ‚äÜSc with |sc| ‚â§Kc
8:
Construct structural modification: s ‚Üê(sp, so, sc)
9:
Sample solver requirements: R ‚àºU(‚Ñ¶R)
10:
Construct model specification: ML3 ‚Üê{œâ, ‚àÜœÄ, s, R}
11:
Generate NL description and implementation: (P, I) ‚àºpLLM(¬∑ | ML3, œÑ L3)
12:
Form complete sample: z ‚Üê{ML3, P, I}
13:
Add to sample set: Z ‚ÜêZ ‚à™{z}
14: end for
15: return Z
C.4. Level 4: Structural Extensions with Semantic Parameters
Algorithm 4 Data Synthesis for Level 4 (L4)
Require: Base system pool ‚Ñ¶sys, directional parameter space ‚Ñ¶dir
œÄ , structural modification space ‚Ñ¶s = Sp√ó2So √ó2Sc, solver requirement
space ‚Ñ¶R, relaxed cardinality bounds K‚Ä≤
o, K‚Ä≤
c, scenario tree collection T = {Tm}M
m=1, instruction specification œÑ L4, LLM model
pLLM, number of samples N
Ensure: Sample set Z = {zi}N
i=1 where each zi = {ML4
i , Pi, Ii}
1: Initialize sample set: Z ‚Üê‚àÖ
2: for i = 1 to N do
3:
Sample base system: œâ ‚àºU(‚Ñ¶sys)
4:
Sample directional parameter modifications: ‚àÜœÄ = {Œ¥k}K
k=1 ‚àºU(‚Ñ¶dir
œÄ )
5:
Sample problem type: sp ‚àºU(Sp)
6:
Sample objective extensions: so ‚äÜSo with |so| ‚â§K‚Ä≤
o
7:
Sample constraint extensions: sc ‚äÜSc with |sc| ‚â§K‚Ä≤
c
8:
Construct structural modification: s ‚Üê(sp, so, sc)
9:
Sample solver requirements: R ‚àºU(‚Ñ¶R)
10:
Initialize scenario fragment set: c ‚Üê‚àÖ
11:
for k = 1 to K do
12:
Extract parameter identifier: pk ‚Üêpar(Œ¥k)
13:
Extract modification direction: dk ‚Üêdir(Œ¥k)
14:
Retrieve matching leaf nodes: Vk ‚ÜêRetrieve(T | pk, dk)
15:
Extract root-to-node paths: Nk ‚Üê{paths from root to v | v ‚ààVk}
16:
Sample scenario fragment: ck ‚àºU(Nk)
17:
Add to fragment set: c ‚Üêc ‚à™{ck}
18:
end for
19:
Construct intermediate specification: f
ML4 ‚Üê{œâ, c, s, R}
20:
Generate NL description and implementation: (P, I) ‚àºpLLM(¬∑ | f
ML4, œÑ L4)
21:
Reconstruct original model specification: ML4 ‚Üê{œâ, ‚àÜœÄ, s, R}
22:
Form complete sample: z ‚Üê{ML4, P, I}
23:
Add to sample set: Z ‚ÜêZ ‚à™{z}
24: end for
25: return Z
21


--- Page 22 ---
Title Suppressed Due to Excessive Size
C.5. Data Cleaning and Text Diversification
This subsection provides the pseudocode algorithm for the data cleaning and text diversification process described in Section 4.2.
Algorithm 5 Data Cleaning and Text Diversification
Require: Raw sample set Zraw = {zi}N
i=1, compatibility rule table C, diversification instruction œÑ diversify, LLM model pLLM
Ensure: Cleaned and diversified sample set Zclean
1: {Stage 1: Compatibility filtering}
2: Initialize filtered sample set: Zfiltered ‚Üê‚àÖ
3: for zi = {Mi, Pi, Ii} ‚ààZraw do
4:
Extract structural modification: s ‚ÜêMi.s
5:
Extract parameter modifications: ‚àÜœÄi ‚ÜêMi.‚àÜœÄ
6:
if (s, ‚àÜœÄi) /‚ààC then
7:
Zfiltered ‚ÜêZfiltered ‚à™{zi}
8:
end if
9: end for
10: {Stage 2: Text diversification for samples with identical M}
11: Initialize cleaned set: Zclean ‚Üê‚àÖ
12: for each unique model specification M in Zfiltered do
13:
Construct equivalence class: ZM ‚Üê{zi ‚ààZfiltered | Mi = M}
14:
if |ZM| = 1 then
15:
Zclean ‚ÜêZclean ‚à™ZM
16:
else
17:
for zi = {Mi, Pi, Ii} ‚ààZM do
18:
Generate diversified text: P‚Ä≤
i ‚àºpLLM(¬∑ | Pi, œÑ diversify)
19:
Form diversified sample: z‚Ä≤
i ‚Üê{Mi, P‚Ä≤
i, Ii}
20:
Zclean ‚ÜêZclean ‚à™{z‚Ä≤
i}
21:
end for
22:
end if
23: end for
24: return Zclean
22


--- Page 23 ---
Title Suppressed Due to Excessive Size
D. Sample Examples and Generation Prompts by Difficulty Level for ProOPF-D
D.1. Level 1: Explicit Parameter Synthesis
Part 1: Natural Language (P)
The NL description provides explicit instructions with specific numerical values for parameter modifications.
Perform AC optimal power flow (ACOPF) on the IEEE 39-bus system (case39). Scale the active power demand at bus 1 by a
factor of 1.5. Set the maximum active power output of all generators at bus 32 to 500 MW. Relax the minimum voltage magnitude
constraint at bus 10 by setting VMIN to 0. Set the branch reactance for the line between bus 2 and bus 25 to 0.01. Set the OPF
violation tolerance (opf.violation) to 1e-8, and write the corresponding MATPOWER code.
Part 2: Model Specification (M)
The structured specification defines parameter modifications with explicit operations and values.
{
"base system": "case39",
"parameter modifications":
[
{"component": "bus", "bus id": 1, "target parameter": "PD", "operation": "Scale",
"value": 1.5},
{"component": "gen", "bus id": 32, "target parameter": "PMAX", "operation": "Set",
"value": 500},
{"component": "bus", "bus id": 10, "target parameter": "VMIN", "operation": "Set",
"value": 0},
{"component": "branch", "fbus": 2, "tbus": 25, "target parameter": "BR_X",
"operation": "Set", "value": 0.01}
],
"structural modification":
{},
"solving requirements": {
"opf violation": 1e-8
}
}
Part 3: MATPOWER Code
The generated code implements the specified modifications and solves the OPF problem.
1
define_constants;
2
mpc = loadcase(‚Äôcase39‚Äô);
3
4
bus1_idx = find(mpc.bus(:, BUS_I) == 1);
5
mpc.bus(bus1_idx, PD) = mpc.bus(bus1_idx, PD) * 1.5;
6
7
gen32_idx = find(mpc.gen(:, GEN_BUS) == 32);
8
mpc.gen(gen32_idx, PMAX) = 500;
9
10
bus10_idx = find(mpc.bus(:, BUS_I) == 10);
11
mpc.bus(bus10_idx, VMIN) = 0;
12
13
branch_idx = find( ...
14
(mpc.branch(:, F_BUS) == 2
& mpc.branch(:, T_BUS) == 25) | ...
15
(mpc.branch(:, F_BUS) == 25 & mpc.branch(:, T_BUS) == 2) );
16
mpc.branch(branch_idx, BR_X) = 0.01;
17
18
mpopt = mpoption(‚Äôopf.violation‚Äô, 1e-8);
19
results = runopf(mpc, mpopt);
20
printpf(results);
Part 4: Synthesis Instructions (œÑ L1)
The synthesis instruction œÑ L1 guides the LLM to generate aligned natural language descriptions P and executable MATPOWER
implementations I from a given model specification ML1. The prompt structure follows a few-shot in-context learning paradigm with
explicit formatting requirements.
23


--- Page 24 ---
Title Suppressed Due to Excessive Size
Task: You are an expert power systems engineer specializing in optimal power flow (OPF) modeling. Your task is to generate a
natural language description and executable MATPOWER code for an OPF problem based on the provided model specification. The
natural language description should be clear and professional, suitable for control room operators, while the MATPOWER code
must be syntactically correct and executable.
Input Format: A JSON object containing base system, parameter modifications (each with component, bus id or fbus/tbus,
target parameter, operation, and value), structural modification (empty for Level 1), and solving requirements.
Output Requirements:
1. Natural Language Description: Write a clear, professional instruction that explicitly states all parameter modifications with
their numerical values. Use imperative language (e.g., ‚ÄùScale...‚Äù, ‚ÄùSet...‚Äù) and include the base system, all modifications, and
solver requirements.
2. MATPOWER Code: Generate executable MATLAB code that loads the base system using loadcase(), applies all
parameter modifications using appropriate MATPOWER indexing, configures solver options via mpoption(), executes OPF
via runopf().
Example:
Input Model Specification:
{
"base system": "case39",
"parameter modifications":
[
{"component": "bus", "bus id": 1, "target parameter": "PD",
"operation": "Scale", "value": 1.5},
{"component": "gen", "bus id": 32, "target parameter": "PMAX",
"operation": "Set", "value": 500},
{"component": "bus", "bus id": 10, "target parameter": "VMIN",
"operation": "Set", "value": 0},
{"component": "branch", "fbus": 2, "tbus": 25,
"target parameter": "BR_X", "operation": "Set", "value": 0.01}
],
"structural modification":
{},
"solving requirements": {"opf violation": 1e-8}
}
Expected Natural Language Output: Perform AC optimal power flow (ACOPF) on the IEEE 39-bus system (case39). Scale the
active power demand at bus 1 by a factor of 1.5. Set the maximum active power output of all generators at bus 32 to 500 MW. Relax
the minimum voltage magnitude constraint at bus 10 by setting VMIN to 0. Set the branch reactance (BR X) for the line between
bus 2 and bus 25 to 0.01. Set the OPF violation tolerance (opf.violation) to 1e-8, and write the corresponding MATPOWER code.
Expected MATPOWER Code Output:
1
define_constants;
2
mpc = loadcase(‚Äôcase39‚Äô);
3
4
bus1_idx = find(mpc.bus(:, BUS_I) == 1);
5
mpc.bus(bus1_idx, PD) = mpc.bus(bus1_idx, PD) * 1.5;
6
7
gen32_idx = find(mpc.gen(:, GEN_BUS) == 32);
8
mpc.gen(gen32_idx, PMAX) = 500;
9
10
bus10_idx = find(mpc.bus(:, BUS_I) == 10);
11
mpc.bus(bus10_idx, VMIN) = 0;
12
13
branch_idx = find( ...
14
(mpc.branch(:, F_BUS) == 2
& mpc.branch(:, T_BUS) == 25) | ...
15
(mpc.branch(:, F_BUS) == 25 & mpc.branch(:, T_BUS) == 2) );
16
mpc.branch(branch_idx, BR_X) = 0.01;
17
18
mpopt = mpoption(‚Äôopf.violation‚Äô, 1e-8);
19
results = runopf(mpc, mpopt);
24


--- Page 25 ---
Title Suppressed Due to Excessive Size
D.2. Level 2: Semantic Parameter Inference
Part 1: Natural Language (P)
The NL description uses scenario-based narratives to describe parameter changes, requiring inference of modification directions rather
than explicit values.
A regional grid is modeled using the IEEE 39-bus system (case39). During an extreme summer heatwave, widespread air-conditioning
usage sharply increases the electrical demand around bus 1. Meanwhile, high ambient temperature forces the generator(s) connected
to bus 32 to operate in a derated mode, limiting their deliverable output. During late-night hours, bus 10, which primarily serves
industrial loads from an industrial park, enters a scheduled shutdown period with all production facilities ceasing operations. In
addition, a fault-triggered outage of local compensation equipment on the corridor between bus 2 and bus 25 degrades power transfer
capability along that path. Set opf.violation to 1e-8, use IPOPT as the ACOPF solver, and generate the corresponding MATPOWER
code. All scenario-driven parameters are assigned using placeholder values of the form object parameter id, which represent the
post-modification values consistent with the specified scenario directions.
Part 2: Model Specification (M)
The structured specification uses direction constraints (Increase/Decrease) instead of explicit values, requiring semantic understanding of
the scenario.
{
"base system": "case39",
"parameter modifications":
[
{"component": "bus", "bus id": 1, "target parameter": "PD", "direction": "Increase"
},
{"component": "gen", "bus id": 32, "target parameter": "PMAX", "direction": "
Decrease"},
{"component": "bus", "bus id": 10, "target parameter": "PD", "direction": "Set zero
"},
{"component": "branch", "fbus": 2, "tbus": 25, "target parameter": "BR_X",
"direction": "Increase"}
],
"structural modification":
{},
"solving requirements": {
"opf violation": 1e-8,
"solver": "IPOPT"
}
}
Part 3: MATPOWER Code
The generated code is structured as a function that accepts placeholder variables as parameters and includes assertion checks to validate
direction constraints.
1
function results = opf_case39(bus_PD_1, gen_PMAX_32, bus_PD_10, branch_BR_X_2_25)
2
define_constants;
3
mpc = loadcase(‚Äôcase39‚Äô);
4
5
bus1_idx = find(mpc.bus(:, BUS_I) == 1);
6
pd0_bus1 = mpc.bus(bus1_idx, PD);
7
assert(bus_PD_1 >= pd0_bus1);
8
mpc.bus(bus1_idx, PD) = bus_PD_1;
9
10
gen32_idx = find(mpc.gen(:, GEN_BUS) == 32);
11
pmax0_gen32 = mpc.gen(gen32_idx, PMAX);
12
assert(all(gen_PMAX_32 <= pmax0_gen32));
13
mpc.gen(gen32_idx, PMAX) = gen_PMAX_32;
14
15
bus10_idx = find(mpc.bus(:, BUS_I) == 10);
16
assert(bus_PD_10 == 0);
17
mpc.bus(bus10_idx, PD) = bus_PD_10;
18
19
branch_idx = find( ...
20
(mpc.branch(:, F_BUS) == 2
& mpc.branch(:, T_BUS) == 25) | ...
21
(mpc.branch(:, F_BUS) == 25 & mpc.branch(:, T_BUS) == 2) );
25


--- Page 26 ---
Title Suppressed Due to Excessive Size
22
x0_2_25 = mpc.branch(branch_idx, BR_X);
23
assert(all(branch_BR_X_2_25 >= x0_2_25));
24
mpc.branch(branch_idx, BR_X) = branch_BR_X_2_25;
25
26
mpopt = mpoption(‚Äôopf.violation‚Äô, 1e-8, ‚Äôopf.ac.solver‚Äô, ‚ÄôIPOPT‚Äô);
27
results = runopf(mpc, mpopt);
28
printpf(results);
29
end
Part 4: Synthesis Instructions (œÑ L2)
The synthesis instruction œÑ L2 guides the LLM to generate scenario-based natural language descriptions P and parameterized MATPOWER
implementations I from scenario fragments {ck}K
k=1 that semantically encode parameter modification directions without explicit
numerical values. The prompt structure emphasizes narrative composition and function design with placeholder-based parameterization.
Task: You are an expert power systems engineer specializing in optimal power flow (OPF) modeling. Your task is to generate a
scenario-based natural language description and a parameterized MATPOWER function for an OPF problem based on the provided
scenario fragments. The natural language description should compose these fragments into a coherent operational narrative without
explicitly mentioning parameter names or modification directions. The MATPOWER code must be structured as a function that
accepts placeholder variables and includes assertion checks to validate modification direction constraints.
Input Format: A JSON object containing base system, scenario fragments (a list of scenario descriptions that semantically encode
parameter modification directions), structural modification (empty for Level 2), and solving requirements.
Output Requirements:
1. Natural Language Description: Compose the scenario fragments into a coherent, professional narrative that describes
operational conditions and their implications on the power system. The description should:
‚Ä¢ Integrate all scenario fragments into a unified operational scenario
‚Ä¢ Use natural, scenario-based language (e.g., ‚ÄùDuring an extreme summer heatwave...‚Äù, ‚ÄùMeanwhile, high ambient
temperature forces...‚Äù)
‚Ä¢ Avoid explicitly stating parameter names or modification directions
‚Ä¢ Include a statement that scenario-driven parameters use placeholder values of the form object parameter id
‚Ä¢ Include solver requirements and request MATPOWER code generation
2. MATPOWER Code: Generate a MATLAB function that:
‚Ä¢ Accepts placeholder variables as function parameters (naming convention: object parameter id, e.g., bus PD 1,
gen PMAX 32)
‚Ä¢ Loads the base system using loadcase()
‚Ä¢ For each parameter modification, retrieves the original value, adds an assertion to validate the modification direction
(e.g., assert(bus PD 1 >= pd0 bus1) for Increase, assert(all(gen PMAX 32 <= pmax0 gen32)) for
Decrease, assert(bus PD 10 == 0) for Set zero)
‚Ä¢ Applies the placeholder parameter values to the model
‚Ä¢ Configures solver options via mpoption() including solver specification if provided
‚Ä¢ Executes OPF via runopf()
Example:
Input Scenario Fragments:
{
"base system": "case39",
"scenario_fragments": [
"Extreme summer heatwave + Increased electrical demand",
"High ambient temperature + Generator derating",
"Late-night hours + Industrial park shutdown",
"Fault-triggered outage + Degraded power transfer capability"
],
"structural modification":
{},
"solving requirements": {
"opf violation": 1e-8,
"solver": "IPOPT"
}
}
26


--- Page 27 ---
Title Suppressed Due to Excessive Size
Expected Natural Language Output: A regional grid is modeled using the IEEE 39-bus system (case39). During an extreme
summer heatwave, widespread air-conditioning usage sharply increases the electrical demand around bus 1. Meanwhile, high
ambient temperature forces the generator(s) connected to bus 32 to operate in a derated mode, limiting their deliverable output.
During late-night hours, bus 10, which primarily serves industrial loads from an industrial park, enters a scheduled shutdown period
with all production facilities ceasing operations. In addition, a fault-triggered outage of local compensation equipment on the corridor
between bus 2 and bus 25 degrades power transfer capability along that path. Set opf.violation to 1e-8, use IPOPT as the ACOPF
solver, and generate the corresponding MATPOWER code. All scenario-driven parameters are assigned using placeholder values of
the form object parameter id, which represent the post-modification values consistent with the specified scenario directions.
Expected MATPOWER Code Output:
1
function results = opf_case39(bus_PD_1, gen_PMAX_32, bus_PD_10, branch_BR_X_2_25)
2
define_constants;
3
mpc = loadcase(‚Äôcase39‚Äô);
4
5
bus1_idx = find(mpc.bus(:, BUS_I) == 1);
6
pd0_bus1 = mpc.bus(bus1_idx, PD);
7
assert(bus_PD_1 >= pd0_bus1);
8
mpc.bus(bus1_idx, PD) = bus_PD_1;
9
10
gen32_idx = find(mpc.gen(:, GEN_BUS) == 32);
11
pmax0_gen32 = mpc.gen(gen32_idx, PMAX);
12
assert(all(gen_PMAX_32 <= pmax0_gen32));
13
mpc.gen(gen32_idx, PMAX) = gen_PMAX_32;
14
15
bus10_idx = find(mpc.bus(:, BUS_I) == 10);
16
assert(bus_PD_10 == 0);
17
mpc.bus(bus10_idx, PD) = bus_PD_10;
18
19
branch_idx = find( ...
20
(mpc.branch(:, F_BUS) == 2
& mpc.branch(:, T_BUS) == 25) | ...
21
(mpc.branch(:, F_BUS) == 25 & mpc.branch(:, T_BUS) == 2) );
22
x0_2_25 = mpc.branch(branch_idx, BR_X);
23
assert(all(branch_BR_X_2_25 >= x0_2_25));
24
mpc.branch(branch_idx, BR_X) = branch_BR_X_2_25;
25
26
mpopt = mpoption(‚Äôopf.violation‚Äô, 1e-8, ‚Äôopf.ac.solver‚Äô, ‚ÄôIPOPT‚Äô);
27
results = runopf(mpc, mpopt);
28
printpf(results);
29
end
D.3. Level 3: Structural Extensions with Explicit Parameters
Part 1: Natural Language (P)
The NL description includes structural modifications (problem type change and custom objective function) along with explicit parameter
specifications.
Formulate a DC optimal power flow (DCOPF) problem for the IEEE 39-bus system (case39). In addition to the default generation
cost in the base case, add a quadratic penalty on phase-angle differences across all in-service transmission lines to discourage
excessive angle separation (penalty weight beta = 10). Scale the active power demand at bus 1 by 1.5, set the maximum active power
output of the generator(s) connected to bus 32 to 500 MW, and set the branch reactance of the line between bus 2 and bus 25 to 0.01.
Set opf.violation to 1e-8, and write the corresponding MATPOWER code.
Part 2: Model Specification (M)
The structured specification includes both explicit parameter modifications and structural modifications (problem type and objective
function extension).
{
"base system": "case39",
"parameter modifications":
[
{"component": "bus", "bus id": 1, "target parameter": "PD", "operation": "Scale",
"value": 1.5},
27


--- Page 28 ---
Title Suppressed Due to Excessive Size
{"component": "gen", "bus id": 32, "target parameter": "PMAX", "operation": "Set",
"value": 500},
{"component": "branch", "fbus": 2, "tbus": 25, "target parameter": "BR_X",
"operation": "Set", "value": 0.01}
],
"structural modification":
{
"problem": "DCOPF",
"objective_modification": {
"op": "add",
"name": "angle_difference_penalty",
"beta": 10,
"form": "beta * ||E*Va||_2ÀÜ2"
}
},
"solving requirements": {
"opf violation": 1e-8
}
}
Part 3: MATPOWER Code
The generated code implements structural modifications using advanced OPF setup with custom objective function.
1
define_constants;
2
mpc = loadcase(‚Äôcase39‚Äô);
3
4
bus1_idx = find(mpc.bus(:, BUS_I) == 1);
5
mpc.bus(bus1_idx, PD) = mpc.bus(bus1_idx, PD) * 1.5;
6
7
gen32_idx = find(mpc.gen(:, GEN_BUS) == 32);
8
mpc.gen(gen32_idx, PMAX) = 500;
9
10
branch_idx_2_25 = find( ...
11
(mpc.branch(:, F_BUS) == 2
& mpc.branch(:, T_BUS) == 25) | ...
12
(mpc.branch(:, F_BUS) == 25 & mpc.branch(:, T_BUS) == 2) );
13
mpc.branch(branch_idx_2_25, BR_X) = 0.01;
14
15
mpopt = mpoption(‚Äôopf.violation‚Äô, 1e-8, ‚Äômodel‚Äô, ‚ÄôDC‚Äô);
16
17
beta = 10;
18
19
om = opf_setup(mpc, mpopt);
20
21
nb = size(mpc.bus, 1);
22
br_on = find(mpc.branch(:, BR_STATUS) == 1);
23
nl = length(br_on);
24
25
f = mpc.branch(br_on, F_BUS);
26
t = mpc.branch(br_on, T_BUS);
27
28
E = sparse(1:nl, f,
1, nl, nb) + sparse(1:nl, t, -1, nl, nb);
29
30
Q_va = 2 * beta * (E‚Äô * E);
31
om = om.add_quad_cost(‚Äôang_diff_pen‚Äô, Q_va, [], 0, {‚ÄôVa‚Äô});
32
33
idx_i1 = om.var.idx.i1;
34
idx_iN = om.var.idx.iN;
35
36
[x, fval, eflag, Àú, Àú] = om.solve();
37
38
Va_solution = x(idx_i1.Va:idx_iN.Va);
39
Pg_solution = x(idx_i1.Pg:idx_iN.Pg);
40
41
results = mpc;
42
results.bus(:, VA) = Va_solution * 180/pi;
28


--- Page 29 ---
Title Suppressed Due to Excessive Size
43
results.gen(:, PG) = Pg_solution;
44
results.f = fval;
45
results.success = (eflag > 0);
46
47
printpf(results);
Part 4: Synthesis Instructions (œÑ L3)
The synthesis instruction œÑ L3 guides the LLM to generate natural language descriptions P and executable MATPOWER implementations
I that incorporate structural modifications (e.g., problem type changes, custom objective functions, additional constraints) along with
explicit parameter modifications. The prompt structure emphasizes understanding structural extension design principles and their
MATPOWER implementation patterns.
Task: You are an expert power systems engineer specializing in optimal power flow (OPF) modeling with advanced structural
extensions. Your task is to generate a natural language description and executable MATPOWER code for an OPF problem that
includes both structural modifications (problem type changes, objective function extensions, or constraint additions) and explicit
parameter modifications with numerical values.
Input Format: A JSON object containing the following components:
‚Ä¢ base system: The base power system specification (e.g., MATPOWER case file identifier or system data structure).
‚Ä¢ parameter modifications: Explicit parameter modifications with specific operations (e.g., set, scale, offset) and numerical
values applied to system parameters (e.g., generator costs, line impedances, load values).
‚Ä¢ structural modification: A specification of structural changes to the OPF problem formulation, which may include:
‚Äì Problem Type Changes: Modifications to the fundamental problem formulation that alter the decision variable space or
reformulate the problem structure, such as switching between different OPF variants (e.g., "ACOPF", "DCOPF", "ED",
"UC", "OTS").
‚Äì Objective Function Extensions: Additions or modifications to the objective function beyond the standard cost minimiza-
tion, such as quadratic penalties on specific decision variables, linear terms, or custom cost functions that incorporate
additional system considerations.
‚Äì Constraint Modifications: Additions, modifications, or relaxations of constraints beyond the standard OPF con-
straints, including custom equality or inequality constraints that capture additional operational requirements or system
characteristics.
The structural modification component should specify the type of structural change, the mathematical form of the modification
(e.g., quadratic penalty terms, linear constraints), the decision variables involved, and any relevant parameters or coefficients.
‚Ä¢ solving requirements: Solver configuration and solution requirements (e.g., solver type, tolerance settings, output format
specifications).
Structural Modification Design Principles:
‚Ä¢ Problem Type Changes: Structural modifications that alter the fundamental mathematical model (e.g., linearization assump-
tions, variable elimination, constraint relaxation) require corresponding changes in the optimization framework configuration
and variable space definition.
‚Ä¢ Objective Function Extensions: Custom objective terms should be mathematically well-defined and compatible with the
underlying optimization framework, maintaining convexity properties when required and ensuring proper integration with
existing cost functions.
‚Ä¢ Constraint Extensions: Additional constraints must be formulated in a manner consistent with the optimization model
structure, properly indexing decision variables and maintaining feasibility of the solution space.
‚Ä¢ Implementation Considerations: The implementation should follow the optimization framework‚Äôs standard patterns for model
construction, variable definition, constraint addition, and solution extraction, ensuring compatibility with the framework‚Äôs
internal mechanisms.
Output Requirements:
1. Natural Language Description: Write a clear, professional instruction that:
‚Ä¢ Explicitly states the structural modification (e.g., ‚ÄùFormulate a DC optimal power flow...‚Äù, ‚Äùadd a quadratic penalty on...‚Äù)
‚Ä¢ Includes all explicit parameter modifications with their numerical values
‚Ä¢ Specifies solver requirements and requests MATPOWER code generation
29


--- Page 30 ---
Title Suppressed Due to Excessive Size
2. MATPOWER Code: Generate executable MATLAB code that:
‚Ä¢ Loads the base system and applies explicit parameter modifications
‚Ä¢ Configures solver options including model type if structural modification specifies a problem type change
‚Ä¢ Uses opf setup() to create an optimization model object
‚Ä¢ Implements structural modifications:
‚Äì For objective extensions:
Construct the quadratic cost matrix Q based on the specified form, then use
om.add quad cost() to add the term
‚Äì For constraint extensions: Use appropriate constraint addition methods
‚Ä¢ Solves using om.solve() and extracts solution components
‚Ä¢ Constructs and returns a results structure with solution values
Example:
Input Model Specification:
{
"base system": "case39",
"parameter modifications":
[
{"component": "bus", "bus id": 1, "target parameter": "PD",
"operation": "Scale", "value": 1.5},
{"component": "gen", "bus id": 32, "target parameter": "PMAX",
"operation": "Set", "value": 500},
{"component": "branch", "fbus": 2, "tbus": 25,
"target parameter": "BR_X", "operation": "Set", "value": 0.01}
],
"structural modification":
{
"problem": "DCOPF",
"objective_modification": {
"op": "add",
"name": "angle_difference_penalty",
"beta": 10,
"form": "beta * ||E*Va||_2ÀÜ2"
}
},
"solving requirements": {"opf violation": 1e-8}
}
Expected Natural Language Output: Formulate a DC optimal power flow (DCOPF) problem for the IEEE 39-bus system (case39).
In addition to the default generation cost in the base case, add a quadratic penalty on phase-angle differences across all in-service
transmission lines to discourage excessive angle separation (penalty weight beta = 10). Scale the active power demand at bus 1 by
1.5, set the maximum active power output of the generator(s) connected to bus 32 to 500 MW, and set the branch reactance of the
line between bus 2 and bus 25 to 0.01. Set opf.violation to 1e-8, and write the corresponding MATPOWER code.
Expected MATPOWER Code Output:
1
define_constants;
2
mpc = loadcase(‚Äôcase39‚Äô);
3
4
bus1_idx = find(mpc.bus(:, BUS_I) == 1);
5
mpc.bus(bus1_idx, PD) = mpc.bus(bus1_idx, PD) * 1.5;
6
7
gen32_idx = find(mpc.gen(:, GEN_BUS) == 32);
8
mpc.gen(gen32_idx, PMAX) = 500;
9
10
branch_idx_2_25 = find( ...
11
(mpc.branch(:, F_BUS) == 2
& mpc.branch(:, T_BUS) == 25) | ...
12
(mpc.branch(:, F_BUS) == 25 & mpc.branch(:, T_BUS) == 2) );
13
mpc.branch(branch_idx_2_25, BR_X) = 0.01;
14
15
mpopt = mpoption(‚Äôopf.violation‚Äô, 1e-8, ‚Äômodel‚Äô, ‚ÄôDC‚Äô);
16
17
beta = 10;
18
19
om = opf_setup(mpc, mpopt);
30


--- Page 31 ---
Title Suppressed Due to Excessive Size
20
21
nb = size(mpc.bus, 1);
22
br_on = find(mpc.branch(:, BR_STATUS) == 1);
23
nl = length(br_on);
24
25
f = mpc.branch(br_on, F_BUS);
26
t = mpc.branch(br_on, T_BUS);
27
28
E = sparse(1:nl, f,
1, nl, nb) + sparse(1:nl, t, -1, nl, nb);
29
30
Q_va = 2 * beta * (E‚Äô * E);
31
om = om.add_quad_cost(‚Äôang_diff_pen‚Äô, Q_va, [], 0, {‚ÄôVa‚Äô});
32
33
idx_i1 = om.var.idx.i1;
34
idx_iN = om.var.idx.iN;
35
36
[x, fval, eflag, Àú, Àú] = om.solve();
37
38
Va_solution = x(idx_i1.Va:idx_iN.Va);
39
Pg_solution = x(idx_i1.Pg:idx_iN.Pg);
40
41
results = mpc;
42
results.bus(:, VA) = Va_solution * 180/pi;
43
results.gen(:, PG) = Pg_solution;
44
results.f = fval;
45
results.success = (eflag > 0);
46
47
printpf(results);
D.4. Level 4: Structural Extensions with Semantic Parameters
Part 1: Natural Language (P)
The NL description combines scenario-based narratives with structural modification requirements, representing the most complex level.
A regional grid is modeled using the IEEE 39-bus system (case39). During an extreme summer heatwave, widespread air-conditioning
usage sharply increases the demand around bus 1. High ambient temperature forces the generator(s) connected to bus 32 to operate in
a derated mode, reducing their deliverable output capacity. In addition, a fault-triggered outage of local compensation equipment on
the corridor between bus 2 and bus 25 degrades power transfer capability along that path. To discourage excessive phase separation
under stressed operation, formulate a DC optimal power flow (DCOPF) and add a quadratic penalty on phase-angle differences
across all in-service transmission lines with penalty weight beta = 10. Set opf.violation to 1e-8, use IPOPT as the DCOPF solver,
and generate the corresponding MATPOWER code. All scenario-driven parameters are assigned using placeholder values of the
form object parameter id, which represent post-modification values consistent with the specified scenario directions.
Part 2: Model Specification (M)
The structured specification combines semantic parameter specifications (direction constraints) with structural modifications (problem
type and objective function extension).
{
"base system": "case39",
"parameter modifications":
[
{"component": "bus", "bus id": 1, "target parameter": "PD", "direction": "Increase"
},
{"component": "gen", "bus id": 32, "target parameter": "PMAX", "direction": "
Decrease"},
{"component": "branch", "fbus": 2, "tbus": 25, "target parameter": "BR_X",
"direction": "Increase"}
],
"structural modification":
{
"problem": "DCOPF",
"objective_modification": {
31


--- Page 32 ---
Title Suppressed Due to Excessive Size
"op": "add",
"name": "angle_difference_penalty",
"beta": 10,
"form": "beta * ||E*Va||_2ÀÜ2"
}
},
"solving requirements": {
"opf violation": 1e-8,
"solver": "IPOPT"
}
}
Part 3: MATPOWER Code
The generated code is structured as a function that accepts placeholder variables as parameters, combines them with assertion checks, and
implements advanced OPF setup for structural modifications.
1
function results = opf_case39_sc(bus_PD_1, gen_PMAX_32, branch_BR_X_2_25)
2
define_constants;
3
mpc = loadcase(‚Äôcase39‚Äô);
4
5
bus1_idx = find(mpc.bus(:, BUS_I) == 1);
6
pd0_bus1 = mpc.bus(bus1_idx, PD);
7
assert(bus_PD_1 >= pd0_bus1);
8
mpc.bus(bus1_idx, PD) = bus_PD_1;
9
10
gen32_idx = find(mpc.gen(:, GEN_BUS) == 32);
11
pmax0_gen32 = mpc.gen(gen32_idx, PMAX);
12
assert(all(gen_PMAX_32 <= pmax0_gen32));
13
mpc.gen(gen32_idx, PMAX) = gen_PMAX_32;
14
15
branch_idx_2_25 = find( ...
16
(mpc.branch(:, F_BUS) == 2
& mpc.branch(:, T_BUS) == 25) | ...
17
(mpc.branch(:, F_BUS) == 25 & mpc.branch(:, T_BUS) == 2) );
18
x0_2_25 = mpc.branch(branch_idx_2_25, BR_X);
19
assert(all(branch_BR_X_2_25 >= x0_2_25));
20
mpc.branch(branch_idx_2_25, BR_X) = branch_BR_X_2_25;
21
22
mpopt = mpoption(‚Äôopf.violation‚Äô, 1e-8, ‚Äômodel‚Äô, ‚ÄôDC‚Äô, ‚Äôopf.dc.solver‚Äô, ‚ÄôIPOPT‚Äô);
23
24
beta = 10;
25
26
om = opf_setup(mpc, mpopt);
27
28
nb = size(mpc.bus, 1);
29
br_on = find(mpc.branch(:, BR_STATUS) == 1);
30
nl = length(br_on);
31
32
f = mpc.branch(br_on, F_BUS);
33
t = mpc.branch(br_on, T_BUS);
34
35
E = sparse(1:nl, f,
1, nl, nb) + sparse(1:nl, t, -1, nl, nb);
36
37
Q_va = 2 * beta * (E‚Äô * E);
38
om = om.add_quad_cost(‚Äôang_diff_pen‚Äô, Q_va, [], 0, {‚ÄôVa‚Äô});
39
40
idx_i1 = om.var.idx.i1;
41
idx_iN = om.var.idx.iN;
42
43
[x, fval, eflag, Àú, Àú] = om.solve();
44
45
Va_solution = x(idx_i1.Va:idx_iN.Va);
46
Pg_solution = x(idx_i1.Pg:idx_iN.Pg);
47
48
results = mpc;
32


--- Page 33 ---
Title Suppressed Due to Excessive Size
49
results.bus(:, VA) = Va_solution * 180/pi;
50
results.gen(:, PG) = Pg_solution;
51
results.f = fval;
52
results.success = (eflag > 0);
53
54
printpf(results);
55
end
Part 4: Synthesis Instructions (œÑ L4)
The synthesis instruction œÑ L4 guides the LLM to generate scenario-based natural language descriptions P and parameterized MATPOWER
implementations I that combine structural modifications with semantic parameter inference. This represents the most complex level,
requiring both narrative composition from scenario fragments and advanced structural extension implementation with placeholder-based
parameterization.
Task: You are an expert power systems engineer specializing in optimal power flow (OPF) modeling with advanced structural
extensions and scenario-based parameter inference. Your task is to generate a scenario-based natural language description and a
parameterized MATPOWER function for an OPF problem that includes both structural modifications and parameter modifications
inferred from operational scenarios (without explicit numerical values).
Input Format: A JSON object containing the following components:
‚Ä¢ base system: The base power system specification (e.g., MATPOWER case file identifier or system data structure).
‚Ä¢ scenario fragments: A list of scenario descriptions that encode parameter modification directions without explicit numerical
values. Each fragment describes an operational condition or event (e.g., weather conditions, equipment failures, demand
changes) that implies specific parameter modifications (e.g., increased load, reduced generator capacity, degraded line
parameters).
‚Ä¢ structural modification: A specification of structural changes to the OPF problem formulation, which may include:
‚Äì Problem Type Changes: Modifications to the fundamental problem formulation that alter the decision variable space or
reformulate the problem structure, such as switching between different OPF variants (e.g., "ACOPF", "DCOPF", "ED",
"UC", "OTS").
‚Äì Objective Function Extensions: Additions or modifications to the objective function beyond the standard cost minimiza-
tion, such as quadratic penalties on specific decision variables, linear terms, or custom cost functions that incorporate
additional system considerations.
‚Äì Constraint Modifications: Additions, modifications, or relaxations of constraints beyond the standard OPF con-
straints, including custom equality or inequality constraints that capture additional operational requirements or system
characteristics.
The structural modification component should specify the type of structural change, the mathematical form of the modification
(e.g., quadratic penalty terms, linear constraints), the decision variables involved, and any relevant parameters or coefficients.
‚Ä¢ solving requirements: Solver configuration and solution requirements (e.g., solver type, tolerance settings, output format
specifications).
Structural Modification Design Principles:
‚Ä¢ Problem Type Changes: Structural modifications that alter the fundamental mathematical model (e.g., linearization assump-
tions, variable elimination, constraint relaxation) require corresponding changes in the optimization framework configuration
and variable space definition.
‚Ä¢ Objective Function Extensions: Custom objective terms should be mathematically well-defined and compatible with the
underlying optimization framework, maintaining convexity properties when required and ensuring proper integration with
existing cost functions.
‚Ä¢ Constraint Extensions: Additional constraints must be formulated in a manner consistent with the optimization model
structure, properly indexing decision variables and maintaining feasibility of the solution space.
‚Ä¢ Implementation Considerations: The implementation should follow the optimization framework‚Äôs standard patterns for model
construction, variable definition, constraint addition, and solution extraction, ensuring compatibility with the framework‚Äôs
internal mechanisms. Parameter modifications inferred from scenarios should be implemented using placeholder variables that
can be instantiated with specific values during function invocation.
Output Requirements:
33


--- Page 34 ---
Title Suppressed Due to Excessive Size
1. Natural Language Description: Compose the scenario fragments into a coherent, professional narrative that:
‚Ä¢ Integrates all scenario fragments into a unified operational scenario
‚Ä¢ Uses natural, scenario-based language without explicitly stating parameter names or modification directions
‚Ä¢ Explicitly describes the structural modification (e.g., ‚Äùformulate a DC optimal power flow...‚Äù, ‚Äùadd a quadratic penalty
on...‚Äù)
‚Ä¢ Includes a statement that scenario-driven parameters use placeholder values of the form object parameter id
‚Ä¢ Specifies solver requirements and requests MATPOWER code generation
2. MATPOWER Code: Generate a MATLAB function that:
‚Ä¢ Accepts placeholder variables as function parameters (naming convention: object parameter id)
‚Ä¢ Loads the base system
‚Ä¢ For each parameter modification, retrieves the original value, adds an assertion to validate the modification direction, and
applies the placeholder parameter value
‚Ä¢ Configures solver options including model type if structural modification specifies a problem type change
‚Ä¢ Uses opf setup() to create an optimization model object
‚Ä¢ Implements structural modifications using om.add quad cost() or other appropriate methods
‚Ä¢ Solves using om.solve(), extracts solution components, and constructs the results structure
Example:
Input Scenario Fragments and Structural Modification:
{
"base system": "case39",
"scenario_fragments": [
"Extreme summer heatwave + Increased electrical demand",
"High ambient temperature + Generator derating",
"Fault-triggered outage + Degraded power transfer capability"
],
"structural modification":
{
"problem": "DCOPF",
"objective_modification": {
"op": "add",
"name": "angle_difference_penalty",
"beta": 10,
"form": "beta * ||E*Va||_2ÀÜ2"
}
},
"solving requirements": {
"opf violation": 1e-8,
"solver": "IPOPT"
}
}
Expected Natural Language Output: A regional grid is modeled using the IEEE 39-bus system (case39). During an extreme
summer heatwave, widespread air-conditioning usage sharply increases the demand around bus 1. High ambient temperature
forces the generator(s) connected to bus 32 to operate in a derated mode, reducing their deliverable output capacity. In addition,
a fault-triggered outage of local compensation equipment on the corridor between bus 2 and bus 25 degrades power transfer
capability along that path. To discourage excessive phase separation under stressed operation, formulate a DC optimal power
flow (DCOPF) and add a quadratic penalty on phase-angle differences across all in-service transmission lines with penalty weight
beta = 10. Set opf.violation to 1e-8, use IPOPT as the DCOPF solver, and generate the corresponding MATPOWER code. All
scenario-driven parameters are assigned using placeholder values of the form object parameter id, which represent post-modification
values consistent with the specified scenario directions.
Expected MATPOWER Code Output:
1
function results = opf_case39_sc(bus_PD_1, gen_PMAX_32, branch_BR_X_2_25)
2
define_constants;
3
mpc = loadcase(‚Äôcase39‚Äô);
4
5
bus1_idx = find(mpc.bus(:, BUS_I) == 1);
6
pd0_bus1 = mpc.bus(bus1_idx, PD);
7
assert(bus_PD_1 >= pd0_bus1);
34


--- Page 35 ---
Title Suppressed Due to Excessive Size
8
mpc.bus(bus1_idx, PD) = bus_PD_1;
9
10
gen32_idx = find(mpc.gen(:, GEN_BUS) == 32);
11
pmax0_gen32 = mpc.gen(gen32_idx, PMAX);
12
assert(all(gen_PMAX_32 <= pmax0_gen32));
13
mpc.gen(gen32_idx, PMAX) = gen_PMAX_32;
14
15
branch_idx_2_25 = find( ...
16
(mpc.branch(:, F_BUS) == 2
& mpc.branch(:, T_BUS) == 25) | ...
17
(mpc.branch(:, F_BUS) == 25 & mpc.branch(:, T_BUS) == 2) );
18
x0_2_25 = mpc.branch(branch_idx_2_25, BR_X);
19
assert(all(branch_BR_X_2_25 >= x0_2_25));
20
mpc.branch(branch_idx_2_25, BR_X) = branch_BR_X_2_25;
21
22
mpopt = mpoption(‚Äôopf.violation‚Äô, 1e-8, ‚Äômodel‚Äô, ‚ÄôDC‚Äô, ‚Äôopf.dc.solver‚Äô, ‚ÄôIPOPT‚Äô
);
23
24
beta = 10;
25
26
om = opf_setup(mpc, mpopt);
27
28
nb = size(mpc.bus, 1);
29
br_on = find(mpc.branch(:, BR_STATUS) == 1);
30
nl = length(br_on);
31
32
f = mpc.branch(br_on, F_BUS);
33
t = mpc.branch(br_on, T_BUS);
34
35
E = sparse(1:nl, f,
1, nl, nb) + sparse(1:nl, t, -1, nl, nb);
36
37
Q_va = 2 * beta * (E‚Äô * E);
38
om = om.add_quad_cost(‚Äôang_diff_pen‚Äô, Q_va, [], 0, {‚ÄôVa‚Äô});
39
40
idx_i1 = om.var.idx.i1;
41
idx_iN = om.var.idx.iN;
42
43
[x, fval, eflag, Àú, Àú] = om.solve();
44
45
Va_solution = x(idx_i1.Va:idx_iN.Va);
46
Pg_solution = x(idx_i1.Pg:idx_iN.Pg);
47
48
results = mpc;
49
results.bus(:, VA) = Va_solution * 180/pi;
50
results.gen(:, PG) = Pg_solution;
51
results.f = fval;
52
results.success = (eflag > 0);
53
54
printpf(results);
55
end
35


--- Page 36 ---
Title Suppressed Due to Excessive Size
E. Sample Examples and Evaluation Prompts for ProOPF-B
E.1. Evaluation Level 1 Sample in ProOPF-B
This section presents a complete Level 1 sample from ProOPF-B, including the natural language description, executable MATPOWER
code, ground-truth execution results, and evaluation prompts for both zero-shot and few-shot settings.
Part 1: Natural Language (P)
The NL description provides explicit instructions with specific numerical values for parameter modifications.
Perform AC optimal power flow (ACOPF) on the IEEE 39-bus system (case39). Scale the active power demand at bus 1 by a
factor of 1.5. Set the maximum active power output of all generators at bus 32 to 500 MW. Relax the minimum voltage magnitude
constraint at bus 10 by setting VMIN to 0. Set the branch reactance for the line between bus 2 and bus 25 to 0.01. Set the OPF
violation tolerance (opf.violation) to 1e-8, and write the corresponding MATPOWER code.
Part 2: MATPOWER Code (I)
The generated code implements the specified modifications and solves the OPF problem.
1
define_constants;
2
mpc = loadcase(‚Äôcase39‚Äô);
3
4
bus1_idx = find(mpc.bus(:, BUS_I) == 1);
5
mpc.bus(bus1_idx, PD) = mpc.bus(bus1_idx, PD) * 1.5;
6
7
gen32_idx = find(mpc.gen(:, GEN_BUS) == 32);
8
mpc.gen(gen32_idx, PMAX) = 500;
9
10
bus10_idx = find(mpc.bus(:, BUS_I) == 10);
11
mpc.bus(bus10_idx, VMIN) = 0;
12
13
branch_idx = find( ...
14
(mpc.branch(:, F_BUS) == 2
& mpc.branch(:, T_BUS) == 25) | ...
15
(mpc.branch(:, F_BUS) == 25 & mpc.branch(:, T_BUS) == 2) );
16
mpc.branch(branch_idx, BR_X) = 0.01;
17
18
mpopt = mpoption(‚Äôopf.violation‚Äô, 1e-8);
19
results = runopf(mpc, mpopt);
20
printpf(results);
Part 3: Ground-Truth Execution Results
The ground-truth results are obtained by executing the MATPOWER code, providing reference values for correctness verification.
{
"converged": true,
"objective_value": 43009.10379295345,
"execution_time": 1.973813,
"error_message": null
}
Part 4: Zero-Shot Evaluation Prompt
The zero-shot prompt provides task instructions without examples, testing the LLM‚Äôs ability to generate OPF code from natural language
descriptions.
Task: You are an expert power systems engineer specializing in optimal power flow (OPF) modeling. Your task is to generate
executable MATPOWER code for an OPF problem based on the provided natural language description. The code must be
syntactically correct and executable.
Input: A natural language description specifying:
‚Ä¢ The base power system (e.g., IEEE case file)
‚Ä¢ Parameter modifications with explicit numerical values (e.g., scale demand at bus X by factor Y, set generator limit at bus Z to
W MW)
36


--- Page 37 ---
Title Suppressed Due to Excessive Size
‚Ä¢ Structural modifications (if any)
‚Ä¢ Solver configuration requirements (e.g., violation tolerance, solver selection)
Output Requirements:
1. Load the base system using loadcase()
2. Apply all parameter modifications using appropriate MATPOWER indexing
3. Configure solver options via mpoption()
4. Execute OPF via runopf()
5. Include printpf() to display results
Example Input: Perform AC optimal power flow (ACOPF) on the IEEE 39-bus system (case39). Scale the active power demand at
bus 1 by a factor of 1.5. Set the maximum active power output of all generators at bus 32 to 500 MW. Relax the minimum voltage
magnitude constraint at bus 10 by setting VMIN to 0. Set the branch reactance (BR X) for the line between bus 2 and bus 25 to 0.01.
Set the OPF violation tolerance (opf.violation) to 1e-8, and write the corresponding MATPOWER code.
Expected Output Format: Generate executable MATLAB code that implements the specified modifications and solves the OPF
problem.
Part 5: Few-Shot Evaluation Prompt
The few-shot prompt includes in-context examples to guide the LLM‚Äôs code generation, demonstrating the expected input-output mapping.
Task: You are an expert power systems engineer specializing in optimal power flow (OPF) modeling. Your task is to generate
executable MATPOWER code for an OPF problem based on the provided natural language description. The code must be
syntactically correct and executable.
Input Format: A natural language description specifying the base power system, parameter modifications with explicit numerical
values, structural modifications (if any), and solver configuration requirements.
Output Requirements:
1. Load the base system using loadcase()
2. Apply all parameter modifications using appropriate MATPOWER indexing
3. Configure solver options via mpoption()
4. Execute OPF via runopf()
5. Include printpf() to display results
Example 1:
Input: Perform AC optimal power flow (ACOPF) on the IEEE 14-bus system (case14). Scale the active power demand at bus 2
by a factor of 1.2. Set the maximum active power output of all generators at bus 1 to 300 MW. Set the OPF violation tolerance
(opf.violation) to 1e-6, and write the corresponding MATPOWER code.
Output:
1
define_constants;
2
mpc = loadcase(‚Äôcase14‚Äô);
3
4
bus2_idx = find(mpc.bus(:, BUS_I) == 2);
5
mpc.bus(bus2_idx, PD) = mpc.bus(bus2_idx, PD) * 1.2;
6
7
gen1_idx = find(mpc.gen(:, GEN_BUS) == 1);
8
mpc.gen(gen1_idx, PMAX) = 300;
9
10
mpopt = mpoption(‚Äôopf.violation‚Äô, 1e-6);
11
results = runopf(mpc, mpopt);
12
printpf(results);
Example 2:
Input: Perform AC optimal power flow (ACOPF) on the IEEE 30-bus system (case30). Set the active power demand at bus 5 to 100
MW. Set the minimum voltage magnitude constraint at bus 8 to 0.95. Set the branch reactance for the line between bus 1 and bus 2
to 0.05. Set the OPF violation tolerance (opf.violation) to 1e-8, and write the corresponding MATPOWER code.
37


--- Page 38 ---
Title Suppressed Due to Excessive Size
Output:
1
define_constants;
2
mpc = loadcase(‚Äôcase30‚Äô);
3
4
bus5_idx = find(mpc.bus(:, BUS_I) == 5);
5
mpc.bus(bus5_idx, PD) = 100;
6
7
bus8_idx = find(mpc.bus(:, BUS_I) == 8);
8
mpc.bus(bus8_idx, VMIN) = 0.95;
9
10
branch_idx = find( ...
11
(mpc.branch(:, F_BUS) == 1
& mpc.branch(:, T_BUS) == 2) | ...
12
(mpc.branch(:, F_BUS) == 2 & mpc.branch(:, T_BUS) == 1) );
13
mpc.branch(branch_idx, BR_X) = 0.05;
14
15
mpopt = mpoption(‚Äôopf.violation‚Äô, 1e-8);
16
results = runopf(mpc, mpopt);
17
printpf(results);
Now, generate the code for the following input:
Perform AC optimal power flow (ACOPF) on the IEEE 39-bus system (case39). Scale the active power demand at bus 1 by a
factor of 1.5. Set the maximum active power output of all generators at bus 32 to 500 MW. Relax the minimum voltage magnitude
constraint at bus 10 by setting VMIN to 0. Set the branch reactance for the line between bus 2 and bus 25 to 0.01. Set the OPF
violation tolerance (opf.violation) to 1e-8, and write the corresponding MATPOWER code.
E.2. Evaluation Level 2 Sample in ProOPF-B
This section presents a complete Level 2 sample from ProOPF-B, including the scenario-based natural language description, parameterized
MATPOWER function code, ground-truth execution results for multiple parameter instantiation strategies, and evaluation prompts for
both zero-shot and few-shot settings.
Part 1: Natural Language (P)
The NL description uses scenario-based narratives to describe parameter changes, requiring inference of modification directions rather
than explicit values.
A regional grid is modeled using the IEEE 14-bus system (case14). During the late-night hours, industrial loads at bus 3 are
significantly reduced, causing both active and reactive power demand to decrease substantially. The long-distance transmission
lines exhibit pronounced capacitive charging effects, leading to elevated voltage levels at bus 8. To mitigate the risk of voltage
exceeding the upper limit, shunt capacitor banks at bus 5 need to be disconnected. Meanwhile, the reduced reactive power demand
at bus 3 further contributes to the voltage rise phenomenon. Set opf.violation to 1e-6, use MIPS as the ACOPF solver, and
generate the corresponding MATPOWER code. All scenario-driven parameters are assigned using placeholder values of the form
object parameter id, which represent the post-modification values consistent with the specified scenario directions.
Part 2: MATPOWER Code (I)
The generated code is structured as a function that accepts placeholder variables as parameters and includes assertion checks to validate
direction constraints.
1
function results = opf_case14(bus_PD_3, bus_QD_3, bus_VMAX_8, bus_BS_5)
2
define_constants;
3
mpc = loadcase(‚Äôcase14‚Äô);
4
5
bus3_idx = find(mpc.bus(:, BUS_I) == 3);
6
pd0_bus3 = mpc.bus(bus3_idx, PD);
7
assert(bus_PD_3 <= pd0_bus3);
8
mpc.bus(bus3_idx, PD) = bus_PD_3;
9
10
qd0_bus3 = mpc.bus(bus3_idx, QD);
11
assert(bus_QD_3 <= qd0_bus3);
12
mpc.bus(bus3_idx, QD) = bus_QD_3;
13
14
bus8_idx = find(mpc.bus(:, BUS_I) == 8);
38


--- Page 39 ---
Title Suppressed Due to Excessive Size
15
vmax0_bus8 = mpc.bus(bus8_idx, VMAX);
16
assert(bus_VMAX_8 >= vmax0_bus8);
17
mpc.bus(bus8_idx, VMAX) = bus_VMAX_8;
18
19
bus5_idx = find(mpc.bus(:, BUS_I) == 5);
20
assert(bus_BS_5 == 0);
21
mpc.bus(bus5_idx, BS) = bus_BS_5;
22
23
mpopt = mpoption(‚Äôopf.violation‚Äô, 1e-6, ‚Äôopf.ac.solver‚Äô, ‚ÄôMIPS‚Äô);
24
results = runopf(mpc, mpopt);
25
printpf(results);
26
end
Part 3: Ground-Truth Execution Results
The ground-truth results are obtained by executing the parameterized function with different parameter instantiation strategies, providing
reference values for correctness verification. Strategy 1 and Strategy 2 represent different parameter value assignments consistent with the
scenario directions.
Strategy 1 Parameter Values:
{
"bus_PD_3": 89.49,
"bus_QD_3": 18.05,
"bus_VMAX_8": 1.113,
"bus_BS_5": 0.0
}
Strategy 1 Execution Results:
{
"converged": true,
"objective_value": 7889.236964788632,
"execution_time": 0.915973,
"error_message": null
}
Strategy 2 Parameter Values:
{
"bus_PD_3": 84.78,
"bus_QD_3": 17.1,
"bus_VMAX_8": 1.166,
"bus_BS_5": 0.0
}
Strategy 2 Execution Results:
{
"converged": true,
"objective_value": 7698.5847023253245,
"execution_time": 0.737384,
"error_message": null
}
Part 4: Zero-Shot Evaluation Prompt
The zero-shot prompt provides task instructions without examples, testing the LLM‚Äôs ability to generate parameterized OPF functions
from scenario-based natural language descriptions.
Task: You are an expert power systems engineer specializing in optimal power flow (OPF) modeling. Your task is to generate a
parameterized MATPOWER function for an OPF problem based on the provided scenario-based natural language description. The
function must accept placeholder variables as parameters and include assertion checks to validate modification direction constraints.
Input: A scenario-based natural language description specifying:
39


--- Page 40 ---
Title Suppressed Due to Excessive Size
‚Ä¢ The base power system (e.g., IEEE case file)
‚Ä¢ Operational scenarios that imply parameter modification directions (e.g., ‚Äùdemand decreases‚Äù, ‚Äùvoltage rises‚Äù, ‚Äùcapacitor banks
disconnected‚Äù)
‚Ä¢ Structural modifications (if any)
‚Ä¢ Solver configuration requirements (e.g., violation tolerance, solver selection)
‚Ä¢ A statement indicating that scenario-driven parameters use placeholder values of the form object parameter id
Output Requirements:
1. Generate a MATLAB function that accepts placeholder variables as function parameters (naming convention:
ob-
ject parameter id, e.g., bus PD 3, bus VMAX 8)
2. Load the base system using loadcase()
3. For each parameter modification implied by the scenario:
‚Ä¢ Retrieve the original value from the base system
‚Ä¢ Add an assertion to validate the modification direction:
‚Äì For ‚Äùdecrease‚Äù scenarios: assert(new value <= original value)
‚Äì For ‚Äùincrease‚Äù scenarios: assert(new value >= original value)
‚Äì For ‚Äùset zero‚Äù scenarios: assert(new value == 0)
‚Ä¢ Apply the placeholder parameter value to the model
4. Configure solver options via mpoption() including solver specification if provided
5. Execute OPF via runopf()
Example Input: A regional grid is modeled using the IEEE 14-bus system (case14). During the late-night hours, industrial loads
at bus 3 are significantly reduced, causing both active and reactive power demand to decrease substantially. The long-distance
transmission lines exhibit pronounced capacitive charging effects, leading to elevated voltage levels at bus 8. To mitigate the risk of
voltage exceeding the upper limit, shunt capacitor banks at bus 5 need to be disconnected. Meanwhile, the reduced reactive power
demand at bus 3 further contributes to the voltage rise phenomenon. Set opf.violation to 1e-6, use MIPS as the ACOPF solver, and
generate the corresponding MATPOWER code. All scenario-driven parameters are assigned using placeholder values of the form
object parameter id, which represent the post-modification values consistent with the specified scenario directions.
Expected Output Format: Generate a MATLAB function that implements the scenario-based modifications with appropriate
assertion checks for direction validation.
Part 5: Few-Shot Evaluation Prompt
The few-shot prompt includes in-context examples to guide the LLM‚Äôs function generation, demonstrating the expected input-output
mapping for scenario-based parameter inference.
Task: You are an expert power systems engineer specializing in optimal power flow (OPF) modeling. Your task is to generate a
parameterized MATPOWER function for an OPF problem based on the provided scenario-based natural language description. The
function must accept placeholder variables as parameters and include assertion checks to validate modification direction constraints.
Input Format: A scenario-based natural language description specifying the base power system, operational scenarios that imply
parameter modification directions, structural modifications (if any), solver configuration requirements, and a statement about
placeholder parameter values.
Output Requirements:
1. Generate a MATLAB function that accepts placeholder variables as function parameters (naming convention:
ob-
ject parameter id)
2. Load the base system using loadcase()
3. For each parameter modification, retrieve the original value, add direction validation assertions, and apply the placeholder
parameter value
4. Configure solver options via mpoption() including solver specification if provided
5. Execute OPF via runopf()
40


--- Page 41 ---
Title Suppressed Due to Excessive Size
Example 1:
Input: A regional grid is modeled using the IEEE 14-bus system (case14). During peak demand hours, the electrical load at bus 2
increases significantly due to commercial activity. Meanwhile, generator maintenance at bus 1 reduces the available generation
capacity. Set opf.violation to 1e-6, use MIPS as the ACOPF solver, and generate the corresponding MATPOWER code. All scenario-
driven parameters are assigned using placeholder values of the form object parameter id, which represent the post-modification
values consistent with the specified scenario directions.
Output:
1
function results = opf_case14(bus_PD_2, gen_PMAX_1)
2
define_constants;
3
mpc = loadcase(‚Äôcase14‚Äô);
4
5
bus2_idx = find(mpc.bus(:, BUS_I) == 2);
6
pd0_bus2 = mpc.bus(bus2_idx, PD);
7
assert(bus_PD_2 >= pd0_bus2);
8
mpc.bus(bus2_idx, PD) = bus_PD_2;
9
10
gen1_idx = find(mpc.gen(:, GEN_BUS) == 1);
11
pmax0_gen1 = mpc.gen(gen1_idx, PMAX);
12
assert(all(gen_PMAX_1 <= pmax0_gen1));
13
mpc.gen(gen1_idx, PMAX) = gen_PMAX_1;
14
15
mpopt = mpoption(‚Äôopf.violation‚Äô, 1e-6, ‚Äôopf.ac.solver‚Äô, ‚ÄôMIPS‚Äô);
16
results = runopf(mpc, mpopt);
17
printpf(results);
18
end
Example 2:
Input: A regional grid is modeled using the IEEE 30-bus system (case30). During a scheduled maintenance period, industrial
facilities at bus 5 completely shut down, eliminating all power demand. High reactive power injection from renewable sources causes
voltage to rise at bus 12, requiring adjustment of the maximum voltage limit. Set opf.violation to 1e-8, use IPOPT as the ACOPF
solver, and generate the corresponding MATPOWER code. All scenario-driven parameters are assigned using placeholder values of
the form object parameter id, which represent the post-modification values consistent with the specified scenario directions.
Output:
1
function results = opf_case30(bus_PD_5, bus_VMAX_12)
2
define_constants;
3
mpc = loadcase(‚Äôcase30‚Äô);
4
5
bus5_idx = find(mpc.bus(:, BUS_I) == 5);
6
assert(bus_PD_5 == 0);
7
mpc.bus(bus5_idx, PD) = bus_PD_5;
8
9
bus12_idx = find(mpc.bus(:, BUS_I) == 12);
10
vmax0_bus12 = mpc.bus(bus12_idx, VMAX);
11
assert(bus_VMAX_12 >= vmax0_bus12);
12
mpc.bus(bus12_idx, VMAX) = bus_VMAX_12;
13
14
mpopt = mpoption(‚Äôopf.violation‚Äô, 1e-8, ‚Äôopf.ac.solver‚Äô, ‚ÄôIPOPT‚Äô);
15
results = runopf(mpc, mpopt);
16
printpf(results);
17
end
Now, generate the code for the following input:
A regional grid is modeled using the IEEE 14-bus system (case14). During the late-night hours, industrial loads at bus 3 are
significantly reduced, causing both active and reactive power demand to decrease substantially. The long-distance transmission
lines exhibit pronounced capacitive charging effects, leading to elevated voltage levels at bus 8. To mitigate the risk of voltage
exceeding the upper limit, shunt capacitor banks at bus 5 need to be disconnected. Meanwhile, the reduced reactive power demand
at bus 3 further contributes to the voltage rise phenomenon. Set opf.violation to 1e-6, use MIPS as the ACOPF solver, and
generate the corresponding MATPOWER code. All scenario-driven parameters are assigned using placeholder values of the form
object parameter id, which represent the post-modification values consistent with the specified scenario directions.
41


--- Page 42 ---
Title Suppressed Due to Excessive Size
E.3. Evaluation Level 3 Sample in ProOPF-B
This section presents a complete Level 3 sample from ProOPF-B, including the natural language description with structural modifications,
executable MATPOWER code implementing structural extensions, ground-truth execution results, and evaluation prompts for both
zero-shot and few-shot settings.
Part 1: Natural Language (P)
The NL description includes structural modifications (problem type change and custom objective function) along with explicit parameter
specifications.
Build a DC optimal power flow (DCOPF) optimization problem for the IEEE 39-bus system (case39). In addition to the default
generation cost in the base case, add a quadratic penalty on phase-angle differences across all in-service transmission lines to
discourage excessive angle separation (penalty weight beta = 10). Scale the active power demand at bus 1 by 1.5, set the maximum
active power output of the generator(s) connected to bus 32 to 500 MW, and set the branch reactance of the line between bus 2 and
bus 25 to 0.01. Assign opf.violation to 1e-8, and create the corresponding MATPOWER code.
Part 2: MATPOWER Code (I)
The generated code implements structural modifications using advanced OPF setup with custom objective function.
1
define_constants;
2
mpc = loadcase(‚Äôcase39‚Äô);
3
4
bus1_idx = find(mpc.bus(:, BUS_I) == 1);
5
mpc.bus(bus1_idx, PD) = mpc.bus(bus1_idx, PD) * 1.5;
6
7
gen32_idx = find(mpc.gen(:, GEN_BUS) == 32);
8
mpc.gen(gen32_idx, PMAX) = 500;
9
10
branch_idx_2_25 = find( ...
11
(mpc.branch(:, F_BUS) == 2
& mpc.branch(:, T_BUS) == 25) | ...
12
(mpc.branch(:, F_BUS) == 25 & mpc.branch(:, T_BUS) == 2) );
13
mpc.branch(branch_idx_2_25, BR_X) = 0.01;
14
15
mpopt = mpoption(‚Äôopf.violation‚Äô, 1e-8, ‚Äômodel‚Äô, ‚ÄôDC‚Äô);
16
17
beta = 10;
18
19
om = opf_setup(mpc, mpopt);
20
21
nb = size(mpc.bus, 1);
22
br_on = find(mpc.branch(:, BR_STATUS) == 1);
23
nl = length(br_on);
24
25
f = mpc.branch(br_on, F_BUS);
26
t = mpc.branch(br_on, T_BUS);
27
28
E = sparse(1:nl, f,
1, nl, nb) + sparse(1:nl, t, -1, nl, nb);
29
30
Q_va = 2 * beta * (E‚Äô * E);
31
om = om.add_quad_cost(‚Äôang_diff_pen‚Äô, Q_va, [], 0, {‚ÄôVa‚Äô});
32
33
idx_i1 = om.var.idx.i1;
34
idx_iN = om.var.idx.iN;
35
36
[x, fval, eflag, Àú, Àú] = om.solve();
37
38
Va_solution = x(idx_i1.Va:idx_iN.Va);
39
Pg_solution = x(idx_i1.Pg:idx_iN.Pg);
40
41
results = mpc;
42
results.bus(:, VA) = Va_solution * 180/pi;
43
results.gen(:, PG) = Pg_solution;
44
results.f = fval;
45
results.success = (eflag > 0);
42


--- Page 43 ---
Title Suppressed Due to Excessive Size
Part 3: Ground-Truth Execution Results
The ground-truth results are obtained by executing the MATPOWER code with structural modifications, providing reference values for
correctness verification.
{
"converged": true,
"objective_value": 42306.19654969372,
"execution_time": 17.461786,
"error_message": null
}
Part 4: Zero-Shot Evaluation Prompt
The zero-shot prompt provides task instructions without examples, testing the LLM‚Äôs ability to generate OPF code with structural
modifications from natural language descriptions.
Task: You are an expert power systems engineer specializing in optimal power flow (OPF) modeling with advanced structural
extensions. Your task is to generate executable MATPOWER code for an OPF problem that includes both structural modifications
(problem type changes, objective function extensions, or constraint additions) and explicit parameter modifications with numerical
values.
Input: A natural language description specifying:
‚Ä¢ The base power system (e.g., IEEE case file)
‚Ä¢ Structural modifications:
‚Äì Problem type changes (e.g., DCOPF, ACOPF)
‚Äì Objective function extensions (e.g., quadratic penalties on decision variables)
‚Äì Constraint modifications (e.g., additional operational constraints)
‚Ä¢ Parameter modifications with explicit numerical values (e.g., scale demand at bus X by factor Y, set generator limit at bus Z to
W MW)
‚Ä¢ Solver configuration requirements (e.g., violation tolerance, solver selection)
Output Requirements:
1. Load the base system using loadcase()
2. Apply all parameter modifications using appropriate MATPOWER indexing
3. Configure solver options via mpoption() including model type if structural modification specifies a problem type change
4. Use opf setup() to create an optimization model object
5. Implement structural modifications:
‚Ä¢ For objective extensions:
Construct the quadratic cost matrix Q based on the specified form, then use
om.add quad cost() to add the term
‚Ä¢ For constraint extensions: Use appropriate constraint addition methods
6. Solve using om.solve() and extract solution components
7. Construct a results structure with solution values
Example Input: Build a DC optimal power flow (DCOPF) optimization problem for the IEEE 39-bus system (case39). In addition
to the default generation cost in the base case, add a quadratic penalty on phase-angle differences across all in-service transmission
lines to discourage excessive angle separation (penalty weight beta = 10). Scale the active power demand at bus 1 by 1.5, set the
maximum active power output of the generator(s) connected to bus 32 to 500 MW, and set the branch reactance of the line between
bus 2 and bus 25 to 0.01. Assign opf.violation to 1e-8, and create the corresponding MATPOWER code.
Expected Output Format: Generate executable MATLAB code that implements the structural modifications and parameter
modifications, using opf setup() and om.add quad cost() for objective extensions.
Part 5: Few-Shot Evaluation Prompt
43


--- Page 44 ---
Title Suppressed Due to Excessive Size
The few-shot prompt includes in-context examples to guide the LLM‚Äôs code generation, demonstrating the expected input-output mapping
for problems with structural modifications.
Task: You are an expert power systems engineer specializing in optimal power flow (OPF) modeling with advanced structural
extensions. Your task is to generate executable MATPOWER code for an OPF problem that includes both structural modifications
and explicit parameter modifications with numerical values.
Input Format: A natural language description specifying the base power system, structural modifications (problem type changes, ob-
jective function extensions, or constraint additions), parameter modifications with explicit numerical values, and solver configuration
requirements.
Output Requirements:
1. Load the base system and apply explicit parameter modifications
2. Configure solver options including model type if structural modification specifies a problem type change
3. Use opf setup() to create an optimization model object
4. Implement structural modifications using appropriate methods (e.g., om.add quad cost() for objective extensions)
5. Solve using om.solve() and extract solution components
6. Construct a results structure with solution values
Example 1:
Input: Formulate a DC optimal power flow (DCOPF) problem for the IEEE 14-bus system (case14). Add a quadratic penalty on
phase-angle differences across all in-service transmission lines with penalty weight beta = 5. Scale the active power demand at bus 2
by 1.2. Set opf.violation to 1e-6, and write the corresponding MATPOWER code.
Output:
1
define_constants;
2
mpc = loadcase(‚Äôcase14‚Äô);
3
4
bus2_idx = find(mpc.bus(:, BUS_I) == 2);
5
mpc.bus(bus2_idx, PD) = mpc.bus(bus2_idx, PD) * 1.2;
6
7
mpopt = mpoption(‚Äôopf.violation‚Äô, 1e-6, ‚Äômodel‚Äô, ‚ÄôDC‚Äô);
8
9
beta = 5;
10
11
om = opf_setup(mpc, mpopt);
12
13
nb = size(mpc.bus, 1);
14
br_on = find(mpc.branch(:, BR_STATUS) == 1);
15
nl = length(br_on);
16
17
f = mpc.branch(br_on, F_BUS);
18
t = mpc.branch(br_on, T_BUS);
19
20
E = sparse(1:nl, f,
1, nl, nb) + sparse(1:nl, t, -1, nl, nb);
21
22
Q_va = 2 * beta * (E‚Äô * E);
23
om = om.add_quad_cost(‚Äôang_diff_pen‚Äô, Q_va, [], 0, {‚ÄôVa‚Äô});
24
25
idx_i1 = om.var.idx.i1;
26
idx_iN = om.var.idx.iN;
27
28
[x, fval, eflag, Àú, Àú] = om.solve();
29
30
Va_solution = x(idx_i1.Va:idx_iN.Va);
31
Pg_solution = x(idx_i1.Pg:idx_iN.Pg);
32
33
results = mpc;
34
results.bus(:, VA) = Va_solution * 180/pi;
35
results.gen(:, PG) = Pg_solution;
36
results.f = fval;
37
results.success = (eflag > 0);
44


--- Page 45 ---
Title Suppressed Due to Excessive Size
Example 2:
Input: Build an AC optimal power flow (ACOPF) problem for the IEEE 30-bus system (case30). Add a quadratic penalty on
generator active power outputs with penalty weight gamma = 0.1. Set the active power demand at bus 5 to 100 MW. Set the minimum
voltage magnitude constraint at bus 8 to 0.95. Set opf.violation to 1e-8, and write the corresponding MATPOWER code.
Output:
1
define_constants;
2
mpc = loadcase(‚Äôcase30‚Äô);
3
4
bus5_idx = find(mpc.bus(:, BUS_I) == 5);
5
mpc.bus(bus5_idx, PD) = 100;
6
7
bus8_idx = find(mpc.bus(:, BUS_I) == 8);
8
mpc.bus(bus8_idx, VMIN) = 0.95;
9
10
mpopt = mpoption(‚Äôopf.violation‚Äô, 1e-8);
11
12
gamma = 0.1;
13
14
om = opf_setup(mpc, mpopt);
15
16
ng = size(mpc.gen, 1);
17
Q_pg = 2 * gamma * speye(ng);
18
om = om.add_quad_cost(‚Äôpg_penalty‚Äô, Q_pg, [], 0, {‚ÄôPg‚Äô});
19
20
idx_i1 = om.var.idx.i1;
21
idx_iN = om.var.idx.iN;
22
23
[x, fval, eflag, Àú, Àú] = om.solve();
24
25
Va_solution = x(idx_i1.Va:idx_iN.Va);
26
Vm_solution = x(idx_i1.Vm:idx_iN.Vm);
27
Pg_solution = x(idx_i1.Pg:idx_iN.Pg);
28
Qg_solution = x(idx_i1.Qg:idx_iN.Qg);
29
30
results = mpc;
31
results.bus(:, VA) = Va_solution * 180/pi;
32
results.bus(:, VM) = Vm_solution;
33
results.gen(:, PG) = Pg_solution;
34
results.gen(:, QG) = Qg_solution;
35
results.f = fval;
36
results.success = (eflag > 0);
Now, generate the code for the following input:
Build a DC optimal power flow (DCOPF) optimization problem for the IEEE 39-bus system (case39). In addition to the default
generation cost in the base case, add a quadratic penalty on phase-angle differences across all in-service transmission lines to
discourage excessive angle separation (penalty weight beta = 10). Scale the active power demand at bus 1 by 1.5, set the maximum
active power output of the generator(s) connected to bus 32 to 500 MW, and set the branch reactance of the line between bus 2 and
bus 25 to 0.01. Assign opf.violation to 1e-8, and create the corresponding MATPOWER code.
45


--- Page 46 ---
Title Suppressed Due to Excessive Size
F. Evaluation Workflow for ProOPF-B
F.1. Evaluation Workflow
Concrete OPF Modeling (Levels 1/3). For concrete modeling, the LLM generates a complete implementation bI that can be directly
executed to obtain c
f ‚àó, which is compared against the ground-truth f ‚àófor correctness verification.
Abstract OPF Modeling (Levels 2/4). For abstract modeling, the LLM generates a parameterized function bI(¬∑) that requires parameter
instantiation œÄ before execution. The generated implementation is validated by executing bI(œÄ) and comparing c
f ‚àó(œÄ) against the
ground-truth f ‚àó(œÄ) obtained from the expert-annotated implementation I(œÄ).
This distinction reflects the fundamental difference between explicit parameter specification and semantic parameter inference in OPF
modeling tasks, as illustrated in Figure 5.
Algorithm 6 Evaluation for Concrete OPF Modeling (Levels 1/3)
Require: Sample set Z = {zi}N
i=1 where zi = {Mi, Pi, Ii}, LLM model pLLM, instruction specification œÑ, tolerance
threshold œµ > 0 (a small positive number)
Ensure: Correctness rate r ‚àà[0, 1]
1: Initialize correct count: ctotal ‚Üê0
2: for i = 1 to N do
3:
Generate implementation from NL description: bIi ‚àºpLLM(¬∑ | Pi, œÑ)
4:
Execute generated implementation: c
f ‚àói ‚ÜêbIi()
5:
Execute ground-truth implementation: f ‚àó
i ‚ÜêIi()
6:
Check correctness: ci ‚Üê1[‚à•c
f ‚àói ‚àíf ‚àó
i ‚à•‚â§œµ]
7:
Update count: ctotal ‚Üêctotal + ci
8: end for
9: Compute correctness rate: r ‚Üêctotal/N
10: return r
Algorithm 7 Evaluation for Abstract OPF Modeling (Levels 2/4)
Require: Sample set Z = {zi}N
i=1 where zi = {Mi, Pi, Ii(¬∑), œÄi}, LLM model pLLM, instruction specification œÑ,
tolerance threshold œµ > 0 (a small positive number)
Ensure: Correctness rate r ‚àà[0, 1]
1: Initialize correct count: ctotal ‚Üê0
2: for i = 1 to N do
3:
Generate parameterized function from NL description: bIi(¬∑) ‚àºpLLM(¬∑ | Pi, œÑ)
4:
Execute generated function with parameters: c
f ‚àói(œÄi) ‚ÜêbIi(œÄi)
5:
Execute ground-truth function with parameters: f ‚àó
i (œÄi) ‚ÜêIi(œÄi)
6:
Check correctness: ci ‚Üê1[‚à•c
f ‚àói(œÄi) ‚àíf ‚àó
i (œÄi)‚à•‚â§œµ]
7:
Update count: ctotal ‚Üêctotal + ci
8: end for
9: Compute correctness rate: r ‚Üêctotal/N
10: return r
46


--- Page 47 ---
Title Suppressed Due to Excessive Size
NL Description
Parameters
NL Description
Parameters ùúã
Concrete
Implementation
LLM
LLM
Abstract Function
Infill
Explicit
Expression
Semantic
Inference
Scale the active power demand 
at bus 1 by a factor of 1.5.
During an extreme summer 
heatwave, widespread air-
conditioning usage sharply 
increases the electrical demand 
around bus 1.
Figure 5. Schematic comparison of evaluation workflows for concrete (Levels 1/3) and abstract (Levels 2/4) OPF modeling in ProOPF-B,
illustrating the key difference in validation procedures.
47


--- Page 48 ---
Title Suppressed Due to Excessive Size
G. Six-Dimensional Capability Analysis Framework
To provide deeper insights into the performance gaps among different models on ProOPF-B, we introduce a six-dimensional capability
analysis framework that decomposes model performance into fundamental competencies. These dimensions are designed to capture
distinct aspects of the OPF modeling task and explain why certain models excel or struggle on specific difficulty levels. The six dimensions
are defined as follows:
G.1. Dimension 1: Executable Rate
Definition: The average executable rate across all difficulty levels (Levels 1‚Äì4).
Calculation: For each level ‚Ñì‚àà{1, 2, 3, 4}, let E‚Ñìdenote the number of test cases that produce executable code (no syntax or runtime
errors before solver invocation), and T‚Ñìdenote the total number of test cases at level ‚Ñì. The executable rate is:
Executable Rate = 1
4
4
X
‚Ñì=1
E‚Ñì
T‚Ñì√ó 100%
(24)
Interpretation: This dimension measures the model‚Äôs ability to generate syntactically and semantically valid MATPOWER code that can
be executed without errors. A low executable rate indicates fundamental coding proficiency issues, such as incorrect API usage, invalid
syntax, or misunderstanding of the MATPOWER toolchain.
G.2. Dimension 2: Explicit Parameter Modification Correctness
Definition: The correctness rate on tasks requiring explicit parameter modifications (Levels 1 and 3).
Calculation: Let C1 and C3 denote the number of correct implementations at Levels 1 and 3, respectively. The explicit parameter
modification correctness is:
Explicit Param Mod = 1
2
C1
T1 + C3
T3

√ó 100%
(25)
Interpretation: This dimension evaluates the model‚Äôs ability to follow explicit numerical parameter specifications and apply them
correctly to the OPF model. High performance on this dimension indicates strong instruction-following capability for concrete parameter
assignments.
G.3. Dimension 3: Semantic Parameter Inference Correctness
Definition: The correctness rate on tasks requiring semantic parameter inference from natural language descriptions (Levels 2 and 4).
Calculation: Let C2 and C4 denote the number of correct implementations at Levels 2 and 4, respectively. The semantic parameter
inference correctness is:
Semantic Param Inf = 1
2
C2
T2 + C4
T4

√ó 100%
(26)
Interpretation: This dimension measures the model‚Äôs ability to infer appropriate numerical parameters from semantic descriptions (e.g.,
‚Äùreduce line capacity by 20%‚Äù or ‚Äùincrease load by a moderate amount‚Äù). This requires both natural language understanding and domain
knowledge about reasonable parameter ranges in power systems.
G.4. Dimension 4: Structural Modification Identification
Definition: The rate at which models correctly identify that structural modifications to the OPF formulation are required (Levels 3 and 4).
Calculation: Let S3 and S4 denote the number of implementations at Levels 3 and 4 where the model recognizes and attempts to
implement structural changes (e.g., adding new variables, modifying constraints, or introducing new objective terms), regardless of
execution success. The structural modification identification rate is:
Structural Mod = 1
2
S3
T3 + S4
T4

√ó 100%
(27)
where T3 and T4 are the total number of test cases at Levels 3 and 4.
Interpretation: This dimension measures the model‚Äôs ability to recognize when a task requires non-trivial structural extensions to the
base OPF formulation, such as adding new decision variables, modifying constraints, or introducing new objective terms, distinguishing it
from simple parameter modifications in Levels 1‚Äì2. A high score indicates the model understands what structural changes are needed,
even if implementation challenges prevent successful execution. This separates conceptual understanding from coding proficiency.
48


--- Page 49 ---
Title Suppressed Due to Excessive Size
G.5. Dimension 5: Resolution Specification Correctness
Definition: The rate at which models correctly configure the resolution specification R, including solver selection (e.g., MIPS, IPOPT,
KNITRO), convergence criteria (e.g., constraint violation tolerance opf violation), and output configuration settings.
Calculation: Let R‚Ñìdenote the number of implementations at level ‚Ñìwhere the resolution specification R is correctly configured (i.e., the
solver, convergence tolerance, and output settings match the requirements specified in the task). The resolution specification correctness
is:
Resolution Spec = 1
4
4
X
‚Ñì=1
R‚Ñì
T‚Ñì√ó 100%
(28)
where T‚Ñìdenotes the total number of test cases at level ‚Ñì.
Interpretation: This dimension measures the model‚Äôs ability to correctly interpret and implement the resolution specification R across
all difficulty levels. The resolution specification controls how the OPF problem is solved, including which optimization solver to use,
what convergence tolerance to apply, and how results should be reported. Since R is specified in every task regardless of difficulty level,
this dimension evaluates fundamental proficiency in translating solver requirements into correct MATPOWER API calls. A model may
generate executable code but still fail this dimension if it uses the wrong solver, sets incorrect tolerance values, or misconfigures output
options.
G.6. Dimension 6: Executable Correctness Rate
Definition: The average correctness rate among executable code across all levels.
Calculation: The executable correctness rate is:
Exec Correct Rate =
P4
‚Ñì=1 Ec
‚Ñì
P4
‚Ñì=1 E‚Ñì
√ó 100%
(29)
where Ec
‚Ñìdenotes the number of executable and correct implementations at level ‚Ñì.
Interpretation: This dimension measures the model‚Äôs conditional correctness given that it produces executable code. A high executable
correctness rate but low overall performance suggests that the model understands the task conceptually but struggles with implementation
details. Conversely, a low executable correctness rate indicates that even when the code runs, it often produces incorrect results due to
logical errors or misunderstanding of the problem specification.
G.7. Summary and Usage
The six-dimensional framework provides a comprehensive view of model capabilities across different aspects of OPF modeling. By
analyzing these dimensions jointly (e.g., via radar charts as in Table 4), we can identify specific bottlenecks:
‚Ä¢ Low Executable Rate ‚áíbasic coding/API proficiency issues
‚Ä¢ Low Semantic Param Inf ‚áídifficulty in natural language understanding and domain knowledge
‚Ä¢ Low Structural Mod ‚áífailure to recognize when structural modifications are needed
‚Ä¢ High Structural Mod but low Level 3/4 performance ‚áíconceptual understanding exists but implementation barriers prevent
success
‚Ä¢ High Exec Correct Rate but low overall performance ‚áíimplementation barriers rather than conceptual misunderstanding
This diagnostic framework enables targeted improvements for future model development and training strategies.
49


--- Page 50 ---
Title Suppressed Due to Excessive Size
H. Additional Experiments Results
Table 9 presents extended experimental results with additional model variants. The findings are consistent with the main results: concrete
modeling (Levels 1/3) significantly outperforms abstract modeling (Levels 2/4), with Level 4 remaining at 0% across all models. Among
the additional models, DeepSeek-r1 achieves the highest average performance (31%) under few-shot prompting, primarily due to its
relatively strong performance on Level 3 (16%) compared to other models. However, all models struggle with abstract modeling tasks,
reinforcing the conclusion that semantic parameter inference and MATPOWER implementation remain fundamental challenges for current
LLMs.
Table 9. Model Performance on Different Levels
Model
Concrete Modeling
Abstract Modeling
Average
Level 1
Level 3
Level 2
Level 4
Few-shot Prompt
GPT-5.2
33.33%
10.34%
6.67%
0.00%
14.05%
GPT-5.1
61.11%
6.90%
10.00%
0.00%
22.31%
Claude 4.5 Sonnet
77.78%
37.93%
6.67%
0.00%
33.88%
Claude 3.5 Sonnet
58.33%
0.00%
10.00%
0.00%
19.83%
DeepSeek-V3.2
94.44%
6.90%
0.00%
0.00%
29.75%
DeepSeek-r1
94.44%
17.24%
16.67%
0.00%
36.36%
Gemini 3.0 Pro
94.44%
31.03%
6.67%
0.00%
37.19%
Qwen3-Coder
80.56%
0.00%
0.00%
0.00%
23.97%
Qwen3-30B-A3B
50.00%
0.00%
0.00%
0.00%
14.88%
Zero-shot Prompt
GPT-5.2
25.00%
6.90%
6.67%
0.00%
10.74%
GPT-5.1
22.22%
0.00%
6.67%
0.00%
8.26%
Claude 4.5 Sonnet
66.67%
6.90%
6.67%
0.00%
23.14%
Claude 3.5 Sonnet
16.67%
6.90%
0.00%
0.00%
6.61%
DeepSeek-v3.2
61.11%
0.00%
0.00%
0.00%
18.18%
DeepSeek-r1
5.56%
0.00%
0.00%
0.00%
1.65%
Gemini 3.0 Pro
77.78%
13.79%
0.00%
0.00%
26.45%
Qwen3-Coder
13.89%
6.90%
0.00%
0.00%
5.79%
Qwen3-30B-A3B
0.00%
0.00%
0.00%
0.00%
0.00%
50
